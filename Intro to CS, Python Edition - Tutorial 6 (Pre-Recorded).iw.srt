1
00:00:00,520 --> 00:00:30,520
היי, ברוכים הבאים לתרגול השישי של מבוא למדעי המחשב. התרגול הזה הוא קצת שונה מאלה שקדמו לו, בגלל שהפעם, אנחנו נתעסק קצת יותר בדקויות של פייתון עצמה כשפה, שוב בזה בגריך, ונשים לב לדברים שאולי יעבדו בצורה שלא בדיוק חשבנו שהם יעבדו. אני אפילו אגיד לכם עכשיו, חלק מהדברים שבתרגול הזה הם אפילו חדשים לי,

2
00:00:30,520 --> 00:00:59,660
בתור אחד שהיה פה כמה שנים באוניברסיטה. אז בואו נתחיל. אתם אולי זוכרים בהתחלת הקורס, כשבדיוק למדנו על הנושא הזה של משתנים, אמרנו, אנחנו מן הסתם לא נרצה לקלוט ולכתוב דברים ישירות לכתובות מסוימות בזיכרון של מחשב, אלא אנחנו נרצה לעבוד בעזרת משתנים ופונקציות, ונעשה שינויים על אותם משתנים.

3
00:00:59,660 --> 00:01:14,140
אבל מה בעצם קורה עם המשתנים האלה? על מה הם מסתכלים? מה המשתנים האלה מייצגים? כתובות? מקום בזיכרון? אז בואו טיפה נעמיק בזה.

4
00:01:14,140 --> 00:01:44,040
יש בפייתון אופרטור שפשוט קוראים לו איי-די, שאם אתם עוטפים משתנה באיי-די בסוגריים, אתם בעצם תקבלו סוג של מספר ארוך מאוד כזה, שהוא כביכול הכתובת של אותו משתנה בזיכרון. עכשיו אני אומר לכם כביכול, כי בסופו של דבר פייתון זה שפת תכנות שעובדת בהרבה מכשירים, הרבה מחשבים.

5
00:01:44,040 --> 00:02:03,780
וכל מיני מערכות הפעלה, אז בסופו של דבר כשפייתון מסתכל על זיכרון, הוא מסתכל על גרסה וירטואלית של הזיכרון, ואז כל מחשב בנפרד עם מערכת ההפעלה שלו בנפרד, היא זאת שמתרגמת את הדברים האלה למה שהמחשב מבין.

6
00:02:03,780 --> 00:02:33,700
אבל אנחנו לא נרד לרמת המחשב, אז כרגע אנחנו פשוט נסתכל על מספרי ה-ID האלה שאנחנו נראה עבור משתנים שונים, ומבחינתנו אנחנו נבין שכל ID שונה כזה, הכוונה היא מקום אחר בזיכרון. אז לדוגמה, כאן אנחנו מגדירים משתנה בשם נעם, נותנים לו ערך 3, אחר כך אנחנו נגדיר משתנה אחר, ניו-נעם, ניתן לו את הערך של נעם.

7
00:02:33,700 --> 00:03:03,660
ועוד 4, זאת אומרת נעם זה 3 וניו-נעם זה 7, שני אינטג'רים שונים, כל אחד יש ערך שונה, ובהתאם כאשר נריץ ID בסוגריים על נעם, נקבל מספר ID כלשהו, ואם נריץ את זה על ניו-נעם, אנחנו נקבל ID אחר. ושתדעו, הם לא בהכרח חייבים להיות קרובים אחד לשני לזיכרון.

8
00:03:04,300 --> 00:03:33,620
פה ספציפית, אם אנחנו נסתכל, אנחנו נגלה שהמספרי ID שהם קיבלו, הם בערך קרובים בזיכרון, אבל זה לא בהכרח חייב להיות ככה. בסופו של דבר, לפייתון יש את הלוגיקה שלו, ואת הצרכים של המחשב, לאיפה לשים דברים בזיכרון, אז אל תנסו לפתח ציפיות לגבי מספר ה-ID של משתנים שונים. אז מה יקרה, אם אנחנו...

9
00:03:33,620 --> 00:04:03,620
בואו נכתוב בפייתון כזה דבר A שווה 3 ואז B גם שווה 3. אז השאלה היא מה ה-ID של A ו-B יהיו, אז מן הסתם שלא מצופה שאתם תדעו לנחש מספר של כל כך הרבה ספרות. אבל השאלה כאן היא האם יהיו להם ID שונים? כי A ו-B זה כביכול משתנים שונים. אז התשובה היא שלא. ...

10
00:04:03,620 --> 00:04:31,400
מתברר שאם אתם לוקחים אינטג'רים כאלה פשוטים בערכים קטנים, ואתם שמים אותם במשתנים שונים, אבל כאילו אותו אינטג'ר בשני משתנים נפרדים, אז פייתון מבחינתו, שני המשתנים האלה, יש להם אותו איי-די. מה זה אומר? אז אנחנו נחשוב על זה קצת. בואו נראה עוד דוגמאות.

11
00:04:31,400 --> 00:05:01,240
אנחנו יכולים לקחת את הערך מינוס חמש, לשים אותו בשני משתנים שונים, או לקחת את הערך 200, גם אינטג'ר, לשים אותו בשני משתנים שונים, אבל גם פה וגם פה יש להם את אותו איי-די. כלומר, ראינו פה דוגמאות של אינטג'רים בערכים לא מאוד גדולים, לחיוב או לשלילה, שאם אנחנו לוקחים את אותו אינטג'ר ושמים אותו במשתנים נפרדים, עדיין יהיה להם את אותו איי-די.

12
00:05:01,240 --> 00:05:31,240
אותו איי-די, מה זאת אומרת? זאת אומרת שני משתנים אבל הם מצביעים לאותו מקום בזיכרון? אז זה כאילו לקחת אותו דבר ולתת לו פשוט שני שמות נפרדים, אבל זה אותו דבר, פיזית, בזיכרון אותו דבר, מעניין. מה לגבי 300? הופה, הפעם אפילו שנבאת מספיק שאלה תהיה בחיים. ותעשה סציני

13
00:05:31,240 --> 00:06:01,240
ל-A ול-B יש את אותו ערך 300. למשתנים A ו-B יש באמת ID's שונים, כלומר הם בהכרח מסתכלים על כתובות שונות, בנפרד. כלומר אני ממש יכול להגיד לכם שהמשתנה A, הערך שהוא מסתכל עליו בזיכרון נמצא במקום אחר מהערך ש-B מסתכל עליו בזיכרון. אז מה הקטע? מה קורה פה? איזו עקביות יש כאן? אז...

14
00:06:01,240 --> 00:06:31,240
מתברר שבפייתון אם אתם לוקחים לדוגמה אינטג'רים מספרים שלמים והערך שלהם הוא בין מינוס חמש כולל ל-256 כולל, אז אם נניח אתם לוקחים כזה דבר ושמים אותו בכמה משתנים נפרדים, אז אותם משתנים הם עדיין יצביעו לזה. זאת אומרת, אני עכשיו מריץ לכם פייתון ואני אומר: "איי

15
00:06:31,240 --> 00:06:52,400
שווה 200, b שווה 200, c שווה 10, d שווה 10, אז עכשיו אני עושה, מה ה-id של a? מה ה-id של b? אותו ה-ids, מה ה-id של c? מה ה-id של d?

16
00:06:52,400 --> 00:07:21,420
אז ל-c ול-d יש את אותם ה-ids, ל-b ול-a יש את אותם ה-ids, אז בעצם, אפילו שיש לי כאן ארבעה משתנים, הזוג הזה יש את אותו ערך, ויותר מזה, הם מסתכלים בדיוק על אותו מקום בזיכרון, ואותו דבר לגבי הזוג c ו-d, אז מתברר שבפייתון, יש קצת חיסכון בזיכרון, מה שנקרא.

17
00:07:21,420 --> 00:07:51,420
פייתון בעיקר כשאתם מביאים לו ערכים כאלה פשוטים, הוא לא בהכרח ייצור עוד קופי נפרד שלהם בזיכרון, מעניין הסיפור הזה, מה עוד אנחנו יכולים לראות על זה? מה לגבי ערכים מסוגים שונים? ...אם אנחנו עכשיו גילינו שפייתון בעצם משקר לנו ברקע ואומר כן כן זה משתנים שונים משתנים שנים אבל בעצם לא באמת... יש להם את אותו ערך ויותר מזה שפייתון שמעניין אותו בעצם משתנים שונים אבל בעצם לא באמת יש להם את אותו ערך ויותר מזה שפייתון שמעניין אותו בעצם משתנים שונים ואומר כן כן זה משתנים שונים משתנים שונים אבל בעצם לא באמת

18
00:07:51,420 --> 00:08:21,420
זה ערך פשוט, אז נשים פעם אחת, עותק שזה בזכרון, ופשוט שני אנשים שיסתכלו על אותו דבר. אוקיי. מה אין דברים אחרים? בוליאן. אנחנו יודעים שבוליאן זה משתנה מהסוג הכי פשוט שבעולם, כי זה או true או false. מספיק ביט אחד לייצג את זה, לא? אז יש לנו פה a שווה true ו b שווה true. האם יש להם את אותו id? שאלה טובה. או מה לגבי float? משתנה שהוא כביכול יותר מסובך..

19
00:08:21,420 --> 00:08:46,040
אז נניח נביא איזשהו פלוט כזה של 1.311331 לשני משתנים, מה הID שיהיו להם? אז ככה, מבחינת הבוליין זה טריוויאלי, True זה פשוט True, False זה פשוט False, אז הייתי אומר זה חיסכון פשוט מאוד לעשות בזיכרון, לא? אז פייתון עושה את זה.

20
00:08:46,060 --> 00:09:16,040
אם אתם מביאים שני משתנים את הערך True, פייתון צריך יותר ממקום אחד בזיכרון להחסן את הערך True? לא נראה לי. אז פייתון בוחר שלא, רק מקום אחד. ואם יש לשני משתנים את הערך True, אז לשני משתנים יש ערך שנמצא במקום אחד בזיכרון. מנגד, פלוט זה סיפור יותר מסובך, ופייתון, כמו שאתם רואים, שמר כאן את A ואת B, שמר את ה-R.

21
00:09:16,040 --> 00:09:46,020
הערכים שלהם הם במקומות שונים בזיכרון. זאת אומרת, A מצביע על ערך שנמצא במקום אחד בזיכרון, ו-B מצביע על ערך שנמצא במקום אחר בזיכרון. אבל מה? יש טריק. אם אתם הייתם מריצים בפייתון, את פקודת השוויון, את האופרטור הסמה יותר נכון, אבל כמו שאתם רואים כאן עם פסיק, אז בפייתון זה יעבוד שונה, ואני רוצה להראות לכם את זה. אז בואו תראו, נניח שאני...

22
00:09:46,020 --> 00:10:16,000
באמת, אני אעשה פה את הדוגמה שאתם ראיתם למעלה. אני אקח נניח את הפלוט הזה, A שווה 1.311, B שווה 1.311, אז ID של A, ID של B, יש להם ID שונים. אבל עכשיו אני אגיד את האופרטור שווה בפקודה אחת, שאני בעצם מביא לה את שני המשתנים, A ו-B. ועכשיו אני אומר, יש לכם את הערך 1.311.

23
00:10:16,000 --> 00:10:46,000
אחד-אחד, שניכם, הרי אם אתם הגעתם עד לשלב הזה של הקורס, ועקבתם אחרי כל הדקויות הקטנות של מה שלימדנו אתכם, אתם בעצם תשימו לב שזה שאני כותב את הדבר הזה בשורה אחת, זה כאילו שאני שולח לפונקציה כלשהי, לאופרטור שווה הזה, כביכול שני פרמ... כאילו את שני המשתנים האלה A ו-B, ואת שני הערכים האלה כשני פרמטרים, אז כנראה שהפונקציה היא, המימוש של האופרטור שווה הזה יוצא לא־ בשורה אחת מאז צומח

24
00:10:46,000 --> 00:10:52,760
הפקראטור שווה הזה, הוא יודע להסיק מסקנות כשאני נותן לו את כל המידע הזה בפקודה אחת.

25
00:10:53,980 --> 00:11:02,280
אז נניח שאמרתי את זה, ועכשיו, מה ה-ID של A? מה ה-ID של B? הופה, אותו ID.

26
00:11:03,380 --> 00:11:15,760
אז הנה דקות מעניינת. בסדר, אז בואו נחזור אחורה. ראינו פה כמה דברים מאוד מאוד מעניינים ומוזרים, שלמרות שאנחנו...

27
00:11:15,760 --> 00:11:45,660
כאילו, שומרים ערך כלשהו במשתנים נפרדים, מתברר שפייתון יכול לתת להם את אותה כתובת. כלומר, שני שמות לאותו דבר בדיוק, פיזית, בזיכרון. אז מה זאת אומרת? לא אמרנו מקודם שמשתנה מייצג מקום בזיכרון, ושאנחנו נותנים לו שם כדי להשתמש בו, זאת אומרת, מבחינתנו, הכוונה הייתה שבהכך A, משתנה A, זה בעצם יהיה כותרת לאיזשהו מקום בזיכרון.

28
00:11:45,660 --> 00:12:13,760
ומשתנה אחר, וכך היא יכותרת למקום אחר בזיכרון. זו הייתה ההנחה שלנו, זה היה הדרך שבה אנחנו הבנו תכנות מהיום הראשון. אז זה נכון בחלק מהמקרים, בחלק משפות התכנות, אבל מתברר שיש פה סיבוכיות קצת יותר גדולה מזה. אז במקום זאת, אנחנו נרצה להבין,

29
00:12:13,760 --> 00:12:43,720
שמשתנה, הוא פשוט מצביע למה שנקרא אובייקט. אני לא יודע אם אתם זוכרים שבתרגול הקודם הסתכלנו על דוגמאות בפייתון טיוטר, ושמה ראיתם מימין, לקוד, היה לכם אובייקטיים, ואת הפרימים, הפריים גלובליים, פריים של פונקציה. אז עכשיו אנחנו קצת טיפה נרחיב יותר על נושא הזה, נדבר עליו יותר בצורה ישירה. אז תסתכלו על מה שאתם רואים כאן.

30
00:12:43,720 --> 00:13:13,720
נניח שאנחנו כותבים קוד פשוט מאוד a שווה 2 b שווה 2 ו c שווה 1 כביכול שלושה משתנים שונים אבל מה? a ו b יש להם את אותם ערכים אינטג'רים קטנים ופשוטים אז מה שיקרה במציאות אפילו שהרצנו את שלוש פקודות ההסמה האלה מה שפייתון יעשה ברקע הוא בבינתיים בעבר בשורה שלנו שלנו ומשום דבר שמגיע בכלל מערך אמצעים שלנו אבל אנחנו צריכים לדעת ולהגיד לזה אותה תחוץ שלנו איזה שהצדק לא ניתן להם להגיב אותנו דבר מכך שמגיעה להם כי הוא ואף כן לא ניתן לך לגרור במזוננו לחזים אותנו

31
00:13:13,720 --> 00:13:43,720
בעצם יגרום לכך שגם ל-A וגם ל-B יהיה את אותו ה-ID, כלומר, גם המשתנה A וגם המשתנה B יצביעו לאותו אובייקט בזיכרון, אובייקט, פשוט, ערך שנמצא בזיכרון, הרי בסופו של דבר, לא משנה כמה דברים יהיו מסובכים בעולם של מחשבים ובתכנות, ברמה הכי הכי בסיסית, הכי הכי פשוטה שיש, יש לכם הרכיב.

32
00:13:43,720 --> 00:14:13,720
מבינארים בזיכרון פשוט ערכים מספרים בבינארי אתם מתרגמים אותם לכל בסיס שבא לכם זה פשוט ערך value מספר אז במקרה כאן בחרנו לשים את הערך 2 למשתנה A את הערך 2 למשתנה B פייתון ראה את זה והוא החליט שוואלה A ו-B הם בעצם יסתכלו על אותו ערך בזיכרון אפילו שאנחנו

33
00:14:13,720 --> 00:14:43,720
קוראים להם משתנים שונים. ואז הבאנו ל-C ערך שהוא שונה לגמרי, אז פייתון הבין שאין לו ברירה, הוא הולך עכשיו למקום אחר בזיכרון, שם שם את הערך אחד, קורא לזה אובייקט עם ה-ID כך וכך וכך וגורם ל-C להיות מצביע על האובייקט הזה. זאת אומרת, כן משתנים הם כביכול כותרת ייצוג של מקום בזיכרון, אבל...

34
00:14:43,720 --> 00:15:04,700
אבל מה? יש איתך כמויות, חסכונות, כי הרי תחשבו לזה, אחרת היינו צריכים להיות עם שלושה אובייקטים בזיכרון, וזה סתם היה בזבוז, כי כרגע ל-A ו-B אותו ערך, אז יאללה, ערך כזה פשוט, מספר של אין כזה פשוט, כזה קטן, אובייקט אחד ממנו.

35
00:15:04,700 --> 00:15:34,680
בואו נעשה לעצמנו אגב, דרך אגב, את החיים קלים יותר. במקום לכתוב כל הזמן את האופרטור איי-די, ואז מסוגריים שם של משתנה, אנחנו יכולים להיעזר באופרטור, גם משהו קטע כזה של פייתון, דרך אגב, נקרא לו אופרטור איז. מה הוא עושה? הוא בעצם בודק האם המשתנה מצד שמאל, מצביע על...

36
00:15:34,680 --> 00:16:04,680
אותו אובייקט בדיוק כמו המשתנה מצד ימין. אז במילים אחרות, אם אני כותב עכשיו a שווה 3, b שווה 3, ואז אני שואל האם a הוא b? כלומר, האם המשתנה a מצביע על אותו אובייקט בזיכרון בדיוק, כמו אובייקט b? אז התשובה תיתרו עכשיו, שימו לב, השאלה הזאת אם a הוא b, זו שאלה שהיא אפילו, בדיוק, לא שונת לכלי

37
00:16:04,680 --> 00:16:34,640
אפילו יותר עוצמתית מלשאול האם A שווה שווה B, כי מקודם אתם ראיתם את אופרטור שווה שווה, אבל זה רק שאל אם הערך ש-A מצביע עליו הוא פשוט אותו ערך מבחינה מתמטית, כמו הערך ש-B מצביע עליו, אבל הם יכלו להיות אותו ערך, אבל שני העתקים שונים בזיכרון. פה אופרטור Ease שואל שאלה חזקה יותר.

38
00:16:34,640 --> 00:16:42,820
A, האם אתה מסתכל על אותו אובייקט כמו B, האם אתם שניכם שתי כותרות שונות לאותו דבר בזיכרון?

39
00:16:42,820 --> 00:16:57,680
במקרה הטריוויאלי הזה כאן, כשל-A ול-B נתנו את ערך 3, התשובה היא כן. מה שאתם ראיתם פה, אז תחליפו במקום 2 פה 3, אבל אותו קונספט בדיוק. זה מה שזה היה.

40
00:16:57,680 --> 00:17:25,540
אז בעצם, אם אתם רוצים אגב לתת לזה שם, אתם יכולים להגיד שפייתון עשה סוג של לייזי אלוקיישן. כלומר, פייתון במירכאות התעצל, ומבחינתו הוא לא יצר אובייקט חדש בזיכרון, כל עוד שלא עשיתם משהו שמכריח אותו להתעסק עם שני ערכים בצורה שונה.

41
00:17:25,540 --> 00:17:55,440
אז נניח, כשאמרתם A שווה 3, זה הפעם הראשונה שפייתון הבין שאתם רוצים אובייקט עם ערך של 3, אז בסדר, הוא הלך לזיכרון, הקצה מקום שמה, יצר אובייקט עם הערך 3, וזהו. כשאמרתם B שווה 3, עד לכאן, לא רציתם להיות משהו יותר מזה, רק רציתם עוד משתנים אותו ערך. אז פייתון לא יצר עוד ערך חדש בזיכרון.

42
00:17:55,440 --> 00:18:04,300
אלא אמר, אה, אוקיי, מה שתגיד, ופשוט שם מצביע נוסף לאותו ערך בזיכרון.

43
00:18:05,040 --> 00:18:09,720
אז זה, זה כאילו אלוקציה עצלנית, מה שנקרא.

44
00:18:10,760 --> 00:18:25,260
אבל אם אתם אגב רוצים לחקור על זה קצת יותר, לקונספט הזה של, כל הרעיון הזה של כמה משתנים שמצביעים לאותו אובייקט בדיוק בגלל סיבות כאלה של חיסכון,

45
00:18:25,260 --> 00:18:33,860
לדבר הזה קוראים Object Interning, אם תרצו לחפש על זה מידע באינטרנט זה השם בדיוק של הרעיון הזה.

46
00:18:33,860 --> 00:18:42,260
אוקיי, מעניין, מעניין, אפילו משהו שאני לא בהכרח הכרתי כמו שצריך עד עכשיו, אפילו שכתבתי בפייתון.

47
00:18:42,260 --> 00:18:55,060
אז בואו נראה עוד כמה דוגמאות לזה. אז לדוגמא, עבור A שווה מינוס 10 ו-B מינוס 10, האם A זה B? או מה אם...

48
00:18:55,060 --> 00:19:21,260
A ו-B הם 199, A ו-B הם 1.1 או A ו-B הם התו אחד, אז בואו נבדוק עבור התרחישים האלה, האם בכל אחד מארבע המקרים האלה, A ו-B הם מצביעים על אותו אובייקט, כלומר, האם A הוא ממש B, לא סתם לפי ערך, אלא בקטע של מסתכל על אותו אובייקט, אז בואו נראה.

49
00:19:22,300 --> 00:19:40,260
אז זה דוגמא, כמו שראינו מקודם, במקרה של אינטג'רים, מספרים שלמים, רק בתחום שבין מינוס 5 ל-256, יש את הדבר הזה שקוראים לו אובייקט אין טרנינג, בין משתנים, אז פה זה, רגע, פה זה פולס.

50
00:19:41,880 --> 00:19:48,840
199 זה כן נמצא בתחום הזה, אז טרו, כלומר, A הוא לא רק שווה ל-B, אלא A הוא ממש B.

51
00:19:50,800 --> 00:20:20,760
ראינו פה שבפקודות שווה, באופרטורי הסמה, נפרדים, לא נצליח להגיע למצב ש-A יהיה על אותו אובייקט כמו B כאן, אבל ראינו דוגמה מעניינת שבה אנחנו כן יכולנו בעצם להכריח אופרטור הסמה, לעשות אובייקט אין טרנינג בין A ו-B, כלומר, בשקט פייתון הבין, אה, אוקיי, הבאתי לי אותו ערך פה, אפילו זה פלוט, כן, אני עושה ש-A,  .

52
00:20:20,760 --> 00:20:50,760
צביע ובי הצביעו על אותו אובייקט אז אתם ראיתם את הדוגמה קיצונית כאן אז אם לא יודע בעתיד הרחוק. איך שהוא תרצו להיות חסכונים בזיכרון בפלואטס אז אולי תזכו אחורה בראיון הזה כאן ואולי תעשו את זה, או אולי לא, לא יודע, דברים משתנים בעולם התכנות. א�ral מה עוד ראינו? קרקטר טבסקי אנחנו יודעים שקרקטר בעצם תאגם טבסקי

53
00:20:50,760 --> 00:21:13,340
ואזקי זה בעצם איך מספרי לא מאוד גדול, וכמו שאתה אומר כאן, לפחות עבור את הוואסקי אחד, כן, אנחנו נקבל ש-A הוא ממש בי. אז דברים מעניינים, הבדלים שאולי כדאי שנזכור, מי יודע? אולי זה יעזור לנו לכתוב קוד חסכונים בעתיד.

54
00:21:15,840 --> 00:21:45,820
עכשיו, ראינו מה קורה כשאנחנו בסך הכל שמים את אותו ערך לשני משתנים, אבל עד כאן לא נתנו לפייתון סיבה לעבוד קשה, רק אמרנו, תן את אותו ערך לשני משתנים נפרדים. אז ברור שנתנו לפייתון את כל ההזדמנויות שהוא רוצה לתת לשני משתנים אותו בייט. אז עכשיו השאלה היא, מה קורה כשאנחנו רוצים...

55
00:21:45,820 --> 00:22:15,800
לעשות את ההשוואות האלה, אז, או אולי אחר כך לעשות שינויים. אז בואו נעשה דבר ראשון, קודם כל. נראה מה קורה כשאנחנו אומרים משתנה שווה משתנה אחר. אז נניח הגדרנו A שווה 3, אחר כך אמרנו B שווה A, אז מה קרה? אנחנו בעצם באופן די ישיר אמרנו לפייתון, היי פייתון, בבקשה תעשה עכשיו שמשתנה בשם B יצביע לאותו דבר בדיוק שמשתנה...

56
00:22:15,800 --> 00:22:45,800
בשם M מסתכל עליו. זה ממש קטע כזה אופרטור הסמה, ועכשיו אבל מה קורה כשבאמת אנחנו רוצים לתת לבי ערך אחר, עכשיו אנחנו אומרים "פייתון בבקשה, תעשה שבי יצביע לערך, יצביע לאובייקט עם ה-X86" ואם כזה אובייקט לא היה קיים עדיין אז "פייתון" הבין "טוב אין ברירה, עכשיו בי

57
00:22:45,800 --> 00:23:04,760
אין לו, המשתמש לא ביקש ממני שלB יהיה את אותו ערך כמו של A יש, כבר לא. אז אין לי ברירה, אלא כן להקצות מקום אחר בזיכרון, לשים שם אובייקט עם ערך 6, והמספר ID שלו שהוא שונה, וזהו. אז אתם רואים את ההבדל בסך הכל.

58
00:23:04,760 --> 00:23:34,420
אם מקודם A ו-B הצביעו לאותו דבר, כי אמרנו בצורה מפורשת, תעשה ש-B יהיה בדיוק A, עכשיו זה לא אותו דבר. שני משתנים, שני ערכים שונים, שני מקומות שונים בזיכרון. זה אולי הדבר הכי טבעי לדמיין בעולם המחשבים. אז מה קרה כאן? בדיוק מה שהסברנו. בהתחלה הצביעו לאותו דבר, ועכשיו אמרנו B צריך להיות עם ערך שונה, וזה אומר ש...

59
00:23:34,420 --> 00:23:58,860
שפייתון יצא אובייקט חדש, אז זה לא שבטעות שברנו את כל העולם, ועכשיו החלפנו גם את הערך שב-A. זה לא מה שהתכוונו, וכשאנחנו עובדים משתנים כל כך פשוטים, אז מה שאתם הכרתם עד עכשיו, עובד, בסדר? אם בהתחלה היה לכם שוויון, ואז אמרתם, לא ערך אחר, זה עובד. אז עד כאן זה לא משהו חדש.

60
00:23:58,860 --> 00:24:28,680
למעשה, בואו ניתן לדבר הזה שם. כשאנחנו מתעסקים עם ערכים כמו אינטג'רים, או סטרינגים וכאלה, כאלה אובייקטים כאלה, שאתם לא יכולים לשנות את הערך שלהם, זה פשוט, יצרתם אובייקט עם ערך, ואם אתם רוצים עכשיו ערך אחר, אז הוא נאלץ ליצור אובייקט אחר.

61
00:24:28,680 --> 00:24:58,660
בשבילהם, מקום אחר בזיכרון, עם ערך אחר. אז בואו תכירו קונספט חדש. מיוטבילטי, שזה יכולת שינוי, יכולת לשינוי של אובייקטים, בשפת תכנות לדוגמה. אז בואו נכיר כמה טיפוסים שאתם ראיתם עד עכשיו, ואנחנו עכשיו נלמד עליהם שהם למעשה, המשתנים האלה הם בעצם אובייקטים.

62
00:24:58,660 --> 00:25:28,660
שהם אמיוטאבל, אינם ברי שינוי, אז דברים כמו אינטגר, פלוט ובוליאנים הם אמיוטאבל, זאת אומרת יש לכם, כמו שראיתם כאן, היה לכם מקודם את המשתנה b, נכון, אמרתם b שווה a בסדר, הבאתם לו את אותו ערך כמו מה שהיה ל a, לא שיניתם אובייקט ואז כשאמרתם b עכשיו צריך להיות שווה 6..

63
00:25:28,660 --> 00:25:58,620
אז הוא לא יכול היה בעצם לשנות את זה. ודרך אגב, יכול להיות שהדוגמה שאתם רואים כאן מבלבת אתכם, אני רוצה להביא לכם דוגמה אפילו יותר פשוטה. אז בואו תראו כזה דבר. נניח a שווה 3, b שווה a, עכשיו אנחנו באמת אומרים id a, id b, יופי. עכשיו אני אומר b שווה 6, id b, אז אתם רואים שהוא התחלף ב-id שלו.

64
00:25:58,620 --> 00:26:03,020
ועכשיו אם אני אומר b שווה 9, זה מה שחשוב לשתירו עכשיו.

65
00:26:04,220 --> 00:26:07,940
עכשיו מה ה-id של b? ה-id שונה לגמרי.

66
00:26:08,100 --> 00:26:14,820
זאת אומרת, זה לא שהאובייקט שיצרנו ל-b השתנה, לא,

67
00:26:15,460 --> 00:26:22,140
נוצר אובייקט חדש, אחר, עבור b, כשבחרנו ל-b עכשיו ערך שונה.

68
00:26:22,980 --> 00:26:28,100
וזה הרעיון שלא אני קורא עם מיוטביליטי.

69
00:26:28,380 --> 00:26:35,300
כלומר, העובדה היא שיש סוגים של משתנים שכאשר אתם משנים את הערך שלהם,

70
00:26:36,260 --> 00:26:40,500
מתי שזה לא יהיה? במהלך התוכנה שלכם? במהלך הקוד שלכם?

71
00:26:41,820 --> 00:26:52,060
זה אומר שיווצר אובייקט חדש. לא שהאובייקט הקודם השתנה בערך שלו, אלא שפת התכנון תגיד, אני יוצר את אובייקט חדש.

72
00:26:52,460 --> 00:26:57,260
אני מחפש את מקום אחר בזיכרון ובונה אובייקט חדש שם.

73
00:26:57,260 --> 00:27:19,380
על שינוי ערך, זה אימיוטביליטי. אז למה בכלל אנחנו מדברים על זה? כי אתם תראו עוד מעט שיש מצד שני אובייקטים אחרים שהם כן מיוטביל, כלומר אובייקטים אחרים שאנחנו כן יכולים לשנות אותם, מה שנקרא אינפלייס במקום בזיכרון.

74
00:27:19,380 --> 00:27:49,340
אז קודם, אני רק אמשיך את המצגת, דיברנו על טיפוסי משתנים שהם אימיוטביל, אז אינטג'רים, פלואוטים, מספרים עם משהו אחרי הנקודה העשרונית, בוליאן, שזה פשוט אימיוטביל גם, והאמת גם מחוזות. לא יודע אם יצא לכם לראות את זה עד עכשיו, את השגיאה הזאת, אבל מצד אחד אתם כן יכולתם לגשת לתו מסוים בתוך מחוזת, על ידי אופרטור.

75
00:27:49,340 --> 00:28:19,300
אינדקס, כן, או אופרטור סוגריים מרובעות, אבל מצד שני, בחיים לא עבד לכם הניסיון לשנות מחוזת על ידי אופרטור הסמה להגיד מחוזת באינדקס כך וכך שווה תו כלשהו, זה לא יעבוד לכם, כי סטרינג מחוזת היא אימיוטביל, ברגע שבנית מחוזת יש לה את המקום שלה בזיכרון, ואם אתם רוצים לשנות אתם לא באמת יכולים לשנות.

76
00:28:20,040 --> 00:28:25,000
אתם כן יכולים לבנות מחוזת אחרת, במקום אחר בזיכרון.

77
00:28:26,680 --> 00:28:39,080
אז, דיברנו עכשיו על ה-Immutable Learning, ומקודם נתתי לכם רמז שאם יש דברים שהם Immutable, יש דברים אחרים שהם כן מיוטאבל. מה ברי שינוי?

78
00:28:40,960 --> 00:28:47,780
אז בואו נבדוק מה קורה ברשימות. יאללה, רשימות! אובייקט שבעצמו מכיל כמה...

79
00:28:47,820 --> 00:28:51,560
בעצמו מכיל כמה, ספוילר, אובייקטים.

80
00:28:51,560 --> 00:28:56,140
או יותר נכון, מצביעים לאובייקטים, כי פייתון אוהב להיות כזה.

81
00:28:56,140 --> 00:28:58,800
אבל לאט לאט, אני לא רוצה להמיס עליכם.

82
00:28:58,800 --> 00:29:00,980
אז בואו נסתכל ברשימות.

83
00:29:00,980 --> 00:29:05,160
נניח שהגדרנו A, תהיה רשימה עם מערכים, 1, 2, 3.

84
00:29:05,160 --> 00:29:15,680
אחר כך אמרנו B שווה A. אז עד כאן, אנחנו מקבלים את החיסכון שאנחנו בדיוק עכשיו לומדים שפייתון עושה.

85
00:29:15,680 --> 00:29:43,480
אמרנו לפייתון A, תביא משתנה B, שהוא יהיה בדיוק A, אופרטור שווה A. אז פייתון אומר, אין בעיות. אני אעשה ש-B עכשיו יצביע על אותו אובייקט כמו A. זאת אומרת, יש רשימה אחת בזיכרון, אבל יש לה שני שמות, גם A וגם B. אבל עכשיו תראו קטע. אמרנו כזה דבר, B באינדקס 2 עכשיו שווה 1. אז תראו מה קרה.

86
00:29:43,480 --> 00:30:13,380
קודם כל אינדקס 2. אינדקס 2 זה האיבר השלישי, אתם זוכרים? כי האינדקסים זה 0, 1, 2. אז אנחנו באמת שינינו את האיבר השלישי ברשימה הזאת, ברשימה ש-B מצביע עליה, אבל גם A מצביע עליה. וברגע שעשינו את זה, פייתון לא בצורה אוטומטית יצר אובייקט חדש עבור A.

87
00:30:13,380 --> 00:30:27,380
אז למעשה, זה שאנחנו עכשיו שינינו משהו ברשימה של B, זה בעצם שינה את הרשימה האחת שיש בזיכרון.

88
00:30:27,380 --> 00:30:37,380
אז זה שאמרנו B שווה A, אנחנו לא יצרנו עותק של הרשימה, אנחנו רק אמרנו, אני רוצה ש-B יהיה שווה A.

89
00:30:37,380 --> 00:31:01,380
אז אנחנו צריכים להיזהר באיך שאנחנו אומרים את זה, כי בפקודה כזאת, שני משתנים שהם בעצם אותו דבר, ולכן כשאנחנו משנים את הרשימה דרך משתנה אחד, אנחנו פשוט שינינו את הרשימה האחת שיש לשני המשתנים האלה, לא בהכרך מה שרצינו.

90
00:31:01,380 --> 00:31:16,380
אז מה אנחנו נעשה פה עכשיו, כשכזה דבר קורה, ששינינו את הרשימה באמת, אבל איך שהגדרנו את המשתנה השני שלנו, בעצם לא יצרנו עותק נפרד.

91
00:31:16,380 --> 00:31:28,380
אז ראינו פה עכשיו דוגמה קודם כל למיוטביליות של רשימה, כי וואלה, אנחנו שינינו את האובייקט רשימה בתוך המקום שלו.

92
00:31:28,380 --> 00:31:58,380
איל, אני רוצה אפילו להראות לכם שאנחנו לא עובדים על כן, בואו תראו מבחינת איי-די, מבחינת המיוטביל-יוט, אז אני אכתוב פה בדיוק את הקוד שאתם רואים, A שווה רשימה 1,2,3, B שווה A, אז רגע, קודם כל, ID A, ID B, יש להם את אותו ID בדיוק, עכשיו אני אעשה, B באינדקס 2 שווה 1, תראו לי את A, תראו לי את B, תראו לי את ה-RM שלהם, בדיוק את ה-RM שאתם רואים עליהם, בטוח. וזה לא שאני מכיר מה זה, פשוט ראיתם,

93
00:31:58,380 --> 00:32:08,260
איי-די של איי, אתה רואה את איי-די של בי, רואים? אותו איי-די בדיוק לכל אורך הדרך. שינינו את אובייקט הרשימה האחד הזה.

94
00:32:10,560 --> 00:32:21,020
אוקיי, אז זה היה מיוטביליות של רשימה, וגם על הדרך, תקלה, בגלל שלא ידענו שכשאמרנו בי שווה איי, זה לא יוצר עותק נפרד.

95
00:32:23,180 --> 00:32:31,020
אז כן, זו המסקנה האחרונה שמתבקשת, שלכל אורך הדרך הזאת, איי ובי, עדיין.

96
00:32:33,220 --> 00:32:52,540
בואו נסתכל אבל עמוק יותר בתוך רשימה. מה זאת רשימה? אז תראו קטע. נניח שאנחנו מגדירים איי שווה, רשימה שהיא עם האיברים 1 ו-2, אז מה זה האיברים האלה? למעשה, רשימה בעצמה...

97
00:32:52,540 --> 00:33:13,980
יש לה, כאילו, מצביעים לאובייקטים נפרדים, אז זה שיש לנו פה רשימה עם 1 ו-2, זה בעצם אובייקט עם איברים שכל אחד מהם הוא פשוט מצביע לאובייקט אחר, אז יש לנו מצביע לאובייקט שהערך שלו זה 1, ומצביע עם האובייקט שהערך שלו זה 2.

98
00:33:13,980 --> 00:33:43,900
אז פייתון בכלל תמיד, תמיד עושה גישות זיכרון כאלה. אתם לא, תראו, בעצם אתם ממש תגלו שבעולם המחשבים, אם אתם תעמיקו בזה, זאת אומרת, אתם תגלו שבעולם המחשבים דברים שמורים בזיכרון בצורה הרבה פחות רציפה ממה שהייתם מדמיינים. זה תוצאה של פשוט התקדמויות ואופטימיזציות.

99
00:33:43,900 --> 00:33:57,280
וההבנה שדברים לא חייבים להיות בצורה רציפה בזיכרון, אלא להפך, דברים יכולים להיות מפוזרים בזיכרון כדי שנוכל לשמור על מהירות הפעולות שלנו בדברים אחרים, אבל זה כבר לא נושא של הקורס שלנו.

100
00:33:57,280 --> 00:34:13,800
מה שכן אבל, תראו מה שקורה. נניח שיש לנו את הרשימה הזאת, עכשיו אנחנו משנים את הערך של האיבר השני להיות שלוש, אז מה שקרה, אתם זוכרים שאינטג'ר הוא אובייקט שהוא אימיוטאבל, שברגע שאתם משנים...

101
00:34:13,800 --> 00:34:43,440
ערך אינטג'רי, פשוט, לערך אחר, אז בעצם אתם יוצרים אובייקט אחר עם הערך האחר הזה. וזה מה שקרה פה, אנחנו לקחנו את אותה רשימה שהיא בעצמה מיוטאבל. כן, האיברים של רשימה יכולים להצביע למקומות נפרדים, שונים, אבל כשאנחנו משנים אחד מהאיברים שברשימה, אז זה בעצם כמו שאתם משנים משתנה שהוא אינטג'ר, אז הם בעצם אומרים לו, שומע?

102
00:34:43,440 --> 00:35:13,360
הערך שלך הוא צריך להיות שונה, אז עכשיו אתה הולך לקבל כתובת נפרדת לאובייקט אחר עם ערך אחר, אז תסתכלו עכשיו על ההבדל לפני, אחרי, לפני, אחרי. ID שונה, ערך שונה, זה אובייקט אחר לחלוטין. הרשימה עצמה אבל אותו ID בדיוק, כי הרשימה כאובייקט, היא השתנתה, אבל...

103
00:35:13,360 --> 00:35:42,620
באותו איי-די, זה משהו שכדאי לדעת ולהכיר ולשים לב אליו. אז מה בעצם אנחנו יכולים עכשיו להבין? אנחנו קודם כל יכולים להבין שרשימה עצמה היא סוג של אוסף של מצביעים, אם תרצו. אגב, חידה, מה קורה כשיש לכם כזה דבר? תראו קטע, רשימה A שווה 1,2,3.

104
00:35:42,620 --> 00:36:12,560
עכשיו אנחנו רוצים שהאיבר השלישי שמה, הערך שלו יהיה 1. רגע, יש לנו ערך אחד כלשהו, האם פייתון ידע לעשות משהו עם זה? כן. פייתון ידע לזהות ולשנות את זה כך שהאיבר השלישי ברשימה, כשאתם רואים לו הערך שלך עכשיו לחיות 1, שזה ערך שכבר קיים ברשימה, אז למעשה אתם תגלו שפייתון עכשיו יעשה שהרשימה A שתהיה עכשיו 1,2,1.

105
00:36:12,560 --> 00:36:42,460
אז האחדים האלה הם בעצם יהיו אותו אחד בזיכרון. הנה, אני רוצה גם להראות לכם את זה בלייב, שלא חס וחלילה תחשבו שזה לא זה. הנה, אני פותח פייתון מההתחלה. A שווה 1,2,3. מגניב. עכשיו אני אומר A אינדקס 2 שווה 1. קודם כל נתפיס את A, רואים את זה? עכשיו אני שואל, האם A באינדקס 0 זה בדיוק אותו אובייקט כמו A באינדקס 2?

106
00:36:42,460 --> 00:37:12,140
יס, זה לא סתם אותו ערך, זה אותו מקום בזיכרון. אז זה קטע שוואלה, טיפה מיינד בלואינג, אם יצא לכם לתכנית קצת זמן וחשבתם שאתם יודעים איך הדברים האלה עובדים. אז פייתון באמת דינמי, כשזה מגיע לאיפה לשים דברים בזיכרון ומתי להגיד שדבר הוא בעצם אותו דבר בדיוק. קטע כזה, מעניין.

107
00:37:12,140 --> 00:37:22,600
והנה האמת אנחנו יכולים לראות הדגמה כלשהי בוא נראה בפייתון טיוטר כי למה לא אז הנה תסתכלו איך זה נראה.

108
00:37:23,480 --> 00:37:35,340
הנה הקוד בדיוק שרצנו עכשיו בטרמינל שלנו אז תראו הגדרנו את הרשימה A אתם רואים בגלובל פריים כן כי אנחנו קוד ראשי.

109
00:37:36,980 --> 00:37:47,600
הנה אובייקט הרשימה שלנו שאתם רואים זה בעצם מצביע לאובייקט רשימה שכל איבר בא הוא בעצם מצביע לאובייקט אינטג'ר אחר.

110
00:37:48,060 --> 00:38:05,500
עכשיו אנחנו עושים A בינדקס 2 שווה 1 ותראו את הקטע הזה עכשיו A בינדקס 0 ו-A בינדקס 2 מצביעים לאותו אחד. אז וואלה קטע כזה נכון? זה קטע כזה ואז A בינדקס 0.

111
00:38:05,620 --> 00:38:35,400
איז אי אינדקס 2 פשוט קטע כזה. אוקיי אז בואו נעשה קצת רענון קטן. קודם כל יש אובייקטים שהם מיוטבול ואובייקטים שהם אי מיוטבול. אז מה אנחנו רואים כאן אובייקטים כמו מספרים, בוליאנים, מחוזות, טאפלס שאנחנו נדבר עליהם יותר מאוחר בקורס אבל כבר עכשיו אתם יכולים להבין אותם.

112
00:38:35,400 --> 00:39:05,400
אותם בתור עיניות סדורות, מה זה עיניות סדורות,אם אתם לומדים חדווה או מתמטיקה דיסקרטית זה פשוט אומר זוגות או שלשות או רביות, זה פשוט, תחשבו על זה כמו קבוצה, אבל שסדר העברים כן משנה. אז כאלה עיניות סדורות של מספרים או בייטים בכללי, זה אובייקטים שהם Update  שאתם חייבים ליצור אובייקט חדש בשביל ערך שונה.

113
00:39:05,400 --> 00:39:35,400
לעומת זאת, אובייקטים שהם כן מיוטאבל (מימולי), אז דברים כמו רשימות שאנחנו מכירים, או דברים יותר מתקדמים כמו דיקשינרייס או סטס, שכרגע מבחינתכם תחשבו עליהם בתור רשימות אבל מתקדמות יותר עם יותר מימדים אולי? אז מה בעצם אפשר להבין? הדברים האלה שהם כן מיוטאבל (מימולי), הם פשוט אוסף של מצביעים לאובייקטים אחרים.

114
00:39:35,400 --> 00:39:37,000
אז זה למה, כן?

115
00:39:38,380 --> 00:39:42,020
לא משנה, עדיין יש דקויות שאסור להתבלבל בהן.

116
00:39:42,960 --> 00:39:45,020
אז בואו נדבר טיפה על אופרטור שווה.

117
00:39:45,620 --> 00:39:50,920
זה שראינו מקודם שאומר משתנה B, תהיה בדיוק אותו דבר כמו משתנה A.

118
00:39:51,220 --> 00:39:52,120
אז מה קורה פה?

119
00:39:53,700 --> 00:40:05,220
אופרטור שווה יכול במקרים הרלוונטיים, ממש לפי הגדרה שלו, להגיד שמשתנה כלשהו יצביע לאותו אובייקט כמו משתנה אחר.

120
00:40:05,220 --> 00:40:34,640
אז בעצם אופרטור שווה לא בהכרח מעתיק או משכפל את הנתונים, הוא לא עושה עותק נפרד. הוא בעצם אומר שמשתנה מצד שמאל, אתה תצביע לאותו אובייקט שמשתנה מצד ימין מעביר, כאילו מצביע עליו. ממש ברמה של כתובת, זה כאילו, אתם אומרים B שווה A, אז מה אופרטור שווה עושה? הוא כזה לוקח את הכתובת של אובייקט ש-A מצביע עליו, ואומר B?

121
00:40:34,640 --> 00:41:04,600
עכשיו, אתה תצביע לאותה כתובת. אז זה מה שקרה שם בדוגמה שראינו מקודם, כשהיינו A שווה רשימה, אמרנו B שווה A עצמו, זאת אומרת, B שווה לאותו דבר ש-A מצביע עליו, ואז כששינינו ב-B, שינינו את הערך ההוא שברשימה ב-B, זה בעצם שינה את הרשימה האחת שגם A וגם B הצביעו עליהם. אז אופרטור שווה זה לא בדיוק קופי טהור.

122
00:41:04,600 --> 00:41:17,900
זה לא קופיט ההוא, זה ממש להגיד אתה תהיה אותו דבר, לא עותק של אותו דבר, אלא אתה תהיה אותו דבר, B אתה תהיה A.

123
00:41:19,700 --> 00:41:48,800
אז מתבקשת השאלה, בסדר. אז למדנו עכשיו שלמעשה אופרטור שווה, עושה את השוויון בצורה חכמה. למדנו שבעצם אופרטור שווה, כמה שהוא רק יכול, מנסה לעשות ככה שאנחנו לא יוצרים עותק נפרד, של אותו דבר בזיכרון. אבל איך כן? הרי, וואלה לפעמים אנחנו כן רוצים קופי טהור, שאיתו אפשר לעשות עבודה והיא תשנה דברים,

124
00:41:48,800 --> 00:42:18,780
והיא לא תשפיע על המקור, לפעמים אנחנו כן רוצים קופי נפרד. אז מה? מה אנחנו יכולים לעשות, כדי שאם נניח יש לנו רשימה כלשהי באובייקט A, נעשה משהו, כדי שיהיה לנו קופי של הרשימה הזאת במשתנה שנקרא לו B, אבל ש-A יהיה שונה מ-B. איך אנחנו נעשה את זה? אז יש כמה דרכים, יש כמה גישות ללכת לסיפור הזה. אתם אולי ראיתם את פונקציית קופי.

125
00:42:18,780 --> 00:42:48,780
שהיא פונקציה שעובדת על רשימות, לדוגמה. אולי ראיתם את זה בהרצאה, אני רוצה להראות לכם את זה עכשיו. אז בואו תראו. הנה, אני אפתח עכשיו פייתון מחדש. נגיד a שווה 1,2,3, b שווה a נקודה copy סגריים. זו פונקציה לרשימות. נריץ אותה. עכשיו אני שואל, האם a הוא b? וואלה לא! אוקיי, מה ה-d של a?

126
00:42:49,260 --> 00:43:01,780
מה ה-ID של B? סתכלו, ל-A ול-B יש ID's שונים, מגניב. בואו נתחכם קצת, מה ה-ID של...

127
00:43:03,100 --> 00:43:09,160
אוקיי, במקום זה אני פשוט אכתוב ישר, האם A באינדקס 0 הוא B באינדקס 0?

128
00:43:10,180 --> 00:43:40,140
או, מעניין, האם A באינדקס 1 הוא B באינדקס 1? כן, האם A באינדקס 2 הוא B באינדקס 2? מעניין. אז זאת אומרת, יש לנו שני אובייקטים נפרדים של רשימה, אבל הערכים שלהם מצביעים לאותם ערכים בזיכרון. כי בתכלס, עוד לא שינינו משהו ב-B. עכשיו אני כן רוצה לשנות. עכשיו אני רוצה להגיד ש-B באינדקס 2, אני רוצה שעכשיו הערך שלך...

129
00:43:40,140 --> 00:44:09,800
יהיה 1. ועכשיו אני אשאל, האם A באינדקס 2 הוא B באינדקס 2? מן הסתם שלא. האם B באינדקס 2 הוא B באינדקס 0? שימו לב, אמרתי לו 1. אוקיי, פייתון עדיין היה חסכוני פה. אה... בסדר. ועכשיו לבסוף אני אגיד B באינדקס 2 אתה עכשיו שווה 4. אז מן הסתם, עכשיו כבר שברתי את השוויון הזה.

130
00:44:09,800 --> 00:44:39,800
L, באינדקס 2 הוא כבר לא B בינדקס 2, כן? כי שוב, A, B בנפרד. אז זאת אומרת, האחד הזה, זה אותו אובייקט בזיכרון כמו האחד הזה של B, הששתיים הזה של A הוא אותו אובייקט בזיכרון כמו השתיים הזה של B, והשלוש והארבע האלה הם פשוט אובייקטים נפרדים בזיכרון עכשיו. זאת אומרת, שהצלחנו, בעזרת הפונקציה קופי הזאת, שהיא פונקציה שהיא עבור רשימות, כי שימו לב, עשינו a random.

131
00:44:39,800 --> 00:45:09,720
אז זאת אומרת, זו פונקציה שהיא מובנית עבור המשתנה של A, וה-A הוא משתנה מסוג רשימה. אז הצלחנו, יצרנו קופי של רשימה שהוא נפרד, הידד, יש עוד דרך, אולי ראיתם את הרעיון הזה של ליסט קום פריהנסן, שזה בכלל דרך ממש קלה לבנות רשימות, שתבינו, אני ממש רוצה להראות לכם את הקוד הזה גם, אז הנה, שוב, אני אפתח פייתון מחדש.

132
00:45:09,720 --> 00:45:35,000
תראו קטע, נגיד ש-A, שוב, שווה רשימה, טוב, הפעם ננסה אותה רשימה עד 4. עכשיו תראו מה זה, אני אומר B שווה מה? B שווה מספר אייטם אין, לא, 4, אל תתבלבלו, זה 4.

133
00:45:35,000 --> 00:46:03,780
אנחנו אומרים, B שווה רשימה, והתוכן שלה הוא כל מספר ב-4 מספר אין-A. כלומר, מה אני אומר? שימו לב. קודם כל, אתם מכירים את הביטוי 4, אנחנו אומרים, לכל מספר אין-A, אני רוצה שהמספר הזה יהיה אייבר ב-B. עכשיו A, עכשיו B, האם A הוא B?

134
00:46:03,780 --> 00:46:33,780
מעניין? אז יש לנו עכשיו שתי רשימות נפרדות עכשיו כמובן כרגיל אחרי סכנות של פייתון בהת אם A בינקס 1 זה עדיין B בינקס 1. בסדר. אבל עדיין.יקורפפרינצ'ן אתם תגלו שזה כלי נפלא כדי לבנות רשימות או מטריצות או מערכים ומה שזה לא יהיה בעתיד בצורה סופר פשוטה ואינטואיטיבית. פה אני פשוט אמרתי תביא לי רשימה.

135
00:46:33,780 --> 00:46:43,140
שהערכים שלה זאת פשוט כל המספרים in a אז אני אומר לכל מספר ב a תביא מספר.

136
00:46:43,140 --> 00:46:55,540
פשוט אותו n, תביא לי אותו בתור איבר בנפרד. זה קטע כזה, זה ממש קטע כיפי. אגב אני יכולתי לעשות משהו אחר, יכולתי להגיד b שווה n כפול 2.

137
00:46:55,540 --> 00:47:25,500
פורנה מ-a ואז בכלל מה זה b. כל מספר שיש ב-a יופי תביא לי את ה-p2 שלו אז הנה. סתם שאלה. יש לנו את a ויש לנו את b. האם b באינדקס 0 זה a באינדקס 1? אוקיי אז זה היה קצת חיסכון בסדר? הוא נאבק, הוא מתאמץ בסדר? זה ה-2 הזה זה אותו 2, 4 פה זה אותו 4 שם.

138
00:47:25,500 --> 00:47:55,420
אז אמנם זה לא תרגול ל-least comprehension אבל מי ששכח את זה ככלי, תכירו. חזק. יאללה. האם זה יותר מקופי? טוב ראינו עכשיו, כן? זה לא בדיוק היה זה. אז ראינו את ל-least comprehension, דרך אגב אפשר גם לעשות בסלייסס, אגב אם אנחנו רוצים לצור רשימה שהיא נפרדת, אז אנחנו בעצם יכולים להיעזר באופרטור סלייס.

139
00:47:55,420 --> 00:48:25,420
ואז אופרטור סלייס בהכרח מחזיר ליסט חדש אבל אם פה באמת אנחנו אומרים כזה דבר: "קודם כל מה זה A? הנה A. עכשיו B נניח שווה A אופרטור סלייס כזה שזה אומר לו מההתחלה שלך עד הסוף שלך הכל מהכל, כלומר אופרטור סוגריים ואז נקודתיים אחת אז כאילו הריינג' שלו מתחיל מ 0 ונגמר בעבר האחרון קולל".

140
00:48:25,420 --> 00:48:42,860
אז כשאנחנו אומרים את זה, נסתכל עכשיו על b, אז כן, יצרנו עותק נפרד של הרשימה, אבל אל תשכחו, העברים הם בעצם אותם איברים, כן? זה עדיין אותם איברים בדיוק.

141
00:48:42,860 --> 00:48:55,340
עכשיו, אולי הייתם רוצים לשאול אותנו, איך אפשר ליצור עותק של רשימה, ככה שאפילו ה...

142
00:48:55,340 --> 00:49:25,340
הערכים של הרשימה, מלכתחילה הם אובייקטים נפרדים. אז מה שאתם שואלים זה על הקונספט של דיפקופי. זאת אומרת, זה אולי משהו שאתם גם תיתקלו במעבדה של התרגול הזה, אבל מה שאתם רוצים זה בעצם אותק שנקרא אותק עמוק, כלומר, שלא רק שהרשימה היא… כאילו פה

143
00:49:25,340 --> 00:49:31,480
מה שאובייקט שונה, אלא גם האובייקטים שהרשימה מציבה אליה הם אובייקטים שונים.

144
00:49:32,240 --> 00:49:51,420
עכשיו, יש, מודול בפייתון, אגב אנחנו נלמד על מודולים יודע לי לצפצוף התרגול, אני מקדים את המאוחר, אבל אני יכול עכשיו לעשות,אממ אימפור, כזה... או להגיד, From, קופי, אימפורט, דיפ קופי.

145
00:49:52,700 --> 00:49:59,020
מה שאני עשיתי, אני הבאתי עכשיו פונקציה בשם דיפ קופי, מתוך מודול שהוא בילט אין בפייתון שקוראים לו קופי.

146
00:49:59,520 --> 00:50:22,500
הפונקציה דיפ קופי, ידנית, יוצרת אובייקט חדש, לכל אובייקט, שהמשתנה שלכם מכיל מצביעים בו. אז אם עכשיו אני אומר, הנה A, ו-B שווה...אמ... בוא ניצור דיפ קופי של A, עכשיו הנה B.

147
00:50:23,440 --> 00:50:28,540
אני שואל, האם A is B? לא. האם AB נקשה 0, EBT נקשה 0?

148
00:50:28,540 --> 00:50:52,440
true. אופה. (צחוק), התברר שאפילו זה לא עבד. ראית מה זה? אפילו הדיפקופי של פייתון לא עבד. אז אתם רוצים לדעת, "נו, אז איך אנחנו יכולים ליצור דיפקופי?", טוב, אני לא אגלה את הסודות שאתם תצטרכו להבין.

149
00:50:52,740 --> 00:51:02,320
אבל אם ממש הייתם רוצים רמז, איך אפשר ליצור דיפ קופי של רשימה, זאת אומרת, אותק שבה אפילו אובייקטים בנפרד, הייתי אומר, תתחכמו.

150
00:51:03,040 --> 00:51:22,680
תעשו שטויות עם מערכים, תשנו אותם, אולי תעבירו סוגעים משתנים, ואז כאילו בכוונה זה ייצור לכם אובייקטים חדשים. תעשו ניסויים, אבל מתברר שלעשות דיפ קופי זה קצת קשה, זה קצת קשה. אבל אני לא רוצה לחוג כרגע מאיפה שאנחנו בתרגול.

151
00:51:22,680 --> 00:51:52,300
בסדר, מעניין מאוד. יאללה, בואו נעבור הלאה. אז בואו באמת רק נסתכל קצת על הדבר הזה עוד טיפה, על ההבדלים, מה קורה כשאנחנו עושים שינויים ברשימות, מתי כן זה משתנה, מתי זה לא. אז נסתכל על הדוגמאות הראשונות האלה. נניח שאנחנו מגדירים A שווה 1,2,3, B שווה 1,2,3,

152
00:51:52,660 --> 00:52:22,200
ואז אנחנו שואלים, האם הערכים של A הם אותם הערכים כמו B, ואז בסוף אנחנו נשאל האם A הוא בעצם אותו אובייקט כמו B, או של אחרת, אם אנחנו עושים A שווה 1,2,3, ואז נעשה B שווה A, ואז נעשה אפנד ל-B עם ערך 4, ואנחנו נרצה לראות מה אנחנו נקבל ביניהם.

153
00:52:22,200 --> 00:52:52,180
אז בואו נסתכל. אז תראו, כשאמרנו קודם כל A שווה ככה וככה, ואז B שווה ככה וככה, אז כן, הבאנו את אותם הערכים ל-A ול-B, אבל עצם העובדה שאנחנו הגדרנו רשימה נפרדת עבור B, אז הוא כן יצר לו אובייקט רשימה נפרד. פשוט כמובן, אחר כך אתם תנסו להריץ A באינדקס 0 is A is B באינדקס 0, כלומר, אחר כך אתם...

154
00:52:52,180 --> 00:53:21,060
תרצו לבדוק, עדיין מתקיים מה שראיתם מקודם שה-1 הזה זה אותו 1 הזה, ה-2 כאן הוא אותו 2 כאן וכן הלאה, אבל הרשימות עצמן הן אובייקטים שונים. או מנגד, יש לכם את הקטע שאמרתם אופרטור שווה ל-B, אז בעצם הבאתם ל-B שיצביע לאותה רשימה בדיוק של A, ורק כשעשיתם ל-B אפנד, זאת הרשימה.

155
00:53:21,060 --> 00:53:51,060
אז זה שינה גם את הרשימה שההצביעה עליה, אותה רשימה, ועשינו את האפנד הזה לרשימה האחת שיש. אז כל band ל להבדל בין אופרטור שווה לבין אופרטור ease, שווה רק בודק ערך, ease בודק האם מדובר באותם אובייקטים בדיוק בזיכרון, וכאן זה כמו שראיתם כבר מקודם בתרגול שאנחנו עושים אפנד לרשימה אחת בזיכרון. שליה?

156
00:53:51,060 --> 00:54:01,320
שני מצביעים מצביעים, אז ברור שזה משינה את הרשימה האחת הזאת, ושני המשתנים שמצביעים לו את הרשימה, יראו את זה.

157
00:54:03,080 --> 00:54:21,020
האמת, בדיוק בשביל זה, יצרתי ככה קוד לשאלה אחד, שמראה את זה בצורה מאוד נוחה. יש פה אוסף של פרינטים, את המשתנים עצמם, וגם פרינטים שמדגישים את ההבדל ממש.

158
00:54:21,020 --> 00:54:50,760
אז בואו נסתכל בינתיים על הסעיפים הבאים בתור. בואו נסתכל דוגמא על סעיף ג'. מה קורה כאן? סעיף ג' אומר כזה דבר. ליסט אחד שווה לאחד וליסט שבפנים יש את האיברים שתיים ושלוש. תראו איך זה יכול לראות בזיכרון. הנה ליסט אחד משתנה, הנה האובייקט שהוא מצביע עליו, ואתם רואים שבעצם...

159
00:54:50,760 --> 00:55:08,680
באובייקט הזה יש שני מצביעים לשני איברים שונים, אחד הזה כאן, הוא בעצם מצביע לאובייקט של אינטג'ר מערך אחד, והאיבר השני כאן מצביע לרשימה שבפנים יש לה מצביעים לערכים של 2 ו-3, מגניב.

160
00:55:09,300 --> 00:55:20,700
עכשיו אנחנו אומרים לי 2 שווה לי 1.קופי, אז אופרטור קופי הוא יוצר אובייקט אחר של רשימה, אבל כמו שאתם כבר יודעים,

161
00:55:20,700 --> 00:55:50,600
פייתון מאוד אגרסיבי ביעילות שלו מבחינת ניצול זיכרון, אז זה שיצרנו קופי, אמנם יצר אובייקט אחר של רשימה, אבל האיברים מצביעים לאותם אובייקטים בדיוק, אז תראו את הספסוף הזה של חצים, האחד שנמצא בליסט 1 מצביע לאותו אובייקט, כמו שהאחד שנמצא בליסט 2 מצביע, וכנראה לגבי תת הרשימה 2-3.

162
00:55:50,600 --> 00:56:20,600
אותו דבר, אבל עכשיו תראו קטע, אנחנו נריץ פקודה ליסט 2 באינדקס 1, כלומר ליסט 2 באינדקס 1, זאת אומרת איפה שהתת רשימה 2-3 יושבת, שווה 4, מה יקרה? אז קודם כל מלכתחילה ליסט 2 הוא אובייקט אחר, כן? זאת אומרת זה באמת רשימה אחרת. ועכשיו אנחנו אומרים.

163
00:56:20,600 --> 00:56:50,600
לא, האיבר השני ברשימה, עכשיו אתה הולך להיות ארבע. אז תראו את ההבדל, שינינו את ליסט 2, שהוא היה מלכתחילה אובייקט אחר. אמרנו לו, האיבר השני שלך עכשיו הולך להיות אינטג'ר, שהערך שלו זה ארבע, וזה באמת מה שקרה. אנחנו משנים את האיבר השני שלו, הוא כבר לא יותר מצביע לאובייקט הרשימה הזה של ה 2,3, אלא הוא מצביע עכשיו לאובייקט חדש טרי

164
00:56:50,600 --> 00:57:20,600
אם הערך? 4, וזה ההבדל, זה בדיוק ההבדל, אתם רואים אותו? מי נגד? מה קורה כשאנחנו עושים דווקא דבר אחר? בואו נסתכל, נניח ששוב יש לנו את ליסט 1 וליסט 2, הם אותו דבר בדיוק, אתם רואים? lיסט 1 זה כזה דבר.  ליסט 2 קופי של ליסט 1, אז חזרנו לתרחיש של הסעיף הקודם. יש לנו...

165
00:57:20,600 --> 00:57:50,600
שתי רשימות אבל האיברים שלהם זהים לחלוטין. זה כן שתי רשימות ממש, זאת אומרת ליסט 1 מצביע לרשימה הזאת ליסט 2 מצביע לרשימה הזאת אבל האיברים שלהם זהים. עכשיו אנחנו רואים ליסט 1 באינדקס 1 כלומר האינדקס של תת הרשימה הזאת של 2 3 גישה אליו אינדקס 0 כלומר ליסט 1 האיבר השני שלך

166
00:57:50,600 --> 00:58:07,180
שזו רשימה, אינדקס 0 של אותה רשימה, כלומר, העבר הזה בדיוק כאן, בתוך התת רשימה הזאת, זה שמצביע על אובייקט מירך 2, נשנה אותך להיות 4.

167
00:58:07,180 --> 00:58:37,180
אז במקום שהרשימה תהיה אחד פסיק רשימה של 2-3 זה הולך להיות 1 פסיק רשימה של 4-3. אבל עכשיו השאלה, מה אנחנו יודעים על רשימות כשלעצמן? רשימות הן מיוטבול, ברוט שינוי אין פלייס, כי אנחנו יודעים שרשימה היא בעצם אוסף של מצביעים. אז מה יקרה? אני אגיד לכם מה יקרה. אתם רואים את ה?

168
00:58:37,180 --> 00:59:07,180
תת רשימה הזאת שמצביעים אליה גם מ-List 1 וגם מ-List 2. מה שיקרה זה שאנחנו הולכים להחליף את ה-2 הזה ב-4. כלומר, אם תדמינו שיוצאים מתוך הרשימה הזאת שני חצים, חץ אחד לאינטג'ר מסוג 2, חץ אחר יוצא לאינטג'ר עם ערך 3, אז זה יוחלף בחץ אחר.

169
00:59:07,180 --> 00:59:10,620
שיצביע על אובייקט אחר עם הערך 4.

170
00:59:11,380 --> 00:59:22,100
אבל אתם רואים על מה אני מסתכל? אני מסתכל פה על רשימה שליה כבר יש מצביעים קודמים. אז מה יקרה?

171
00:59:22,960 --> 00:59:36,500
אנחנו משנים את הרשימה הקטנה הזאת, שבמקום שיהיה ב-2-3, שיהיה ב-4-3. אבל זאת רשימה שהיא האיבר השני של שתי רשימות, שהן מצביעות עליו.

172
00:59:36,500 --> 01:00:06,420
אז שימו לב להבדל הזה. ה-ID אגב של התת-רשימה הזאת הוא לא משתנה, כי הרשימה הזאת היא מיוטאבל, היא האיבר השני, גם של איסט 1 וגם של איסט 2 שהיה קופי של איסט 1. אז תראו את ההבדלים האלה. תראו איזה הבדל, הבדל פיצקלה. לעומת נניח מה שהיה לנו מקודם, שמה אנחנו החלפנו לחלפנו לחלוטין את כל הרשימה הזאת לאינטג'ר.

173
01:00:06,420 --> 01:00:36,380
ראיתם את ההבדל הזה בין הסעיפים? זה קטע כזה. עכשיו, בקוד שאני הבאתי לכם ל-Q1, אני, חוץ מזה שזה היה עותק, שמה שראיתם פה במצקת, לכל אחד ממנו אני גם הוספתי הדפסות של האם ליסט 1 שווה שווה לליסט 2, והאם ליסט 1 איז ליסט 2. פשוט לנוחות שלכם. האם אני עכשיו אני אריץ python q1.py, אז בואו נראה את ההדפסות שלנו.

174
01:00:36,620 --> 01:00:54,720
אמרנו A שווה רשימה חשדיים שלוש ו-B שווה חשדיים שלוש אז האם A שווה שווה ל-B? כן, טרו. האם A איס בי? פולס. בנינו רשימות נפרדות. או סעיף באט, כשאמרנו ש-B שווה A ואז עשינו לבי אפנד 4.

175
01:00:55,240 --> 01:01:07,380
אז הפנד הזה השפיע על הרשימה האחת שגם A וגם B יצביע עליו, אז בשני המקרים A מצביע על רשימה שהיא תווסף ל-4 וגם B.

176
01:01:07,380 --> 01:01:23,920
והנה ההוכחה A is B, אז מן הסתם ש-A שווה שווה B. עכשיו סעיפים ג' וד' שראינו עכשיו, אתם ראיתם איך שעשינו, ליסט 1 היה שווה לרשימה, ליסט 2 היה קופי שלה, ואז שינינו לרשימה.

177
01:01:23,920 --> 01:01:36,920
ואז שינינו בליסט 2, שבמקום שיהיה לה איבר שהיא רשימה של ליסט 2-3, הבאנו לה את האיבר אינטג'ר 4. ועכשיו אתם רואים שליסט 1 וליסט 2 הם רשימות שונות לגמרי.

178
01:01:36,920 --> 01:01:53,820
ואז בסעיף ד' לבסוף, זה כשאנחנו שינינו את התת רשימה הזאת שהייתה איבר משותף גם לליסט 1 וגם לליסט 2. השינוי הזה, אפשר היה לראות אותו בשניהם. לכן ליסט 1.

179
01:01:53,820 --> 01:02:23,520
כן שווה שווה לליסט 2, למרות שליסט 1 הוא לא בדיוק לליסט 2 מבחינת אובייקט, כי זה כן שתי רשימות שונות, אבל שינינו ערך משותף להם. את זה. טוב, קטע כזה. באמת שבתרגול הזה אנחנו רואים הרבה דקויות, ממש הרבה הבדלים קטנים. אני אומר לכם, אני מרגיש שאני חזק יותר בפייתון אחרי התרגול הזה. אוקיי.

180
01:02:23,520 --> 01:02:53,520
אולי נעשה זום אאוט קצת, הבנו עד עכשיו שוואלה, nitrogen מקשר לנו דברים ברקע, משייך מה שאנחנו לא בהכרח ידענו שזה יקרה, וזה יכול קצת לסבך לנו את המחשבה אם אנחנו לא מכיר דברים, אז מה לגבי שינוי של רשימה בפונקציה, אנחנו יודעים שרשימה היא מוטבילית נכון.. רשימה.. היא מוטבילית מקיים

181
01:02:53,520 --> 01:03:23,520
היא ברת שינוי כי רשימה היא אוסף של מצביעים אז זה שאנחנו משנים איבר ברשימה אנחנו בעצם משנים אחד מהמצביעים בתוך הרשימה עצמה אז כאילו זה בסדר והרשימה יכולה להישאר אותו אובייקט רשימה עם ההבנה הזאת בואו נסתכל נניח שיש לנו רשימה כלשהי 1,2,3 ונניח שאנחנו רוצים לשנות את הרשימה אז אתדעתכם פונקציה כזאת

182
01:03:24,360 --> 01:03:39,940
תעבוד שהיא לוקחת כביכול רשימה כפרמטר והיא אומרת רשימה שווה לרשימה ועוד עוד תת רשימה, זה בעצם דרך כלשי לעשות אפנד, זה יעבוד לדעתכם?

183
01:03:40,080 --> 01:03:53,380
אז תראו קטע, אם אתם זוכרים, יש את העניין הזה שבפונקציות, פונקציות הם בעצם אובייקט משל הצמן, אתם זוכרים כשראינו בפייתון טיוטר, בטריכולה הקודמת על אהה. . .

184
01:03:53,380 --> 01:04:23,160
כל מיני אובייקטים של רשימות וזה, אז ראינו איך שלמעשה רשימה יש לה את המחסנית משל הצמה וכל זה, אז מה קרה? מה שיקרה עם האופרטור הזה, שווה זה, אנחנו בעצם ניצור אובייקט חדש, לפרמטר המקומי LST הזה, למשתנה המקומי הזה, ואז יהיה לנו את המשתנה החדש הזה, שבדיוק הוספנו לו את ארבע.

185
01:04:24,020 --> 01:04:47,800
וזה מה שיקרה, אנחנו בעצם מביאים למשתנה המקומי של הפונקציה LST, מביאים לו את הערך החדש הזה, אבל כשהפונקציה תיגמר, כל זה עף מהזיכרון, וה-LST המקורי פה, בגלובל פריים, הוא לא השתנה, אז לא השגנו בזה כלום.

186
01:04:47,800 --> 01:05:17,280
אוקיי, אז איך כן נשיג בזה משהו? אז בשביל זה, אני רוצה להראות לכם ישר את הקוד שכתבתי. אז הנה קוד שכתבתי, קצת יותר כללי כזה, גם כל זה נמצא לכם במודל, אז תראו את ההבדלים. הפונקציה הראשונה כאן, קראתי לה addBattly, שאני מקבל את כפרמטר רשימה ואין כלשהו, אז הנה הפונקציה שלא תעבוד, ומתחתיה, יש שתי גרסאות של פונקציה שכן יעבדו.

187
01:05:18,260 --> 01:05:48,260
קודם כל, אפנד, מה שקורה באפנד, אפנד היא עושה את זה בגישת זיכרון, זאת אומרת, מה שקורה, כשאתם לוקחים את הפרמטר שלכם ליסט, אז תראו, מה קורה קודם כל כשאתם שולחים רשימה לפונקציה, אתם בעצם סוג של שולחים אולי אתק אם תרצו לקרוא לזה, אבל כשאנחנו עושים אפנד, אז זה עושה את זה בזיכרון. vivo www.8.3

188
01:05:48,260 --> 01:06:01,060
לאותם אוסף של מצביעים, וכן מוסיף עוד מצביע של משתנה נוסף, של ערך נוסף, מה שנקרא.

189
01:06:01,060 --> 01:06:15,900
ויש גם עוד ערך, אופרטור סלייס. אופרטור סלייס גם למעשה עושה את הגישת זיכרון הנחוצה, כדי לשנות את הרשימה המקורית.

190
01:06:15,900 --> 01:06:24,680
אז אם לדוגמא אני עכשיו מריץ לכם Python Update List נקודה פאי, תראו את ההבדלים.buz: הנה אני ממש רוצה שתראו.

191
01:06:24,680 --> 01:06:43,980
אז הגדרנו List 1,2,3 בפרייום הגלובלי, הרצנו את הפונקציה Add-Badly האלא טובה הזאת עם הפרמטר LST שלנו ולא יודע ארבע.

192
01:06:43,980 --> 01:07:13,040
ועדיין ה-LST בפריום הגלובלי נשאר זהה. מנגד, כשאנחנו הרצנו בעזרת פקודת Append או בעזרת פקודת Slice בפונקציות נפרדות, זה כן עבד וכן הוספנו להם, ל-LST שנמצא בפריום הגלובלי, את הערכים המדוברים. ב-Append הוספנו חמש, בסלייס הוספנו את שש, ואתם רואים שהחמש עדיין שם. אז תראו את ההבדלים, זה קטע כזה.

193
01:07:13,040 --> 01:07:42,460
עכשיו, אני אישית לא מאוד ממליץ לכם, לא ממליץ לכם אפילו בכלל, לכתוב פונקציות בלי ערך ריטרן ואליו. כי פה, אתם תלויים, בחסד של ההבנה שלכם, של מתי שינוי רשימה מחוץ לפונקציה כן עובד ומתי הוא לא עובד. הרבה פעמים נהוג לכתוב פונקציה עם ריטרן ואליו. אז נניח הייתם רוצים לעשות פונקציה שמחזירה רשימה חדשה עם השינוי שרציתם.

194
01:07:42,820 --> 01:07:47,920
אבל אם אתם רוצים לחיות בצורה מסוכנת, תכירו.

195
01:07:47,920 --> 01:07:53,840
הנה גישות שכן יעבדו, והנה הגישה שלא תעבוד.

196
01:07:53,840 --> 01:08:01,720
אז כמובן, הקוטק הזה נמצא לכם במודל, זמין בשביל שתוכלו להבין את זה ולשנות את זה מקרוב.

197
01:08:02,720 --> 01:08:15,560
אז, אה, לפני שאני רק ממשיך איתכם, בפונקציה בגרסה הגרועה שלה, בבקשה תאמינו לי שלא היה כאן בעיה של שם הפרמטר.

198
01:08:15,560 --> 01:08:24,240
גם אם היינו כותבים פה שם פרמטר שונה מהשם של הרשימה מחוץ לפונקציה, זה לא היה פותר את הבעיה.

199
01:08:25,240 --> 01:08:32,600
אז, שאלה, איך אתם יכולים לפתור את הבעיה הזאת? אתם זוכרים גם...

200
01:08:33,200 --> 01:09:01,980
את השימוש בגלובל, כן? זאת אומרת, אם היינו כותבים פה נניח גלובל LST. סתם דוגמא, אני עכשיו אעשה את השינוי הזה. ואני אריץ את פייתון, זה גלובל LST, the name LST is parameter end-global. (צחוק) שזו תקלה, נכון? אל תעשו את זה. אז חכו שנייה, הנה, אני, העלים את זה.

201
01:09:01,980 --> 01:09:30,860
ואני גם באט באד לי אעלים את זה. אוקיי, בסדר, אז ברור שעכשיו זה יעבוד, כן? הנה, אט באד לי, הוספנו את 4 ואז היה לנו את 1, 2, 3, 4, 5 ו-5, 6, בסדר, זאת לוגיה, אל תעשו את זה ככה, באמת אל תעשו את זה ככה. אוקיי, ריטרן value, נכון?

202
01:09:30,860 --> 01:10:00,440
למרות שזה נכון שלפעמים אתם רוצים לעשות שינוי שהוא in place, אני מסכים, רק תזכרו שאם אתם יכולים, אם ברלוונטי, ריטרן value זה תמיד עובד, יש לכם גם את הרעיון של אופרטור פלוס שווה האמת, פלוס שווה יכול לעבוד. בואו נראה לכם את זה, least פלוס שווה. בואו נראה. האם עכשיו את באד לי, won't be so bad? וואלה? Not so bad. הנה 4 שלנו.

203
01:10:01,300 --> 01:10:31,300
ראיתם איזה? LST פלוס שווה, האופרטור הזה היה טיפה חכם יותר. מה העניין? אנחנו רואים פה עוד ועוד דברים. אז, דרך אגב, לגבי אופרטור פלוס שווה, זה תלוי גם במיוטביליות ובאI מיוטביליות של אובייקט, לדוגמא... אם אובייקט שלכם הוא I מיוטביל (אינטג'ר), אז זה שאתם עושים, סתם לדוגמא, X פלוס שווה Y

204
01:10:31,300 --> 01:11:00,780
זה כאילו עדיין יוצא לכם אינטג'ר חדש שהוא פשוט x פלוס y, כן? המנגד, אם האובייקט שלכם הוא muteable, כמו רשימה, אז באמת פלוס שווה עושה פעולה שהיא מאוד דומה קצת לאפנד, בקטע שהוא משנה את האובייקט המקורי בתוספת אם מה שאתם מביאים לו.

205
01:11:00,780 --> 01:11:30,200
אז כן, הנה השקופית שמראה לכם את הקוד שבדיוק הראתי לכם מכדם, גם אפנד וגם אופרטור סלייס, כמו מכתוב סתם, סוגריים מרובעות ונקודתיים באמצע, זה בעצם דרך שלכם לעשות קופי של האובייקט, אם הוא בצורה שדומה לרשימה או משהו כזה. אז כן, אפנד, סלייס, ראינו מקודם את הפלוס שווה.

206
01:11:30,720 --> 01:11:59,080
הופ, אפילו אני כמתרגל מתחיל טיפה ללכת לאיבוד, האם נצליח לזכור את כל זה בעל פה? אם נכתוב קוד והרבה ממנו, יש סיכוי. בסדר. אז מה קורה עם החוזות? נניח שיש לנו סטרינג ואנחנו רוצים לשנות את הvalue שלו בתוך פונקציה, על ידי אופרטור סלייס כלשהו. זה יעבוד?

207
01:11:59,080 --> 01:12:27,840
אז לא, מזכיר לכם, סטרינגים, מחוזות הם אימיוטבל, זאת אומרת, אתם רואים את הקוד הפשוט הזה? נניח יש לנו סטרינג שווה ABC, ואנחנו רוצים להפעיל עליו פונקציה הזאת, מה היא עושה? היא אומרת, סטרינג אופרטור סלייש, שזאת אומרת, תיצור עכשיו עותק חדש של סטרינג, והתוכן שלך כולו יהיה?

208
01:12:28,760 --> 01:12:58,760
איי, האם זה יעבוד? אז התשובה היא לא, ולמעשה, אני אראה לכם. קודם כל, אם אתם הייתם מנסים להריץ את מה שכתוב פה, פה ממש, ותוך קוד, פייתון היה נותן לכם שקיעה. אז, אני אפילו כתבתי לכם פה קוד שבדיוק עושה את מה שכתוב שם במצגת, אני הולך לנסות להריץ את הפונקציה הזאת על ה-Stream, אבל מה?

209
01:12:58,760 --> 01:13:28,760
אני לא רציתי שזה יכרוס לי אז אני אצלם אוספתי פה קונספט כזה שקוראים לו טרא אקספט. שזה לא בדיוק משהו שאנחנו אמורים ללמד לכם כרגע אני רק אגיד את לכם תקציר זה כזה. דרך שבה אתם יכולים לכתוב קוד שהוא עלול לקרוס. להיכשל. ממש לגרום לפייתון להפסיק לרוץ ולתת לכם שגיאה שהרבה מכם אולי לא בדיוק יודעים לקרוא ולהבין את השגיאות כי זה

210
01:13:28,760 --> 01:13:58,760
עדן חדש שלכם, אז הקונספט הזה של טריי אקספט הוא פשוט בקטע כזה של תנסה להריץ את זה ואם באיזשהו שלב פה יש שגיאת תוכנה אז תריץ את מה שנמצא בבלוק של האקספט כי יש כזה דבר בתכנות שקוראים לו אקספצ'נס שזה כאילו שגיאות בגלל סיבה ספציפית אבל אני מקדים פה את המואוחר. בקיצור מה שאתם רואים פה זה בטריי אתם כזה

211
01:13:58,760 --> 01:14:28,760
אתם רואים את הקוד שמגיע מהמצגת וב-except זה סתם פרינט שבו אני חופר לכם, ואני אומר לכם, היי שגיאה, אתם לא יכולים לשנות סטרינג, אובייקט אימיוטבול? בקיצור, אם אני עכשיו עושה python q2.py st אזה abc, attempting to run update st, הרצתי את הפקודה, והיי, זה לא עבד,

212
01:14:28,760 --> 01:14:58,760
את יודעת? כי למה, מייד אחרי זה הקיבלנו בפרינט את האירו ואיפה הוא נמצא בבלוק האקספשן כלומר זה קוד שלא עובד בפייתון זה. אוקיי. around my heart, everyday. אני לא חושב שאני אפילו אספיק להראות את זה בתרגול בשידור חי, להגיד את האמת אז מי שרואים פה את התרגול המוקלט אתם הרווחתם העמקה בפייתון אז זה כיף למי שצופה בבית איני ווי

213
01:14:59,760 --> 01:15:01,480
בואו נסתכל על הקוד הבא בטופ

214
01:15:02,460 --> 01:15:32,460
הנה קוד קצת מוזר, מה קורה פה? יש לנו פה פונקציה, קוראים לה אקסטראקט קארטס. מה היא מקבלת כפרמטר? פרודקט וליסט או עם ערך דפולטיבי. מה זאת אומרת ערך דפולטיבי? אז אני לא יודע אם אתם זוכרים, אמרנו שפונקציות הן כשלעצמן אובייקט, אם אתם זוכרים מהתרגול הקודם, כל הפייתון טיוטר וכל זה וכל זה, אז

215
01:15:32,460 --> 01:16:01,840
פונקציית הן כשלעצמן אובייקט. והקטע הוא שאם אתם נותנים לפרמטרים של פונקציה ערך שהוא ברירת מחדל, אז אתם בעצם יוצרים אובייקט בתוך הפרייים הזה של הפונקציה, שהוא אובייקט שהוא איך אני אגיד לכם, הוא תמידי, הוא נשאר שם, הוא קיים, והוא משתנה לאורך הקוד שלכם. מה זאת אומרת?

216
01:16:01,980 --> 01:16:17,680
בואו נסתכל על הפונקציה, האקסטרקט קרקסית הזאת היא מקבלת פרודקט כפרמטר בלי ערך דפולטיבי אז אתם חייבים לשלוח כפרמטר פרודקט ואופציונלית בגלל הערך הדפולטיבי היא מקבלת גם רשימה.

217
01:16:18,300 --> 01:16:28,180
אבל אתם רואים כאן שאנחנו קוראים לפונקציה הזאת בלי רשימה, מה זאת אומרת? אז כשאתם קוראים לפונקציה בלי לשלוח פרמטר.

218
01:16:28,940 --> 01:16:41,220
איפה שנתתם להגדרה של הפונקציה ערך ברירת מחדל לפרמטר הפונקציה תשתמש באובייקט שהיא יוצרת לעצמה כברירת מחדל.

219
01:16:41,220 --> 01:16:58,080
אז מה אתם הייתם חושבים? אם אתם לא הייתם יודעים שפייתון אוהב להתחכם בקטע הזה של אובייקטים וזיכרון, אז מה שקורה פה זה בסך הכל הנה פונקציה by default רשימה רקעה,

220
01:16:58,080 --> 01:17:27,740
היא עושה לרשימה אפנד עם הפרודקט שאתם מביאים ולבסוף פשוט מחזירה את הרשימה. ואז מה כתוב כאן? יש לנו פה שני משתנים, bety-cart שווה מה ש-extract-carts תחזיר עם פרודקט שהוא המחוזת - laptop. אז הייתם חושבים, אוקיי, bety-cart תקבל פה רשימה שיש בה מחוזת - laptop. הגיוני?

221
01:17:28,260 --> 01:17:41,460
קראנו לפונקציה פעם אחת? עם הסטרינג הזה. הפונקציה יוצרת רשימה ריקה by default, עושה על זה append עם הסטרינג ששלחתם, ואתם מקבלים את זה חזרה.

222
01:17:41,460 --> 01:17:56,980
אבל אז אנחנו אומרים יוני קארט, כלומר אנחנו אומרים משתנה אחר שווה מה שאקסטקט קארטס תחזיר כשאנחנו עכשיו קוראים לה עם סטרינג אייפון. אז...

223
01:17:56,980 --> 01:18:26,560
מי שלא יודע, מי שלא מכיר, מי שזה חדש לו, יחשוב שאנחנו קוראים לפונקציה בלי פרמטר רשימה, אז הפונקציה תיצור כברירת מחדל רשימה ריקה, תוסיף לזה את הסטרינג הזה, ותחזיר לנו רשימה רק עם סטרינג אחד. כלומר, מי שלא ראה את התרגול הזה היה חושב שגם בטי-קארט וגם יוני-קארט, אחרי שתי הפקודות האלה,

224
01:18:26,560 --> 01:18:35,120
יהיו רשימות נפרדות וכל אחת עם אובייקט שהוא סטרינג אחד, זה שמתאים לו.

225
01:18:35,180 --> 01:18:43,360
בדי קארט יהיה לו רק את לפטופ, יוני קארט יהיה לו רק את אייפון. אז עכשיו, אם איך שאני אומר לכם את זה,

226
01:18:44,300 --> 01:18:55,360
אמנם, אז יש פה את הקוד של Q3, אתם רואים פה ימבה של פרינטים, אבל אל תאבדו ריכוז, הפונקציה היא בדיוק אותה פונקציה,

227
01:18:55,940 --> 01:19:25,820
עם הליסט הדפולטיבי, והפקודות כאן הן אותן פקודות. הפרינטים שמסביב הם רק מסבירים את מה שאנחנו הולכים לבדוק, אז בואו נבדוק את זה. אני מריץ פייתון, Q3.pi. אז, מה יש לנו? רגע, אני רוצה שנוכל לקרוא את זה, הנה. אז הפונקציון אקסטרקט קארטס, יש לו ליסט פרמטר שנקרא LST, עם דפולט פרמטר של ליסט פונקצי. ועכשיו,

228
01:19:25,820 --> 01:19:55,820
אנחנו נריץ את שתי הפקודות האלה, את בטי קארט שווה ככה וככה ויוני קארט ככה וככה, לא מביאים רשימה עם זה. עכשיו איך הקארטס נראים, הנה, בטי קארט זה גם לאפטופ וגם אייפון וגם יוני קארט זה לאפטופ ואפטון. היי, מה זה, הם קיבלו אותה רשימה? רגע, אז עכשיו בואו נריץ את אופרטור שווה שווה, אופרטוראיז.

229
01:19:56,840 --> 01:19:58,580
זהה לחלוטין.

230
01:19:59,620 --> 01:20:00,980
אתם מבינים מה קרה פה?

231
01:20:02,320 --> 01:20:09,240
הנה, אני גם רוצה להראות לכם בקוד, אני לא מרמה אתכם. אתם רואים פרינט F עם ההשוואות האלה.

232
01:20:10,280 --> 01:20:26,700
אוקיי, זאת הרשימה בדיוק. מה קרה פה? אז תראו מה קרה. פייתון אכן יצר, פייתון אכן, אכן, אכן יצר רשימה דפולטיבית ריקה. ברגע שהערצתן את הפונקציה הזאת,

233
01:20:26,700 --> 01:20:52,040
התחלתם מרשימה רקע, אבל הקטע הוא שלפחות בפייתון, כשאתם קראתם לפונקציה הזאת פעם נוספת, הרשימה הזאת נשארה שם, היא לא נפתרה, כאילו היא לא נעלמה. דווקא הרשימה הזאת, הרשימה דיפולטיבית הזאת, שהפונקציה יצרה עם הערך הדיפולט וייליו הזה.

234
01:20:53,000 --> 01:21:23,000
ואז כשקראתם בקסטרק קארט עם הסטרינג הזה אייפון, מה זה עשה? זה עשה ליסט אפנד. איזה ליסט? הוא הליסט הדפולטיבי שהפונקציה התחילה איתו עוד בשביל הקריאה הראשונה. אז כנגד כל אינטואיציה אפשרית, יצא מצב שהרשימה הדפולטיבית האחת הזאת היא אותה רשימה שעכשיו אתם החזרתם גם ל...

235
01:21:23,000 --> 01:21:29,240
לבטי קארט, וגם ליוני קארט, שני משתנים שמצביעים על אותה רשימה בזיכרון.

236
01:21:29,240 --> 01:21:37,080
ואני אומר לכם את זה כאן ועכשיו, אם אני לא הייתי עובר לתרגול הזה לפני שהייתי מקליט לכם אותו, אני לא הייתי מכיר את זה.

237
01:21:37,080 --> 01:21:52,880
זה קטע כזה בפייתון. בואו תראו איך זה נראה עכשיו ויזואלית. הנה הפונקציה, זו שהיא אובייקט של הפונקציה, וכשאתם קוראים לה פונקציות בפעם הראשונה, אז זה כן.

238
01:21:52,880 --> 01:22:07,280
כן, מקצה אובייקט שנשאר בזיכרון עם כתובת ידוע בפעם הראשונה, ברגע שיש לכם פרמטר עם דיפולט ואליו, אז...

239
01:22:08,040 --> 01:22:21,900
האובייקט הזה...אז הליסט הזה הולך לקבל אובייקט שישאר בזיכרון. אז קריאה ראשונה עם לפטופ, עשינו אפנד ללפטופ. אוקיי, אז יש לנו עכשיו את ה...

240
01:22:22,560 --> 01:22:52,560
את הפרודקט הזה שעשיתם אפנד עם התוכן שלו לליסט, ואז כשאנחנו, אם אתם רואים עכשיו הנה הליסט שלכם, זה התווסף אליו, זה מצביע על האובייקט הזה מסוג laptop. רק כשאתם קוראים עכשיו לפונקציה השנייה יוני קארט, אז תראו מה קורה. לפני שאנחנו מריצים, יש לכם את הבטי קארד, בטי קארט, שזה משתנה בפרמה גלובלית, הוא מצביע

241
01:22:52,560 --> 01:23:07,840
לאותה רשימה הדפולטיבית שנוצרה אחרי ההתחול הדפולטיבי הזה בפונקציה אקסטראקט קארטס בפעם הראשונה שהרצתם וזה לא נהרס, זה לא נהרס, כי.

242
01:23:09,840 --> 01:23:19,560
זה פשוט קטע כזה, אני מתחילות לגמר לי המילים כבר בשלב הזה של התרגול ואז כשאתם עושים את הקריאה השנייה הזאת לסטרינג אייפון.

243
01:23:20,600 --> 01:23:50,120
זה מקבל אפנט לתוך הליסט הזה, וזה נשאר ככה. תראו קטע כזה, שני ליסטים מחוץ לפונקציה שמצביעים לאותה ליסט שפונקציה יצרה בצורה דפולטיבית. משהו, משהו הדבר הזה באמת. יאללה. אז בואו נתרגיל את הרעיון הזה של עבודה על רשימה.

244
01:23:51,040 --> 01:23:53,520
בתוך פונקציה בלי ריצ'רן ואליו.

245
01:23:54,520 --> 01:24:04,440
בתרגיל הרביעי אומרים לנו תכתבו פונקציה שהיא מקבלת רשימה, ואינדקס כלשהו, והיא מוחקת את העיוור הרלוונטי מהרשימה הזה.

246
01:24:04,440 --> 01:24:13,020
בלי ריצ'רן ואליו, כלומר בלי פונקציה שווה מה שה... סליחה, בלי רשימה שווה מה שהפונקציה תחזיר.

247
01:24:14,920 --> 01:24:17,600
אז, איך אנחנו ניגש לרעיון הזה?

248
01:24:17,600 --> 01:24:47,600
אופרטור סלייס, אופרטור סלייס, שראיתם אותו מקודם. אז אנחנו כן יכולים ליצור פונקציה שמקבלת כפרמטר רשימה, אגב, שימו לב, לא דפול טיווי, בסדר, בלי ערך דפולט. רשימה, אז כאילו קופי של הרשימה, אולי, ואינדקס, אבל אתם ראיתם מקודם שאופרטור סלייס יודע לגשת לרשימה ממש, שאתם

249
01:24:47,600 --> 01:24:55,660
וסיפקתם כ... פרמטר, לא סתם ‫אתם יודעים קופי של רשימה, אופרטור סלייס כן,

250
01:24:55,660 --> 01:25:01,500
ייתן לכם שינוי על ה object list המקורי, ‫שהוא muteable.

251
01:25:01,500 --> 01:25:17,440
אז, זה אתם ראיתם, אתם האמת שראיתם את זה עובד עם אופרטור סלייס, ‫אז דרך אגב, מה זה עושה פה? איך אתם מוכקים את העבר שבאינדקס, ‫אז תראו את העבודה עם הסלייס.

252
01:25:17,440 --> 01:25:47,440
סלייסים שלנו. מה אנחנו אומרים? ליסט מחדש, אותו ליסט מקורי מחדש, אז אתם רואים, סוגריים מרובעות עם נקודתיים באמצע, בלי כלום. זה אומר, הליסט המקורי, עכשיו אתה הולך להיות מה? הליסט המקורי, שמתחיל בהתחלה, נגמר עד באינדקס, לא כולל ועוד, כלומר שירשור, עם הליסט

253
01:25:47,440 --> 01:26:17,440
המקורי שמתחיל באינדקס ועוד אחד ונגמר בסוף. אז ככה מדלגים באלגנטיות על ליסט במקום אינדקס, וזה שינוי שבאמת יהיה in place בליסט שאתם שולחים לפונקציה. דרך אגב, הנה שאלה מכשילה, "האם לעשות כזה דבר יעבוד?", מה יקרה אם אנחנו נגיד ליסט במקום אינדקס? לפגוע בררגעיםץ של מרוגע מרת?

254
01:26:17,440 --> 01:26:46,820
מקום אינדקס שווה נאן, אם אתם הקשבתם בהרצאות אני מניח אתם ראיתם עד עכשיו שיש כזה טיפוס מיוחד בפייתון שקוראים לו נאן וכל המשמעות שלו בחיים זה להגיד אין ערך כלום אין ערך אז השאלה היא תיאורטית האם כזה דבר יעבוד בואו נגלה זה שאלה 4 מה קורה שם.

255
01:26:46,820 --> 01:27:15,540
אז הנה קוד שהוא בדיוק ממה שיש במצגת, יש לנו את פונקציית למחוק מספר, בדיוק לפי אופרטור סלייס, ויש לנו את הפונקציה השנייה הזאת של לנסות למחוק את המספר על ידי לתת לו אופרטור שווה עם non. האם זה יעבוד? בואו נגלה. python-cube-4.py.

256
01:27:15,540 --> 01:27:35,620
אז איך שיש לנו את הליסט שלנו 1,2,3,4 ננסה למחוק ממנו מספר עם פונקציית הדליט הטובה, משולחים את ליסט אינדקט 2, שימו לב, 0, 1,2, הרצנו את זה ועכשיו ליסט הוא 1, 2, 4.

257
01:27:35,620 --> 01:28:04,660
עכשיו ננסה להריץ את זה, דליט נאם נאן, ניקח את הרשימה 1,2,4 וננסה לשנות את האיבר באינדקס 0 לנאן, עכשיו ליסט היא נאן 2,4, כן, לא מה שרצינו, אז זה לא רעיון טוב, אל תעשו את זה.

258
01:28:04,660 --> 01:28:34,620
אוקיי, דיברנו הרבה מאוד על זיכרון, הרבה מאוד על מיוטבלטי, אימיוטבלטי, רשימות, אובייקטים, מצביעים, וואו, זה יכול להרגיש קצת כמו כאב ראש, זה, אני אגיד לכם את זה עכשיו, זה מרגיש טיפה יותר מסובך ממה שהקורס במתכונת המקורית שלו, כשהוא היה בשפצי, הרגיש כאילו ששם היה צריך.

259
01:28:34,620 --> 01:28:54,080
ללמוד פחות על השפה, אבל זה טוב שאתם מקבלים את הדברים האלה כבר עכשיו, כי פייתון באמת שפה עם כל כך הרבה כלים ויכולות לתכנת ופשוט לעשות דברים בצורה נגישה.

260
01:28:54,080 --> 01:29:04,040
ספיקינג אוף לעשות דברים בצורה נגישה. אתם יודעים שלפייתון יש כזה דבר שקוראים לו מוד'יולס.

261
01:29:04,040 --> 01:29:33,200
שזה פשוט קבצי פייתון נפרדים שנותנים לכם פונקציות שאתם יכולים פשוט להשתמש בהן, ממש בילט אין טולס, אז אתם זוכרים את הרעיון של פונקציות אינפוט, פונקציות פרינט, פונקציות מין, מקס, זה הכל פונקציות שהן בילט אין לשפה, נכון? מישהו פשוט מימש אותן, ואנחנו יכולים להשתמש בהן.

262
01:29:33,200 --> 01:30:03,120
אז מה הקטע פה? חוץ מהפונקציות שהן ממש ממש בילט אין לשפה, כאלה שאתם פשוט כותבים אותן כמו אינפוט, פרינט, מין, מקס וכולי, יש גם אקסטרה פונקציות שלפעמים אנחנו אומרים לכם בואו נעשה אימפורט למודול כלשהו, אימפורט משהו, ואז נריץ פונקציה שמגיעה משם. אז קודם כל, למה זה טוב שאנחנו יכולים ככה...?

263
01:30:03,120 --> 01:30:33,080
לייבא פונקציות מקבצים נפרדים? למה לא נרצה לממש את הפונקציות האלה בעצמנו? כי סתם דוגמה, נניח שיש איזשהו באג, נניח שיש צורך בלשנות קוד של פונקציה, שאנחנו שמים אותה בקובץ אחד שמשותף להרבה דברים. אז זה מסוג הדברים שיותר נוח, כי ככה אם יש דברים שצריך לשנות בהם, משנים את הקובץ האחד הזה, ואז...

264
01:30:33,080 --> 01:31:02,180
כל שאר הקבצים שמייבאים אותו אליהם, מבחינתם אין הבדל, אבל אם לא עשיתם את ההפרדה הזאת, ונניח העתקתם את אותה פונקציה לכל קבצי הקוד הנפרדים שלכם, דמיינו מה זה עכשיו להצטרך לעקוב אחרי זה, ולשנות את הקוד, לתקן אותו בכל הקבצים הנפרדים. לא ילך. אז חלוקה...

265
01:31:02,180 --> 01:31:31,380
מודולים נפרדים, חיצוניים, יבוא סלקטיבי, זה טוב. אוקיי, אבל בוא לא נלך רחוק מדי, זה קוסמו וו, אז אם אתם רוצים, בשורה אחת, מה זאת אומרת מודולים וזה, וקבצים נפרדים, זה פשוט ארגון נכון ובריא של עבודה. בואו נראה שימושים, סתם דוגמה.

266
01:31:31,380 --> 01:31:59,680
נניח שאנחנו רוצים לקחת רשימה, הנה רשימה פשוטה, ואנחנו רוצים ליצור לה רשימה שתהיה, בכל איבר בה, יהיה סכום האיברים עד לאותו אינדקס. זאת אומרת, אחד זה האיבר היחיד שנמצא באינדקס 0, אז סכום כל האיברים עד אינדקס 0 יהיה פשוט אחד.

267
01:31:59,680 --> 01:32:28,980
סכום כל האיברים עד וכולל אינדקס 1 יהיה אחד, ועוד שתיים, כלומר שלוש. סכום כל האיברים עד אינדקס 2 כולל יהיה אחד, ועוד שתיים, ועוד שלוש. שש. אז בעצם תחשבו על זה, אנחנו רוצים לקחת רשימה, ולחשב את רשימת הסכומים, רשימת תתי הסכומים, מה שנקרא לזה.

268
01:32:28,980 --> 01:32:35,700
מה שנקרא לזה, תת סכום, זאת אומרת סכום של האיברים עד לאותו אינדקס כל פעם.

269
01:32:37,500 --> 01:32:58,780
אז לכתוב את הקוד לזה לא יהיה לכם קשה מאוד, נכון? סתם דוגמא, בואו נבנה רשימה כזאת, נניח נגיד ריינג' מ-0 עד 99 כולל, בסדר? עכשיו בואו נבנה, בואו נבנה, כזאת רשימת תתי סכום.

270
01:32:58,780 --> 01:33:28,700
נבנה רשימה חדשה, סכום 0, עכשיו נריץ, נגיד, for item in הריינג' הזה של מ-0 עד 99 כולל, כלומר אנחנו נעבור על זה 100 פעמים, נגיד, סכום רץ פלוס שווה המספר הנוכחי ונוסיף את זה לרשימת התתי סכומים שלנו. אז אתם רואים מה יקרה, זה מתחיל מ-0, append, 0 ועוד 1, 1.

271
01:33:28,700 --> 01:33:40,020
אפנד 1 ועוד 2 שזה יהיה 3 אפנד אז זאת אומרת יהיה לנו ככה רשימה של סכומים רצין ככה 0, 1.

272
01:33:40,020 --> 01:33:57,600
אני חושב שיהיה כבר 3 כן בדיוק 0, 1, 3, 6 וכן הלאה וכן הלאה. אוקיי. אבל יש כבר את הפונקציה הזאת בסדר כבר בנו לנו אותה.

273
01:33:57,600 --> 01:34:26,960
יש מודול ספרי הפקאג' איך שתרצו לזה סופר פופולרי בשם נאם פאי אולי הספרי הפקאג' הכי פופולרי לפייתון, בסדר? נאם פאי, שזה אוקיי נאם ופאי, זאת אומרת פעולות מתמטיות. ומימשו לנו כבר פונקציות כאלה. לדוגמה, תראו קטע, אנחנו ניקח את הריינג' של עד 100.

274
01:34:27,960 --> 01:34:41,060
ואנחנו יכולים פשוט לקרוא לפונקציה מתוך מודול חיצוני שכבר עושה את זה, ובצורה הרבה יותר יעילה. אז אנחנו נגדיר שהרשימה החדשה שלנו שווה.

275
01:34:41,060 --> 01:34:50,940
נאמפאי. פה עשינו אימפורט נאמפאי אס א.נ.פ. נ.נ.פ. זה שם מקוצר שאנחנו נותנים לנאמפאי, אז נגיד.

276
01:34:50,940 --> 01:35:08,280
n.p. נקודה קיומי לטבסם, זאת אומרת סכום קומולטיבי כזה שגדל לאורך זמן, ובתוך פרמטר שולחים לו את הריינג' הזה, ואולי אנחנו נקבל את הרשימה של תתי סכומים.

277
01:35:08,280 --> 01:35:20,880
זה פשוט הרבה יותר מהיר, הרבה יותר נוח, כי גם אתם יכולים בטוחים שפקג'ים פופולאריים כאלה גדולים, לפחות עשו להם מימושים גם די טובים לפונקציות.

278
01:35:20,880 --> 01:35:39,560
אז וואלה, אני הרבה יותר הייתי מעדיף ללכת לחפש באינטרנט, לגלות שהפונקציה הזאת קיימת, ופשוט להשתמש בה, מאשר לממש בעצמי את הפונקציה הזאת, גם בצורה שהיא בטח פחות יעילה ממה שאנשים שכבר מנוסים יודעים לעשות.

279
01:35:39,560 --> 01:36:09,300
בעולם האמיתי, אתם נעזרים בקוד שכבר אנשים בנו לכם. אז הנה דוגמה פשוטה לשימוש במודול, כי למה לא? אז איך אנחנו יכולים לכתוב מודול האמת? הרי לא באנו לפה סתם בתור משתמשים, אלא באנו לפה כדי להיות מתכנתים בעצמנו. אז האמת?

280
01:36:09,720 --> 01:36:39,140
זה לא מאוד קשה, מה שאנחנו יכולים לעשות זה פשוט לכתוב קובץ פייתון עם הגדרות של פונקציות, לשים את הקובץ הזה באותה תיקייה כמו התיקייה שבה אנחנו רוצים לכתוב קוד פייתון שקורא לזה, או אלטרנטיבית אם אנחנו התקנו את פייתון סתם דוגמה בפרוגרם פיילס שלנו אתם זוכרים בהתחלה של הקורס אמרתי לכם.

281
01:36:39,140 --> 01:37:07,680
תתקנו פייתון כאדמיניסטרטורים אז בואו תראו קטע אני הולך עכשיו ל-C פרוגרם פיילס פייתון 3.13 זה הגרסת פייתון של הקורס נכון לסמסטר הזה. תיקייה בשם ליב LIB קיצור לספרייה. ומה אני מוצא פה? ים על גבי ים של קבצי פייתון הרבה מהם הגיעו עם פייתון כשהתקנתי אותו.

282
01:37:08,660 --> 01:37:37,560
ואני יכול פשוט להעביר אותם זאת אומרת אני יכול בפקודה של אינפורט אני יכול להעביר אותם אליי והם יעבדו לי. אז בואו נראה דוגמה. אתם רואים כאן דוגמה לקובץ פייתון פשוט שתי פונקציות array-sum array-average זה בסך הכל מקבל רשימות ומחשב לכל אחד.

283
01:37:37,560 --> 01:38:07,560
מעבר למעט את מה שברור מאליו. סכום, מחשבים סכום ממוצא, מחשבים ממוצא, ומחזירים אותם באטם, ואז אנחנו יכולים בקובץ.מי שלנו, פשוט לעשות אימפורט. אז סתם דוגמא, אנחנו יכולים בקובץ נפרד לעשות אימפורט. ואז כותבים את שם קובץ הפייתון שלנו, אפילו בלי שיאומט, פשוט שם קובץ הפייתון, וכשעשינו את זה. אנחנו עשינו בעצםTAKE ONE frame of pure data. נמל ממעשה משהו אותך להכיר להחזיר לה חזות בטמתך שאתה לא גזל זמן. את זה חזור לך, אם תחזור לך

284
01:38:07,560 --> 01:38:37,560
בעצם, כאילו שהעתקנו את התוכן של הקובץ ל... מאיפה שאנחנו עושים את זה. אז אם יש לנו קובץ שיש רק definitions לפונקציות, אז העתקנו את הדפינישן של הפונקצייות, ועכשיו יש לנו אותן זמינות. איך? אם אנחנו עושים אימפורט, אנחנו... עושים, כשאנחנו רוצים להשתמש בפונקציה, נגיד, שם הקובץ, נקודה, ואז הפונקציה שאנחנו רוצים. אז בואו

285
01:38:37,560 --> 01:39:07,560
בואו נראה דוגמה לזה באמת, תסתכלו, הנה קובץ mymodule נקודה פאי, הנה שתי הפונקציות מוגדרות, האמת אני משראה לכם, הנה הוא פה, mymodule נקודה פאי הוא פה, עכשיו קטפתי קובץ אחר, נקרא לו test נקודה פאי, ותראו מה אני עושה שם, אני עושה מתוך from mymodule, מי זה mymodule?

286
01:39:07,560 --> 01:39:22,080
זה הקובץ הזה, מיימודג'ול, אימפורט אריי אבי ג'י, זאת אומרת, אני מייבא ספציפית את הפונקציה אריי אבי ג'י.

287
01:39:22,080 --> 01:39:35,940
שאם היה עושה, נותנים לו אריי או רשימה, הוא פשוט מחשף סכום ואז עושה לזה חלקי האורך, כל הכבוד, ממוצע. אז יש לנו את זה.

288
01:39:35,940 --> 01:40:05,880
אז מה אני הולך לעשות? אני הולך להריץ את הקוד שאתם האמת רואים פה בשקופית. הנה רשימה, שני איברים, ואני רוצה לחשב לה את הממוצע. אז מה אני עושה? אני קורא לה פונקציה אריי אבי ג'י שהבאתי אותה מתוך מיימודג'ול, וזה יעבוד לי. אבל אתם יודעים מה לא יעבוד? אם אתם עושים אימפורט סלקטיבי כזה, אז...

289
01:40:05,880 --> 01:40:35,620
אתם יכולים בטעות לנסות לקרוא לפונקציה אחרת שנמצאת ב-my module, אבל לא היווטתם אותה. כי תראו מה אני כותב פה, from my module אימפורט רק את אריי אבי ג'י. לא את אריי סאם. אז אם הייתי מנסה להריץ את הקוד הזה, פייתון היה אומר לי, אני לא מכיר את אריי סאם. אולי התכוונתם לאריי אבי ג'י? אז תשימו לב לזה. הקוד כאן מימינה אבל, אם הייתי...

290
01:40:35,620 --> 01:41:05,620
הייתי מנסה לעשות פרינט גם עם הרי סאם זה היה עובד, כי הבאתי את כל מהמודשול. אז בקוד שאני הבאתי לכם פה בטסט נקודה פאי, קודם כל הרצתי את הרי אבריג' שזה בסדר, ואז עשיתי ניסיון להריץ את הרי סאם שלא הבאתי אותו. אז גם פה כדי שהקוד לא יקרוס לי, אני עשיתי בבלוק כזה של טראי אקספט.אתם לא צריכים להכיר את הקונספט הזה, אבל הוא די מסביר את עצמו, כן? תנסה

291
01:41:06,420 --> 01:41:36,420
עריץ פונקציה שלא קיימת, לא הלך לך? אוקיי, אז תדפיס איזה סתם שטוט. בקיצור, פייתון טסט נקודה פאי. אז פה אני כתבתי את זה בפרינט, כן? זה לא שזה סתם כתוב. הנה, פרינט. ומה זה אומר? זה אומר שאיבנו את הפונקציה  rate average מהקובץ mind module נקודה פאי, אז הנה ה:rate שלנו. בואו נחשב את ה:average על ידי height average שלוש, חישובי. ניסיתי מאליו, הרי

292
01:41:36,420 --> 01:42:06,420
יאי, ומה יקרה אם אנחנו ננסה להריץ פונקציה שלא קיימת? אז ננסה להריץ את הקוד הזה: Let's try running הנה זה פה, הנה הפרינט: Try, לא הלך. לאקספט רץ, הפרינט של הארו. הרי סאם לא קיים. עכשיו, מה קורה אם אני פשוט אשנה את זה? אימפורט, אה...

293
01:42:06,960 --> 01:42:07,780
my module

294
01:42:10,960 --> 01:42:19,860
אולי אני אתחכם קצת. אה... לא, אני לא אתחכם, אוקיי. אז אם אני סתם עושה import my module, זה יעבוד? בוא נבדוק.

295
01:42:22,540 --> 01:42:35,140
אוקיי, אני אגיד לכם מה - זה לא יעבוד, אבל זה בסדר. כי פה יש קטע אחר, כשאני עושה import my module, אז אני צריך ללכת צד אחד רחוק יותר.

296
01:42:35,420 --> 01:43:04,220
אני לא יכול סתם ככה לקרוא לפונקציות, אני צריך להגיד, my module נקודה array average. וגם פה, my module נקודה array sum. הופה, אולי עכשיו זה יעבוד? בואו נראה. הנה array שלנו, חמש ואחת, אז array average שלו זה שלוש. ומה קורה אם אנחנו מריצים את array sum?

297
01:43:04,220 --> 01:43:29,440
6, ראיתם מה ההבדל? הפעם פשוט עשינו אימפורט מלא והפקודה הזאת כן רצה אז כשאחר כך אתם מתעסקים עם מודיולס ואתם עושים להם אימפורט כן כן לא לא שימו לב להבדלים האלה אוקיי?

298
01:43:29,440 --> 01:43:38,600
ועכשיו בואו נראה את המוד'יול האחרון שאנחנו נכיר לפחות בשביל התרגול הזה.

299
01:43:38,600 --> 01:43:59,260
הקלטה הזאת כבר מתחילה להימשך, כן? אל תדאגו, אנחנו לקראת הסוף. הנה מוד'יול נוסף, חביב בשם Matplotlib. אוקיי, ספריית סרטוט מתמטית. בקיצור, אנחנו רוצים לסרטט גרפים או היסטוגרם.

300
01:43:59,260 --> 01:44:29,060
איך נעשה את זה? בעזרת הפייקג' הזה, שהוא יהיה לנו שימושי. אז קחו דוגמה פשוטה. נניח שאנחנו מייבאים את הפונקציה הפופולרית מאוד בשם PyPlot, Python Plotting, סרטוט בפייתון. נקרא לה בשם מקוצר PLT. על הדרך נעשה משהו נוראי, נייבא ספרייה במלואה.

301
01:44:29,060 --> 01:44:47,400
שזה פשוט הרבה קוד בדרך כלל תשתדלו אם אתם רוצים לכתוב קוד שהוא יהיה יעיל, תנסו לעשות אימפוט סלקטיבי, אבל בסדר רק אם אתם צריכים שהקוד שלכם יהיה יעיל, כרגע אנחנו רק לומדים איך לתכנת, בסדר?

302
01:44:47,400 --> 01:44:58,300
אז אנחנו מייבים פה את הפייפלוט הזה, פונקציה אחלה. מייבים גם את כל ספריית מת... כל זה בשביל מה? אנחנו בונים לעצמנו רשימה...

303
01:44:58,300 --> 01:45:11,160
מתוך הטווח הזה שבין 0 עד 19 כולל. אוקיי, 0 עד 19, ואז מה אנחנו עושה? אנחנו נבנה רשימה, תראו איזה קטע.

304
01:45:11,900 --> 01:45:26,960
math. sin של pt או פוינט לכל פוינט in x, מה זה x? רשימת המספרים בין 0 ל-19 כולל.

305
01:45:26,960 --> 01:45:35,280
זאת אומרת, אנחנו בונים פה רשימה שהערך שלה יהיה, זה list comprehension מה שאתם רואים פה, יהיה sin0,

306
01:45:35,280 --> 01:46:05,240
סינוס 1, סינוס 2, סינוס 3, סינוס 4, סינוס 6, עד סינוס 19 כולל. עכשיו אם אתם שואלים אותי, במעלות או ברדיאנים? אז, אם אתם ממש רוצים לחשב את זה, בואו נראה. נשר רדיאן, שני רדיאנים, אנחנו יודעים זה... זהו, אתם יודעים מה שאוכל. תגלו בעצמכם, אנחנו...

307
01:46:05,240 --> 01:46:35,240
כבר לקראת סוף התרגול. בוא... בוא... בוא נמשיך הלאה. בקיצור, חישבנו את הציר X שלנו, שזה פשוט הטווח הזה בין 0 ל-19 כולל, ציר Y שלנו זה פשוט ערכי הסינוס, כן? X ו-Y, ואז ניקח את הפייפלוט שלנו ונגתיר לו: PLT נקודה, פלוט, סרטט, וסוגריים ציר X, ציר Y. זאת אומרת, לא סתם ציר X, ציר Y, אלא...

308
01:46:35,240 --> 01:47:05,240
הנה הערכים שלך בציר x והנה הערכים שלך בציר y,שרטט את זה כגרף עם קווים שמחברים בין הנקודות והנה זה הגרף. אז הנה בוא נראה לכם באמת פייתון פלוט אחד נקרא פאי. הנה הפלוטינג שלנו, הנה הסרטוט, אז באמת שתראו שאף אחד לא עובד עליכם, הנה אני אפתח את פלוט אחד.

309
01:47:05,240 --> 01:47:34,000
הנה הקוד, לא קוד מאוד מסובך, הוא פשוט נעזר בפקקג'ים שהגיעו מבחוץ. אז בנינו רשימה של ערכים בציר X, בנינו רשימה עבור ערכים בציר Y, ועשינו פלוט של אותם ערכים בציר X, אותם ערכים בציר Y, והפקודה הכי חשובה, show, PLT נקודה show, זאת הפקודה שתחריח כאילו את פייתון,

310
01:47:34,000 --> 01:47:57,920
להציג לכם את הפלוטינג שהוא כרגע בנה. אז הנה חלון הפלוט, יש פה גם כמה כפתורים בנויים כמו לא יודע, לעשות זום אין, אז הוא יודע לעשות זום אין, לעשות בק, אפילו אתם יכולים לעשות שינוי לכמה דברים רחוקים מהקצה של החלון וכולי, או אפילו לשמור.

311
01:47:57,960 --> 01:48:27,040
Save the figure, אז אתם יכולים לשמור את התמונה שלכם בכמה פורמטים שזה שימושי. נניח יהיו לכם תרגילי בית יותר מאוחר בתואר, שירצו שתשמרו פלוטים שאתם סרטטתם, אז כן, יהיה לכם את החלון בגודל הקטן הזה, אבל אתם יכולים גם להגדיל אותו אם אתם רוצים תמונה ברזולוציה יותר גדולה. קטע כזה שכדאי להכיר. קול. עכשיו אחרי שסגרתי את הפלוט, הפייתון סיים לרוץ.

312
01:48:27,040 --> 01:48:47,000
מגניב, אז בואו נלדוג מע אחרת. נניח שאנחנו רוצים רשימת ציונים, אז נניח כתבנו פה כמה שמות של אנשים, רשימה, כן? רשימה של שמות. רשימה של מספרים, עד כאן לא מסובך.

313
01:48:48,280 --> 01:48:55,180
ואנחנו רוצים ליצור את זה בתור היסטוגרם. אז תראו אנחנו ניקח מהפייפלוט.

314
01:48:55,180 --> 01:49:11,900
נריץ פונקציה בשם בר, מה זה בר? היה לנו עמודות של היסטוגרמות ונשלח כפרמטרים רשימה ראשונה, יהיה לנו בציר X, תהיה ה-student names, כן?

315
01:49:11,900 --> 01:49:23,200
פרמטר שני יהיה רשימת הציונים זאת אומרת הנה הערכים שיש לנו פה בשביל הציר Y, זאת אומרת...

316
01:49:24,760 --> 01:49:54,740
גובה של כל אחד מהברז האלה, לפי הסדר, כן? ופה פשוט הוא יצר לנו בסקאלה כזאת בציר Y, כן? אתם רואים? אז ה-student הראשון נניח O, היא הבר הראשון משמאל, יקבל את הערך הראשון משמאל של רשימת הגריידס, 87, אתם רואים? ועל הדרך אפילו הגדרנו לו color שווה blue, וואו, איזה פרמטר מנהים. הגדרנו את הבר הזה של ההיסטוגרמות.

317
01:49:55,260 --> 01:50:23,820
ושאו. אז הנה, אני אראה לכם שהקוד הזה קיים ואמיתי. אז הנה הוא, אימפורט רק לפייפלוט, יצרנו רשימת שמות, רשימת מספרים, נהיינו ציונים, הגדרנו בר, זאת אומרת, פשוט עמודות כאלה, אז הנה הרשימה הראשונה, הרשימה השנייה, צבע, ויאללה, תציג את זה. אז בואו נציג את זה. פלוט 2 נקודה פייפ.

318
01:50:24,680 --> 01:50:25,340
הנה זה.

319
01:50:27,900 --> 01:50:28,320
אוקיי,

320
01:50:30,780 --> 01:50:38,780
אני יודע, זה די מסביר את עצמו, כן? אני יכול, לא חייב ל-blue, אני יכול גם ל-red, או... אוקיי, הנה red.

321
01:50:40,040 --> 01:50:44,340
אני יכול גם ל-green, סתם שאלה, הוא מכיר מג'נטה?

322
01:50:47,380 --> 01:50:49,400
כן, הוא מכיר מג'נטה.

323
01:50:51,280 --> 01:50:55,640
אוקיי, מהר, להתחכם, אסאיין מכיר?

324
01:50:55,640 --> 01:51:25,640
הוא מכיר סיין, אוקיי. אוקיי נסע לנכון. גולד. יאללה, זהב. הופה, אוקיי הצלחנו לצבוע אותם. מגניב, נחזור חזרה לבלואו. מה יקרה אם אני אגרוף את הסדר של הפרמטרים, הוא ישרוד את זה? לדעתכם. שהגריידידס יהיה אבל טעים לצבע, מפשוט בלי להתייחס לצבע הזה. והוא שורט אפילו בכניסה מהפרומטרים, שתרצה חזרת נדריך ושאתה אוהב אותה לא גם בטחה חיפה. אבל חולה על המצלמטרים אחרת, לצבע ופשוט בלבא, והאתה לא נצמד שאתה צריך

325
01:51:25,640 --> 01:51:30,500
יהיה בציר X וה-STUDENT NAMES יהיה בציר Y? הוא בכלל יכול להבין את זה?

326
01:51:30,500 --> 01:51:55,540
אומייגאד, הוא בהחלט ניסה. כן. אני לא יודע למה ציפיתי, אני גם לא בטוח שאני יודע להסביר לכם. רגע, לפי איך הוא סידר את זה? בוא נראה. אבי, גיא, יותם, דנה, ואיך אמרנו שהסדר?

327
01:51:55,540 --> 01:52:22,140
אביגד, אה, יא, מ, הוא פשוט הכי שמאל הזה, פשוט הכי למטה. אוקיי, אז כן, אתם יכולים לחרבש היסטוגרמה ככה, לפי בחירתכם, פייתון לא שופט אתכם, מגניב, מגניב, מגניב. בקיצור, אל תפחדו להתעסק עם פרמטרים של פונקציות, כן? לא לפחד.

328
01:52:22,140 --> 01:52:50,840
אז בואו... בואו להסתכל באמת על הרעיון הזה של היסטוגרמות. ככה אגב, דרך אגב, אם תסתכלו בפונקציית האוניברסיטה... פונקציה, אני כבר רפוי בשלב הזה של התרגול. אם תסתכלו על אפליקציית האוניברסיטה לטלפון שלכם, כשאתם תעשו מבחנים ותקבלו ציונים, אז תוכלו באפליקציה הזאת לראות את היסטוגרמות הציונים שלכם.

329
01:52:50,840 --> 01:53:20,740
העמודה שתהיה מודגשת בכחול תייצג אתכם, הציון שאתם קיבלתם נכון לאותו מועד של מבחן או ציון סופי. וככה בעצם תראה היסטוגרמה. ככה היא תראה. אז, הנה כחול תרגיל. תנסו לכתוב קוד שמדפיס היסטוגרמה של ציונים. אז...

330
01:53:20,740 --> 01:53:36,940
אז איך אנחנו יכולים לכתוב כזה קוד? סתם דוגמא, נניח שאנחנו נכתוב את זה בפונקציה, אז הפונקציה שלנו קודם כל תגדיר לנו את ציר ה-X שלנו, שזה פשוט ה... נכתוב פה את זה במחוזות.

331
01:53:38,640 --> 01:54:08,580
הנה, אתם רואים כל הזמן, איך החלוקה אגב עובדת? לפי 10 נקודות צמודות, אז מי שיקיבל בין 0 ל-10 ימצא בעמודה הזאת, מי שיקיבל בין 31 ל-40 ימצא בעמודה הזאת, אתם מבינים? זה כזה חלוקה של 100 נקודות לתוך 10 עמודות היסטוגרמה, נכון? 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10. אוקיי. אז אנחנו נגדיר במה.

332
01:54:08,580 --> 01:54:37,980
10 מחוזות שונות עבור ציר ה-X. אנחנו נרצה לחשב את הגובה של כל עמודה, כן? אז מה נעשה? קודם כל, נתחיל רשימה ריקה של 10 עמודות ב-0, לא ריקה, סליחה, נתחיל רשימה של 10 איברים שייך שלהם ל-0, ועכשיו, בהינתן, שוב אמרו לנו, תכתבו משהו שנקבל ציונים,

333
01:54:37,980 --> 01:55:07,980
איך נחשב? אז אם אתם מסתכלים מקרוב תסתכלו קרוב מה קורה לכל ציון. אנחנו מבינים שכל.. כל ציון הוא כאילו הולך לתוך העמודה.. לתוך עמודה, כזאת, שמאגדת בתוך עשרה ציונים אז נניח יש לי 25. יש 25..

334
01:55:08,660 --> 01:55:37,440
אני רוצה לקחת 25 הזה, שהוא יהיה בעמודה הזאת כאן. איזה חישוב מתמטי אני הייתי עושה? אז תסתכלו מה כדאי לעשות. ניקח את הציון שלנו ונגיד נעשה חלקי חלקי, זאת אומרת חלוקה, תעזוב את השארית, ב-10. אז נניח 25 חלקי חלקי 10, ייתן לנו 2. אינדקס 2. שזה עליך.

335
01:55:37,440 --> 01:56:07,440
שתיים, שזה אחלה. אז בוא נעבוד על זה. עכשיו, בשביל לפתור בעיות קטנות של... מה קורה כשנראה שיש לכם ציון, נסתם דוגמה, 21. אם היה לנו 21? לא, סליחה. אם היה לנו לדוגמה ציון 20. או, 20. 20 חלקי 10 ייתן 2. אם

336
01:56:07,440 --> 01:56:37,440
אינדקס 2 אבל זה עמודה שלישית, אז מה שאנחנו נעשה בדיוק בשביל מקרה קיצון האלה אנחנו ניקח את הציון נעשה לו פחות 1 ואז חלקי חלקי וזה יביא אותנו לעמודה הדרושה שלנו, כי שימו לב האינדקסים שלנו הם בן 0 ל-9 כולל לא 1 עד 10, 0 עד 9 מחשבים. בקיצור נחשב לאיזה עמודה כל ציון מתאים ילך for grade in grades ופשוט. נוסיף אותו. לעמודה.

337
01:56:37,440 --> 01:57:07,440
עמודה רלוונטית שלו, מישהו עם ציון לעמודה רלוונטית שלו, אחרי זה פשוט נעשה פלוט.בר, ציר x שמות, ציר y. ה.....,בינס שלנו ויאללה נציג את זה, דרך אגב, איך אנחנו יכולים, להנפיץ בקלות, ציונים, אנחנו יכולים להיעזר, בספריית רנדום, אז מתוך ספריית רנדום עשיתי אימפורט לפונקציה בשם.

338
01:57:07,440 --> 01:57:37,300
רנד אינט, אינטג'ר אקראי, ופשוט אמרתי, גריידס הולכת להיות רשימה שמא תקחי רנד אינט בין 0 ל-100 כולל לכל מספר בריינג' של 50. במילים אחרות, 50 פעמים אני מגריל פה מספר בין 0 ל-100, וכל אחת מהגרלות האלה תהיה איבר נפרד ברשימת גריידס. וזה מה שאני שולח לפונקציה שלי.

339
01:57:37,300 --> 01:58:07,300
אז אני רק רוצה להראות לכם את ההרצאה של זה. הנה, אני גם אראה לכם את הקוד עצמו, בדיוק כמו שראיתם עכשיו. בואו נריץ את זה: python q5.py.בבקשה ויש לנו פה היסטוגרמה של ציונים.אם אני אסגור את זה, אני אריץ את זה שוב. היסטוגרמה שונה.אז אסגור את זה, אצי זה שוב. היסטוגרמה שונה. מי היה מדמיין?

340
01:58:07,300 --> 01:58:11,860
רנט אינט עובד.

341
01:58:11,860 --> 01:58:29,040
כן. וואו. איכשהו סיימנו את התרגול הזה. אין לי מושג איך אני אעביר אותו פרונטלית, אבל אני מקווה שיצאתם מהתרגול הזה מבינים קצת יותר פייתון.

342
01:58:29,040 --> 01:58:44,740
אני יצאתי מהתרגול הזה מבין קצת יותר פייתון על הדקויות שלו. ספריות זה משהו שפשוט אני משתמש בו בלי יותר מדי לחשוב, אבל הקטע של ניהול הזיכרון של פייתון שהוא יודע לקחת לי משתנים ופשוט.

343
01:58:45,420 --> 01:58:59,020
לתת להם את אותו אובייקט או תרחישים אחרים שבהם רשימות עובדות לפעמים כן בצורה צפויה ולפעמים לא. חייב להגיד לכם זה מסוג הדברים שבגללה.

344
01:58:59,020 --> 01:59:14,620
אני מודה על זה שאני מתרגל אתכם בפייתון, כי אני שיפרתי את הידע שלי בפייתון. אז רבותיי, תודה רבה שישבתם כאן כדי לראות ולהקשיב לתרגול הזה. נתראה עם קצת מזל בתרגול הבא.

