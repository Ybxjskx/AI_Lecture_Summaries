1
00:00:00,000 --> 00:00:15,000
היי, ברוכים הבאים לתרגול החמישי של מבוא למדעי המחשב. היום אנחנו נדבר על שני נושאים. הנושא הראשון שלנו יהיה סקופ, או כפי שהוא יודע בעברית תחום הכרזה, והנושא השני יהיה רקורסיה.

2
00:00:15,000 --> 00:00:29,900
בואו נזכר לרגע כאשר בשבוע שעבר אנחנו כתבנו דוגמא לפונקציה פשוטה שפשוט ידעה לסכום מספרים שבתוך רשימה ולהחזיר לנו.

3
00:00:29,900 --> 00:00:44,800
אז שימו לב לדוגמה הזאת כאן. יש לנו כאן פונקציה שקוראים לה סאם. היא מקבלת כפרמטר משתנה שקוראים לו arr. יש לה פה משתנה שקוראים לו mid.

4
00:00:44,800 --> 00:01:14,700
נותנים לו ערך 0 ואז אנחנו לא עושים איתו כלום. יש פה משתנה סאם 1. מהתחילים אותו ב-0 ואז יש לנו לו לטפור לכל מספר בתוך arr. אנחנו פשוט נוסיף אותו לסכום הגדל הזה של סאם 1. והכוונה היא שאחרי שהפור הזה ייגמר בכל איטרציות שלו בסאם 1 יהיה את כל הערכים, סכום כל הערכים של הרשימה ב-0.

5
00:01:14,700 --> 00:01:44,600
מה הבעיה אבל? הקוד שאנחנו רואים כאן הוא לא ירוץ כמו שהיינו רוצים. כי תראו, תראו למה. אנחנו קוראים לה פונקציה סאם כאן. הרי אני מזכיר לכם, כאשר אנחנו מגדירים פונקציה בדף, אנחנו פשוט מגדירים אותה. ככה הפונקציה תעבוד כשנקרא לה. אז פה אנחנו קוראים לה סאם ואנחנו דוחפים כפרמטר רשימה.

6
00:01:44,600 --> 00:02:13,240
ממש ככה על המקום רשימה שיש בה את 1, 2 ו-3. אוקיי, אנחנו מריצים את סאם, תאמינו לו בסאם 1 לאורך ריצת הפונקציה הזאת הסכום באמת יגדל. אבל זהו, לא קורה איתו כלום. ואחר כך כשאנחנו ננסה להריץ פה את הפקודה פרינט סאם 1, זה לא יעבוד לנו. למה? בגלל הנושא של סקופ.

7
00:02:13,240 --> 00:02:43,140
אז מה, מה בעצם קורה עם הנושא הזה? אז סקופ או בעברית תחום הכרזה של משתנה זה בעצם החלק של, החלק שבקוד שבו בכלל אפשר לגשת למשתנה שאפשר לעשות איתו משהו. תראו כשאנחנו נכנסים לפונקציה אנחנו פותחים מה שנקרא סקופ חדש זאת אומרת אנחנו נכנסים.

8
00:02:43,140 --> 00:03:13,140
נסים לאזור אחר בזיכרון כשאנחנו מתעסקים שם במשתנים וזה לא בהכרח אותו דבר כמו משתנים שנמצאים מחוץ לפונקציה. בצורה יותר ספציפית אנחנו יכולים להגיד שנוצרת מחסנית קריאות חדשה עבור הפונקציה הספציפית שלנו. טיפה יותר מאוחר בתרגול אנחנו נראה מכשות לזה. העניין הוא שאותה מחסנית היא באמת תכיר את המשת..ן..יהיה לה גישה אל המשתנים.

9
00:03:13,140 --> 00:03:43,140
של הפונקציה הנוכחית, אז דוגמא במתקרה שלנו התחלנו להריץ את הפונקציה סאם, אז למחסנית הקריאות שלה התווסף המשתנה המקומי הזה מין, התווסף לה המשתנה המקומי סאם אחד, ואפילו התווסף לה r, כשהרישחנו אותו כפרמטר ואז התחלנו להריץ את הפונקציה, זה התווסף למחסנית הקריאות הנוכחית של סאם, אנחנו עושים את הסכום הזה בסדר, סאם אחד.

10
00:03:43,460 --> 00:04:11,860
משתנה, אבלerma כשיצאנו מהפונקציה, כל הסיפור שקרה פה בפנים, נשאר שם, זאת אומרת אין לו שום קשר למה שנמצא פה בחוץ, כשפה מחוץ לפונקציה אנחנו מנסים להדפיס sum אחד, מי זה sum אחד? אין sum אחד. sum אחד אחר היה בתוך הפונקציה sum כשהיא עבדה, אבל היא נגמרה.

11
00:04:12,860 --> 00:04:42,860
אחד שנמצא כאן בכלל לא אותו דבר כמו זה, פה פייתון פשוט יגיד לנו לא מכיר צמ אחד, מי זה? אז מה אנחנו יכולים להבין בעצם מההבדלים האלה, אז בואו נשאלת את עצמנו את השאלות המתבקשות, קודם כל אם באמת יש את הנושא הזה, שיש משתנים מקומיים לפונקציאת נפרדות, אז האם אנחנו יכולים להשתמש באותו שם משתנה בין...

12
00:04:42,860 --> 00:05:12,860
פונקציות נפרדות, זאת אומרת, נניח פה היה לנו סם ונניח שהיינו עושים דפיין לעוד פונקציה אחרת, ובפונקציה אחרת היה לנו גם סם אחד. . אז התשובה היא שכן, בדיוק בגלל שמשתנה שהוא פנימי לפונקציה, הוא בדיוק ככה, פנימי לפונקציה, פונקציות אחרות, או מה שנמצא מחוץ לפונקציות, פשוט לא רואים, הם לא רואים.

13
00:05:12,860 --> 00:05:42,860
את זה אז זאת התשובה לשאלה ראשונה שאלה אחרת שואלת מה אם יש איזה שהוא משתנה שמופיע בתוכנית זאת אומרת אנחנו כותבים אותו בחוץ כזה ולא לא עושים משהו בפונקציה לא מנסים להחליף אותו במשתנה אחרת אז אנחנו נחזור לקטע הזה מה אנחנו יכולים לעשות במקרים כאלה בשאלה שלישית אוקי אז יש פונקציה שרצה שימה לעוץ מה?

14
00:05:42,860 --> 00:06:12,860
מה קורה למחסנית הקריאות שלה בסוף? לאן זה הולך? מה קורה למשתנים? אנחנו נראה דוגמה למעשה, מה קורה? עכשיו לפני שאנחנו נתחיל לראות דוגמאות, אני ארצה לשאול את עצמנו שאלה אחרת, הרעיון הזה של Scope, זאת אומרת עד עכשיו רק ראינו את הקונספט שאם יש פונקציה, אז משתנים פנימיים לפונקציה, זה לא אותו דבר כמו דברים שנמצאים מחוץ לפונקציה. אז, יש איזשהו...

15
00:06:13,960 --> 00:06:27,620
קונסטרקט, או איזשהו משהו אחר בפייתון שגם פותח מה שנקרא סקופ חדש משל עצמו? אז מה לגבי לולאה?

16
00:06:27,620 --> 00:06:43,720
האם הקוד הזה כאן יעבוד? נניח מה יש לנו פה? יש לנו פה לולאת 4, 4i in range עד 5, להדפיס את i ועל הדרך להגיד t שווה 6. ואחרי שהלולאה הזאת נגמרת.

17
00:06:44,000 --> 00:07:14,000
אנחנו אומרים פרינט את שלום ודי. זה יעבוד? אוקיי אז כדי לראות אם זה יעבוד בואו נבדוק יש לנו כאן את הקוד מוכן ומזומ�ן בכובץ פייתון בואו נריץ אותו ונראה מה אנחנו נקבל שקורה. נריץ פייתון איקושפט 4.4 איקושפטמה מה יתגיד לנו. אנחנו זוכרים ריינג' עד 5 זה בעצם ריינג' שזז מ0 עד 4

18
00:07:14,000 --> 00:07:44,000
כולל, ואז עשינו פרינט של מספר בתוך הריינג', אז הנה ה-0 עד 4 שלנו. ואחר כך, קראנו לפקודת פרינט של t ואז i והודפס לנו 6 ו-i. אז מה המסקנה מכאן?, שזה שכתבנו for כאן לפני פקודת הפרינט, מה שנמצא בתוך ה-for היה נגיש, כי הדפסנו t שווה 6, במקום לקבל שגיאה של 'הלו מי זה t'

19
00:07:44,280 --> 00:08:02,960
ו i שלנו היה בערך המקסימלי שלו 4, הרי הריינג' הזה שנגמר בחמש, הכוונה היא ריינג' בין 0 ל-4 כולל, אז זאת אומרת, אנחנו יכולים להבין מזה, שלכל הפחות, לולאות לא, לא שוברות לנו את הראש.

20
00:08:02,960 --> 00:08:32,960
בתוך לולאה עדיין באינטראקציה עם מה שבחוץ, זאת אומרת זה לא שזה איזושהי פונקציה שאנחנו אולי קוראים לה אולי לא, זה קוד שבאמת התרחש אלפני פקודת הפרינט פה אז עד כאן אנחנו מבינים שזה לא שהלולאה הזאת פתחה לנו איזשהו תחום הכרזה נפרד. למעשה, משהו שכדאי לדעת, בשפת פייתון, בסוגריים, בשונה מספות אחרות כמו

21
00:08:32,960 --> 00:09:02,960
רק דברים כמו הגדרה של פונקציה או הגדרה של קלאס או הגדרה של לא יודע פונקציית למדה או ליסט קומפרנציש כל מיני דברים מאוד מאוד ספציפיים כאלה, אבל כרגע אני רק מבקש שתזכרו הגדרה של הפונקציה, רק בתוך פונקציה נפרדת בעצם אנחנו פותחים סקופ חדש, במילים אחרות מה שראיתם בהתחלה של התרגול ראיתם פה את הפונקציה סאמה

22
00:09:02,960 --> 00:09:32,960
אז כאן היה סקופ תחום הכרזה כזה נפרד עצמאי מתוך שאר הפונקציה אז כל עוד שאתם מבינים את זה אכלה אז בואו באמת קצת נרחיב על הנושא הזה של משתנים מקומיים מה זאת אומרת ובכן כשיש לנו משתנים שהם מוגדרים לנו בתוך פונקציה אז הם משתנים מקומיים זה מסביר את עצמו המשתנים האלה

23
00:09:32,960 --> 00:09:41,560
הם מקומיים לפונקציה עצמה ולא רלוונטי למה שנמצא מחוץ לפונקציה, פשוט אין קשר.

24
00:09:42,700 --> 00:10:02,540
אז אלה משתנים מקומיים. מה אנחנו יכולים להבין עליהם? כמו שאמרנו עכשיו, שהם לא נגישים מחוץ לפונקציה עצמה. עכשיו אם עולה השאלה למה, מה זאת אומרת? למה אי אפשר לגשת להם? זה קוד שכתבנו, אז התשובה היא, תראו.

25
00:10:03,280 --> 00:10:50,280
אם אנחנו קראנו לפונקציה הזאת, כן?הירצנו את הקוד של הפונקציה, אז הקוד שכתוב בפונקציה ירוץ, כי אנחנו קראנו לפונקציה הזאת עם פרמטר אפילו. אבל כשהפונקציה סיימה לרוץ, גמרנו. כל מה שהיה פה - אף. לא נגיש יותר בזיכרון, פשוט אין יותר. אז קראנו לפונקציה סא"ם, קיבלנו את הערך חזרה, אם היה כזה, או שהפונקציה עשתה שינוי לאיזשהי חזרה. קראנו לפונקציה שא.נגרום לפונקציה ה אכבו על ערך חזרה. נתחיל הלוקח את האקדחים,

26
00:10:03,280 --> 00:10:24,940
אם אנחנו קראנו לפונקציה הזאת, כן? הרצנו את הקוד של הפונקציה, אז הקוד שכתוב בפונקציה ירוץ, כי אנחנו קראנו לפונקציה הזאת, עם פרמטר אפילו. אבל כשהפונקציה סיימה לרוץ, גמרנו. כל מה שהיה פה, אף, לא נגיש יותר בזיכרון, פשוט אין יותר.

27
00:10:24,940 --> 00:10:53,920
אז קראנו לפונקציה סאם, קיבלנו את הערך חזרה, אם היה כזה, או שהפונקציה עשתה שינוי לאיזשהו מקום בזיכרון שכן נגיש לה, אבל זהו. אז מה שנמצא פה, לא יהיה נגיש לנו. אנחנו לא יכולים סתם ככה, לקרוא למשתנים פנימיים בפונקציה, מחוץ לפונקציה, כשהפונקציה לא רצה. כי הדברים האלה פשוט לא נמצאים בזיכרון כרגע.

28
00:10:53,920 --> 00:11:03,560
עכשיו, יש דקויות קטנות בפייתון פה ושם, ואתם תשימו לב אליהן לאורך זמן, אבל ברמה עקרונית, זו הסיבה.

29
00:11:03,560 --> 00:11:23,820
אז בואו נסתכל כאן, הנה דוגמה פשוטה. יש לנו כאן פונקציה שקומנסם, מקבלת שני פרמטרים x ו- y, היא סוכמת אותם ומחזירה כערך חזרה את הסכום. מה זאת אומרת? כשאנחנו פה נכתוב.

30
00:11:23,820 --> 00:11:53,720
המשתנה ריזולט שווה לערך החזרה של הפונקציה סאם עם הפרמטרים שלוש וחמש. אז הרעיון הוא שאנחנו באמת נקבל פה את הסכום שהוא שמונה. עולה השאלה, מי מהמשתנים כאן הוא משתנה מקומי? אז כדי לענות לכם, אנחנו לקחנו את הקוד פה ועוד כמה קודים מאוחר יותר בתרגול, לאתר חביב שקוראים לו פייתון טיוטרל.

31
00:11:53,720 --> 00:12:02,560
and he just will show us step by step what happens when you run a code so here's the code here as you can see it's blank

32
00:12:02,560 --> 00:12:14,120
and let's run it again and again so I click here on next cuz we are not running a function that's just according to design

33
00:12:14,120 --> 00:12:44,120
יש לנו כאן, מה שנקרא, פרייים, הפכוונה היא מסגרות, תחשבו על זה בתור הסקופס הנפרדים של, לא יודע, מחסניות, זיכרון, תחשבו על זה, פשוט אזורים נפרדים בזיכרון, אז פה יש לנו את המסגרת הגלובלית, שזאת אומרת, הקוד מבחוץ, היה לנו הקוד הראשי, פשוט הקוד שרץ, בלי איזשהו משהו מבפנים, ויש לנו פה את מילה הסודית.

34
00:12:44,120 --> 00:13:14,120
הכוונה היא ההגדרה של הפונקציה סאם. ופה אנחנו מסתכלים ימינה, אובייקטים, זה פשוט קוד שנמצא בזיכרון מבחינת זה שאם נקרא לו, הוא ירוץ. כרגע זה פשוט הקוד שכתוב, זה כל מה שזה, עכשיו פה בחץ אדום, הפקודה הבאה בתור ריזולט שווה סאם עם פרמטרים 3-5. אז אם נחץ על next, מה שקורה? אנחנו מתחילים להריץ את הפונקציה סאם.

35
00:13:14,120 --> 00:13:25,320
וזה אומר שאנחנו פותחים מחסנית קריאות נפרדת, יש לנו פה מסגרת זיכרון נפרדת, ותראו מה יש פה.

36
00:13:25,320 --> 00:13:41,960
דבר ראשון, אנחנו רק מתחילים להריץ את הפונקציה סאם, ועל הדרך הגדרנו שני פרמטרים, פרמטר x ו-y, והנה הערכים שדחפנו להם מחוץ לפונקציה סאם שרק התחלנו להריץ אותה.

37
00:13:41,960 --> 00:14:11,720
אז יש לנו כאן במסגרת הנפרדת הזאת x שווה 3, y שווה 5, ורבותיי שימו לב x ו-y הם משתנים מקומיים של הפונקציה סאם, מקומיים. למה? זה בסדר שמחוץ לפונקציה דחפנו פרמטרים לפונקציה הזאת כדי להשתמש בה, אבל מה שזה אומר, זה שהערכים האלה הם מה שאנחנו בעצם מתחילים איתם.

38
00:14:11,800 --> 00:14:41,480
את המשתנים המקומיים האלה x ו-y של הפונקציה סאם. בסדר גמור, נריץ נקסט, אז הפקודה הבאה שאנחנו הולכים להריץ זה סאם שווה x פלוס y, ועכשיו שימו לב, אתם רואים את הסאם הזה? זה משתנה מקומי. כן, יש לו כאילו את אותו שם, כמו השם של הפונקציה, פייתון, אני מקווה, יסתדר עם זה, אבל זה העניין.

39
00:14:41,480 --> 00:15:11,400
בתוך הפונקציה שלנו, במחסנית קריאות שלה, מתווסף לנו משתנה מקומי נוסף שקוראים לו סאם, והערך שלו זה פשוט x פלוס y, 8. עכשיו מה קורה? אנחנו נחזיר ערך חזרה, שזה יהיה מה שיש בסאם. עכשיו מה שזה אומר, אתם רואים כתוב פה ריטיון ואליו, גם בתוך המחסנית הקריאות הזאת של הפונקציה סאם, כי זה האמת.

40
00:15:11,400 --> 00:15:41,400
האמת היא שגם ערך החזרה הוא נמצא במחסנית הקריאות אבל מה הקטע? זה הערך היחיד שישרוד את היציאה מהפונקציה. היצאנו מהפונקציה והנה אתם רואים - כל המחסנית קריאות שהייתה פה לפני כן, הלכה ומה שהתווסף למסגרת הגלובלית של הקוד מבחוץ,

41
00:15:41,400 --> 00:16:11,060
זה ערך החזרה שקיבלנו מסאם, והוא פשוט נשמר במשתנה ריזולט. וזה מה שהיה פה. אז לשאלה מי פה היו משתנים מקומיים, התשובה היא פרמטרים שהפונקציה קיבלה x ו y, המשתנה המקומי סאם, ולמעשה אפשר להגיד שגם ערך החזרה, ואז ערך החזרה הזה הוא מה שאחר כך שמרנו.

42
00:16:11,060 --> 00:16:29,140
לתוך המשתנה החיצוני, ריזולט, הוא חיצוני, כן? הוא מחוץ לפונקציה. אז יש פה הרבה דקויות קטנות, שעל חלק מהן אתם תעברו גם בקורסים עתידיים, ובכל מקרה, זה טוב להכיר את הרעיונות האלה כבר עכשיו.

43
00:16:33,700 --> 00:16:45,520
אז מה זה ריזולט? ריזולט כאן לא משתנה מקומי של הפונקציה, זה דווקא משתנה מבחוץ לפונקציה, הוא פשוט קיבל את הריטיון ואליו.

44
00:16:47,840 --> 00:16:59,180
עכשיו, אם דיברנו על משתנים מקומיים, מה לגבי משתנים שהם לא מקומיים לפונקציה אחת? אז פה מגיע קונספט של משתנים גלובליים.

45
00:16:59,180 --> 00:17:29,120
אז תראו, בפייתון משתנה גלובלי זה לא בעצם אומר הרבה, משתנה גלובלי פשוט משתנה שאתם כתבתם אותו מחוץ להגדרה של איזושהי פונקציה, אז זה משתנה שאמור להיות נגיש לכם לקוד הראשי, ואולי דברים בתוך פונקציות, אולי? איך זה יעבוד? בואו נראה, הנה דוגמה, יש לנו כאן.

46
00:17:29,120 --> 00:17:38,160
משתנה, כנראה גלובלי נקרא לו, מה זאת אומרת גלובלי? משתנה לא בתוך הגדרה של פונקציה, Result שווה שלוש.

47
00:17:38,160 --> 00:17:48,340
עכשיו אנחנו רוצים להדפיס את ערך החזרה של הפונקציה Sum עם הפרמטרים 1 ו-2, בואו נסתכל.

48
00:17:48,340 --> 00:17:56,700
בפונקציה Sum יש לנו את הפרמטרים x ו-y שהם בעצם משתנים מקומיים מ-Sum ועכשיו נתנו להם ערכים 1 ו-2,

49
00:17:56,700 --> 00:18:24,820
ואנחנו מגדירים פה משתנה מקומי Sum שווה ל-x ועוד y ועוד Result, הרזולט הזה אם ככה, כי הריזולט הזה קיים לפני שקראנו לפונקציה Sum, זה מחוץ למסגרת של הפונקציה Sum, אבל היא כנראה איכשהו תצליח למצוא את זה, כי למה? 1 ועוד 2 ועוד השלוש הזה מול החזירה לנו 6.

50
00:18:24,820 --> 00:18:54,700
אז בואו באמת נבדוק את זה בפייתון טיוטר, והנה, הנה הקוד שלנו, בואו נריץ את זה שלב שלב. קודם כל הגדרת הפונקציה נכנסת לפריימ הגלובלי, פשוט בתור קוד,Result שווה 3 במסגרת הגלובלית, ועכשיו נקרא ל-Sum עם הפרמטרים 1 ו-2, אז הנה משתנים מקומיים ב-Sum, בפונקציה Sum, עכשיו אנחנו נרצה.

51
00:18:54,700 --> 00:19:24,600
להריץ את הפקודה הזאת, ומה היא תעשה לנו? היא באמת תסכום לנו, תיצור משתנה מקומי שקוראים לו-Sum, שהערך שלו יהיה x ועוד y, 1 ועוד 2 ושלוש, ועוד הריזולט שכבר קיים בגלובל פריימפ כאן. אז שינוי את זה, נשמור ריטרן ואליו, שזה מה שיש במשתנה סאם, שיש. עכשיו נריץ את זה, נצא חוצה מהפונקציה, כל זה יתקפל לתוך.

52
00:19:24,600 --> 00:19:54,600
הריטיון value הזה היה שהיה 6 הוא עכשיו יהיה הערך של סאם בסוגריים 1 פסיק 2 והקוד הזה הולך לרוץ והתוצאה של הפרינט יהיה 6 הפרינט פשוט הולך להיות 6 בסדר גמור אז בואו נמשיך ותזכורת כמובן כמובן כמובן כשיש לכם משתנה שהוא במלחכות גלובלית

53
00:19:54,600 --> 00:20:24,600
אז הוא נשאר בזכרון עד שהתוכנית כולה מסיימת לרוץ, כן? בגלל מה הסקואופ נקרא לזה ככה? של הקוד שבחוץ. הסקואופ הוא לאורך חיצת התוכנית. ועכשיו, סוף סוף, בואו נבדוק קצת השוואה, משתנים קומיים, לעומת גלובליים, אז תראו מה יש לנו פה, יש לנו כאן משתנים גלובליים, מזמינים גדולים, משתנים גדולים, משתנים גדולים, משתנים גדולים, משתנים גדולים גדולים, משתנים גדולים, משתנים גדולים, משתנים גדולים, שמשתנים גדולים, ושמשת

54
00:20:24,600 --> 00:20:36,300
גלובלים x, y שווים 1 ו-2 בהתאם, ועכשיו אנחנו קוראים לפונקציה sum עם ערכים 2 ו-3.

55
00:20:36,300 --> 00:20:54,500
אז מה קורה? אנחנו נכנסים לפונקציה sum, לסאם יש משתנים מקומיים x ו-y, ונתנו להם את הערכים 2 ו-3. איך זה יראה? אז בואו נסתכל בפייתון.

56
00:20:54,500 --> 00:21:24,400
גם את הקוד הזה יש לנו פה, בואו נראה. אז מתחילים אותו, קודם כל הקוד של הפונקציה sum נכנס לפריימ הגלובלי בתור קוד, ועכשיו משתנים גלובליים x, y עם הערכים 1 ו-2 בהתאם, ועכשיו קוראים לפונקציה sum עם הערכים 2 ו-3 כפרמטרים, מה קורה? שימו לב.

57
00:21:25,200 --> 00:21:54,100
מסגרת, לא גלובלית, מסגרת מקומית לפונקציה sum עם x ו-y מקומיים לסאם 2 ו-3. ועכשיו השאלה. משתנה מקומי sum שווה x ועוד y. איזה x ועוד y? אז התשובה היא הx ועוד y המקומיים ביותר. כי זה בעצם הx ו-y הכי רלוונטיים, הרי אוקיי.

58
00:21:54,100 --> 00:22:23,880
יש x ו-y גלובליים, אבל אם בפירוש נתנו x ו-y לפונקציה המקומית שלנו, אז כנראה שזה הx ו-y שאנחנו רוצים. ועל כן, הערך של המשתנה המקומי הזה sum הולך להיות x מקומי ועוד y מקומי, 2 ועוד 3 שווה 5. ועכשיו תראו משהו, x פסיק y שווה 0 פסיק 0. זאת אומרת, אנחנו באים לאפס את x ו-y. איזה x ו-y? אז התשובה היא, הx ו-y.

59
00:22:23,880 --> 00:22:53,880
המקומיים, אלה שקיבלנו בהתחלה כפרמטרים, אז ייפסנו את x' המקומיים. ולבסוף נחזיר כירך חזרה את value של המשתנה מקומי sum, ומה שזה אומר, הנה הreturn value שלנו וכשזה ייגמר התוכנית נגמרת על ידי הפרינט של הסכום שחישבנו. ואם הסכום שחישבנו

60
00:22:53,880 --> 00:23:23,880
היה חמש, אז התוכנית הזאת תתפיס חמש. היא באמת תתפיס חמש. הנה פרינט אאוטפוט אפילו, בגלל שמישהו היה סופק. לא הראיתי את זה, לא הדגשתי את זה מקודם, אבל הנה הוא. אז אלו דברים כדי לדעת. אם יש לכם משתנה מקומי עם אותו שם, כמו משתנה חיצוני, אז המשתנה המקומי ביותר עם אותו שם, זה המשתנה שאתם... מחוסרים, זה לא משתנה מקומית? זה משתנה חיצונית, פשוט גם משתנה חיצונית? מגון, בגלל וואק 21 וואק 22 יוקרנד אפשר חדשות בכל זה להגיד הפרנטיטיב של צעד המשטנה

61
00:23:23,880 --> 00:23:43,860
כנראה מתעסקים איתו, ואז מן הסתם שלשנות את הערך של המשתנים המקומיים האלה, אבל אז פשוט לסגור את הפונקציה, אז זה לא בעצם, אין איזה משמעות פונקציונלית בשבילכם, כי זה לא מתעסק במשתנים החיצוניים עם מאות או שם.

62
00:23:43,860 --> 00:24:12,760
עכשיו השאלה שלנו היא, איך אנחנו יכולים לשנות משתנה גלובלי בתוך פונקציה? כלומר, בהינתן משתנה חיצוני, ריזולט שווה 3, נקרא לפונקציה סאם עם פרמטרים 1 ו-2, נכנסים לסאם x שווה 1, y שווה 2, ועכשיו אנחנו כותבים, ריזולט שווה 5, ואז ריטרן x פלוס y.

63
00:24:12,760 --> 00:24:40,140
אז מה הקטע? פה הריטרן שלנו יהיה x פלוס y, שזה 1 ו-2, כלומר 3, אז הרעיון הוא שאנחנו מחזירים פה 3, ופה יש לנו פרינט ריזולט, אז מה הקטע? אם ריזולט שלנו לא יתעדכן, הפרינט יהיה 3.

64
00:24:40,140 --> 00:25:10,100
אם ריזולט שלנו כן יתעדכן, הפרינט יהיה 5. אז התשובה היא, הפרינט הולך להיות 3. הפרינט הולך להיות 3, אתם יודעים למה? כי הריזולט כאן שכתבנו, ריזולט שווה 5, זה משתנה מקומי, בגלל שזאת פונקציה עם המחסנית קריאות הפנימית משל עצמה, פה פשוט הכרזנו על משתנה מקומי חדש בשם ריזולט, ונתנו ערך 5, והכל זה פשוט הולך להיות.

65
00:25:10,100 --> 00:25:40,000
להיעלם שהפונקציה תיגמר, ואנחנו נשארנו עם הריזולט החיצוני הזה פה, וזה הריזולט שהפרינט ידפיס, הוא ידפיס 3. ועכשיו, השאלה, מה אם בכל זאת אנחנו כן רוצים לשנות את הערך של משתנה גלובלי בתוך פונקציה? אז בשביל זה, יש בפייתון מילת מפתח גלובל, ומה אנחנו עושים איתה? ככה, אנחנו.

66
00:25:40,000 --> 00:26:09,980
אומרים בפונקציה שלנו, גלובל ריזולט, מה שזה אומר, זה אומר, אם אנחנו עכשיו נעשה עבודה עם משתנה בשם ריזולט, אז בבקשה, נא להתייחס לגרסה הגלובלית שלו, וזהו. ועכשיו כשאנחנו פה כותבים ריזולט שווה 5, פייתון יודע לפי ההקשר הזה, שהכוונה היא לריזולט החיצוני הקיים פה, והוא הולך.

67
00:26:09,980 --> 00:26:39,880
לקבל שינוי ערך ל-5. למעשה, יש לנו את זה פה, בקוד פייתון, כפי שאתם רואים כאן, עם ההקדשה פונקציה סאם, עם הגלובל שלנו, עם הקוד פה, אז בואו פשוט, נריץ את זה. אז נריץ את הקוד פייתון שלנו, הוא פשוט ידפיס 5. אז זה תרחיש קיצון נקרא לזה.

68
00:26:39,880 --> 00:27:09,880
אם אנחנו בכל זאת רוצים לשנות משתנה שחי מרוץ לפונקציה, בתוך פונקציה, בלי להגיד באופן ישיר משהו כמו ריזולט שווה הפונקציה כך וכך. יש דרכים לעשות את זה. בואו נתרגל את זה. נתחיל בתרגיל ראשון. להנן שלוש פונקציות נפרדות שהוגדרו לנו. ואנחנו הולכים לעשות איתן משהו.

69
00:27:09,880 --> 00:27:39,680
אז השאלה היא, מה התוכנית הזאת תדפיס? אוקי, איפה התוכנית? הגדרה של פונקציה, הגדרה של פונקציה, הגדרה של פונקציה, או קוד שרץ. הקוד מתחיל, A שווה 5. ואז פרינט מה שהפונקציה F תחזיר. בוא נלך לפונקציה F. הפונקציה F אומרת, A מקומי שווה למה שפונקציה G מחזירה. אוקיי, נלך.

70
00:27:39,680 --> 00:28:09,580
נלך לג'י, ואז G אומרת, A מקומי ל-G שווה למה ש-H מחזירה. מה H תחזיר? 2. A הולך להחזיר 2, פה. ואז פה אנחנו עושים ריטרן, A פלוס 1, כלומר, 3. G מחזירה 3, A שווה 3. ואז B שווה למה ש-H מחזירה, זה 2.

71
00:28:09,580 --> 00:28:25,100
b שווה 2, ריטרן a פלוס b שזה הa המקומי פה 3 ועוד הb המקומי פה 2, 5 f תחזיר 5, פרינט 5

72
00:28:25,860 --> 00:28:38,980
יש לנו דוגמה גם מפייתון טיוטר בואו נראה, יש לכם כאן בדיוק הדוגמאות שראיתם מקודם, הגדרה של g בפרייים הגלובלי, הגדרה frame הגלובלי

73
00:28:38,980 --> 00:28:59,280
הגדרה של h בפריים הגלובלי, הגדרה של f בפריים הגלובלי. שימו לב, זה רק הגדרות הפונקציה, הם לא רצו. עכשיו הקוד שמתחיל לרוץ, a שווה 5 משתנה גלובלי, ועכשיו, פרינט מה שf תחזיר.Let's go.

74
00:28:59,600 --> 00:29:08,540
נכנסנו ל f, a הולך להיות שווה ל... , מה ש-g יחזיר. נכנסים ל-g, שימו לב, f עדיין פתוח, והוא...

75
00:29:08,540 --> 00:29:38,540
והוא ממתין, F ממתין. נכנסנו ל G. עכשיו יש לנו פה A פנימי ב-G שאומר איך החזרה של H. אוקיי נפתח את ה-H פתחנו את ה-H ריטרנ ואליו 2. נפלא. זה אנחנו הולכים לקפל לתוך ה-A המקומי של G. ועכשיו אנחנו..

76
00:29:38,540 --> 00:29:52,840
G תחזיר לנו A פלוס 1, הכוונה היא לאה המקומי שלו, אז הריטנבלי של G הולך להיות 3, נתקפל מ-G, חזרה ל-F, עכשיו האה המקומי של F הוא 3,

77
00:29:52,840 --> 00:30:22,740
B שווה למה ש-H מחזיר, נכנסים ל-H, H פשוט יחזיר 2, ידוע, זה יתקפל ל-F, עכשיו B מקומי ב-F הוא 2, איך חזרה A פלוס B מקומיים? 5, וכל זה הולך להתקפל לפרינט 5. מדהים. יש לנו, דרך אגב, למי שהיו ספקות, את הקוד של שאלה אחד כאן, כפי שהיא, תמיד...

78
00:30:22,740 --> 00:30:52,600
בר שינוי, נריץ את השאלה, לא הפתעה גדולה. 5, דרך אגב, שאלות מהסוג הזה, זה שאלות שאוהבים הרבה לשים במבחנים בקורס מבוא למדעי המחשב, בקורסים דומים לו, כי אלו שאלות שבאות לבדוק, האם אתם יודעים לאן הקוד שלכם הולך? לאן הוא הולך? כאילו...

79
00:30:52,600 --> 00:31:22,540
מה הוא עושה? למי הוא קורה? מה... מה הסדר הפעולות? זה בדיוק מסוג השאלות. הנה שאלה דומה, אבל קצת שונה. מה ההבדל? אתם רואים שיש לנו פה איזה שהם ריטרנים וגלובליים, בואו ננסה להבין מה הפונקציה הזאת תעשה, סליחה מה הקוד הזה יעשה. כרגיל, הגדרה של G, H ו-F, יש לנו פה A שווה 5, פרינט F, אתם יודעים משהו.

80
00:31:22,540 --> 00:31:35,340
בואו פשוט נלך ישר לפייתון טיוטר אין לנו גרסא לזה בפייתון טיוטר צריך לעשות את זה בדרך הקשה אתם מוכנים? זה לא כזה קשה.

81
00:31:35,340 --> 00:31:51,540
יאללה a = 5 ואז פרינט מה שאף יחזיר. אוקיי מה אף יחזיר? נכנסים לאף גלובל a עכשיו אנחנו יכולים לעשות עבודה על ה a הגלובלי. פה.

82
00:31:51,540 --> 00:32:21,420
אז פה, נכנס, A גלובלי הולך להיות שווה למה ש-G מחזיר, אוקיי, נכנס. נכנסים ל-G, A מקומי ל-G שווה מה ש-H מחזיר. נכנסים ל-H, H מחזיר את A. אז פה, אני חושב שהכוונה היא שהוא הולך להחזיר את A כפי שהוא נמצא במצבו הגלובלי.

83
00:32:21,420 --> 00:32:46,020
אז חמש, זה ההנחה שלי, אולי אני טועה, אני מקווה שלא, אז חמש, חוזרים מ-H, אנחנו כאן, אז A שווה, A מקומי שווה חמש, ריטרן, A מקומי ועוד אחד, שש, חוזרים מ-G. A גלובלי עכשיו הפך להיות שש, שימו לב, שש. B שווה ל-G.

84
00:32:46,020 --> 00:33:06,920
b שווה ל h, b מקומי, מה h, סליחה, b שווה ל h, ומה h אומר? h מחזיר a כפי שהוא במצבו הגלובלי, המצבו הגלובלי זה כבר 6.

85
00:33:06,920 --> 00:33:36,820
כלומר b מקומי שווה ל 6, a גלובלי היה שווה ל 6 פה, ריטרן a גלובלי ועוד b מקומי, 6 ועוד 6, והתשובה היא 12. הופה, מתברר שכן יש לנו python tutor. אהה, נראה שאנחנו חסרנו אחד, אז יאללה, בואו נראה את זה עכשיו. הגדרות, הגדרות, הגדרות של פונקציה.

86
00:33:36,820 --> 00:34:05,620
a גלובלי 5, פרינט f, אוקיי, מה f מחזיר? נכנסים ל f, f אומר, עבודה עם a תהיה גלובלית, a שווה למה שg מחזיר, נכנסים ל g, g אומר, a מקומי הולך להיות שווה מה שh מחזיר, h הולך להחזיר את ה-a הגלובלי, ריטרן ואליו 5, חוזרים, a מקומי שמה, שימו לב, ב-g, a מקומי 5,

87
00:34:05,620 --> 00:34:35,520
ריטרן, את ה-a מקומי ועוד 1, 6, נפלא, חוזרים, ותראו מה קרה, a גלובל השתנה ל-6, ראיתם? בגלל שעשינו פה עבודה עם גלובל a, אז עכשיו פה a היה שווה למה שg החזיר, וg החזיר 6, אז a גלובל השתנה ל-6, עכשיו b מקומי, מה ש h תחזיר, h מחזירה, a, איזה a?

88
00:34:35,520 --> 00:35:05,020
חייב להיות הגלובלי, כי אין שום דיבור על a חוץ מזה, וזה אומר, ריטרן ואליו של h שהולך להיות 6, חוזרים חזרה ל-f, b מקומי 6, a גלובלי a, שימו לב, אנחנו בפונקציה f, אין לה a מקומי, וריטרן, a גלובלי, פלוס b, ריטרן ואליו 12, בבקשה, פרינט אוטפוט, פשוט 12, בדיוק כפי שראינו.

89
00:35:06,020 --> 00:35:24,020
ולבסוף, כמובן, יש לנו את q2.pi, תראו שהקוד הוא מה שראיתם, אז אם פשוט נריץ את זה, נקבל 12.

90
00:35:26,020 --> 00:35:55,760
אוקיי, אז דיברנו על סקופ, כל הדיבור הזה לא יהיה סתם מיותר, למעשה, זה יעזור לנו בהבנה שהנושא הגדול הבא, שזה פשוט, רקורסיה, נושא משמעותי במלוא למדעי המחשב, בואו ננסה להבין אותו, לאט לאט, קודם כל, מה זה רקורסיה? מבחינתנו, לפי האינטואיציה שלנו, רקורסיה זה הרעיון של...

91
00:35:55,760 --> 00:36:25,560
לפתור בעיה על ידי שימוש בפתרון הבעיה בגרסה קטנה יותר. מה זאת אומרת? נניח שאנחנו רוצים לחשב 2 בחזקת n חיובי כלשהו, הדרך שאנחנו היינו עושים את זה, היא פשוט להגיד, 2 בחזקת n, מה זה? זה בעצם 2 כפול 2 בחזקת n מינוס 1.

92
00:36:25,660 --> 00:36:55,540
מה זה בעצם אומר? זה יכול להזכיר אינדוקציה לחלק מכם, זה הרעיון של, אנחנו יודעים מה אנחנו נעשה עכשיו, נעשה 2 כפול, ואז נגיד 2 כפול שאר הבעיה. אבל מה זה שאר הבעיה מבחינתנו? n פחות 1 עכשיו, כן? כי טיפלנו באחת מהמספרים של n פה, 2 כפול. ואז, איך זה מתורגם?

93
00:36:55,540 --> 00:37:10,540
בפונקציה נגיד כזה דבר. אנחנו נכריז ממש בדפייני פאו 2 עם פרמטר n, מה אנחנו נגיד? נחזיר 2 כפול.

94
00:37:10,540 --> 00:37:25,040
ואז נקרא לפונקציה עצמה מתוך עצמה, אבל על n פחות 1, ואז התקווה היא שנגיד 2 כפול, 2 בחזקת n מינוס 1.

95
00:37:25,040 --> 00:37:54,940
ואז כשניכנס שם הפנימה, זה פשוט נפתח עוד מחסנית קריאות, עוד פעם ניכנס לפונקציה פאו 2, הפעם עם n פחות 1, ואז שם אז יהיה 2 כפול, פאו 2, n פחות 2, וכן הלאה וכן הלאה. רגע, איפה עוצרים? איפה תנאי הצירה? חסר לנו כאן משהו. אז מה חסר? מה שקורה כשהגענו לתחתית, כשn נניח שווה 0.

96
00:37:54,940 --> 00:38:14,100
ואז מה קורה? טוב מספר בחזקת 0 שווה 1 ואז מה זה בעצם אומר? זה יהיה 1 כפול 2 כפול 2 כפול 2 זאת אומרת כשכל פעם נריץ את הריטרן הזה זה יהיה ריטרן מהצד הימני.

97
00:38:14,100 --> 00:38:43,600
לתוך פה כל זה יהיה חושב ריטרן ואז עוד פעם פה ריטרן, אתם מבינים? זה הולך להיות לולאה ממש כזאת לולאה של לצאת החוצה מכל הקריאות הפנימיות. זה קונספט שאנחנו חייבים לראות אותו בדוגמה. אז בואו נראה את זה בדוגמה. הנה הפייפון טיוטר שלנו. יש לנו פה את הפונקציה פאו 2 בחזקת n.

98
00:38:44,420 --> 00:39:04,200
נגיד, נריץ אותה 2 בחזקת 3, לא הרבה קריאות, איך זה נראה? אז קודם כל, פאו 2 נכנסת למסגרת הגלובלית, לזיכרון הגלובלי, בתור קוד, מוכן לעבוד. יאללה, נקרא לפאו 2 עם פרמטר 3.

99
00:39:04,960 --> 00:39:15,120
אז נכנסים לפונקציה, פותחים מחסנית, פאו 2, פרמטר n, בערך 3.

100
00:39:16,120 --> 00:39:32,640
עכשיו, אנחנו שואלים, האם n הוא 0? לא. אז מה אנחנו אומרים? אנחנו נרצה להחזיר 2 כפול עוד קריאה לפאו 2 עם n פחות 1.

101
00:39:32,640 --> 00:39:47,040
אז לפני שאנחנו נוכל לענות על הריטרן הזה, אנחנו צריכים לעשות אבליואציה לסיפור הזה, והאבליואציה לסיפור הזה תדרוש להריץ את פאו 2, עוד פעם, בתוך הפאו 2 החיצוני.

102
00:39:47,040 --> 00:40:02,420
אז מה שקורה, אנחנו נכנסים עמוק יותר לתוך מעמקי מחסניות הקריאות שלנו. ועכשיו, בזמן שהפאו 2 החיצוני ממתין לנו, אנחנו צריכים לפתוח אותו שוב.

103
00:40:03,020 --> 00:40:31,800
בנפרד. שימו לב, זה בזיכרון נפרד, מקום אחר בזיכרון. אז אנחנו מריצים, פאו 2, הפעם, כששלחנו במקור עבור n פחות 1, התכוונו לזה, הn המקומי היה 3, קראנו עם n פחות 1, זאת אומרת, n מקומי חדש בפאו 2 הפנימי עוד יותר, זה n שווה 2.

104
00:40:31,800 --> 00:41:01,720
ושוב, מריצים את השאלה, האם n שווה ל-0? לא, אז נרצה לעשות את הריטרן 2 כפול, אבל 2 כפול מה? קריאה נוספת לפער 2 עם 2 פחות 1. ועכשיו, בלי לסגור אף אחד מהקריאות הקודמות לפער 2, פתחנו עוד קריאה לפער 2, n שווה 1, ושוב, איפה n שווה 0? לא, דלג.

105
00:41:01,720 --> 00:41:30,920
ריטרן 2 כפול מה? עוד קריאה, אחרונה אני מקווה, לפער 2 עם 1 פחות 1 שזה 0. והנה, הכי עמוק שירדנו במחסנית הקריאות, תראו. כמה פעמים קראנו לפונקציה פער 2 בלי להתקפל, בלי לסיים ריצה של אחת מהפעמים של הפונקציות, כי הן מחכות, כל הפונקציות האלה, אתם יודעים למי הם מחכים? הם מחכים לקבל את הערך הזה.

106
00:41:31,520 --> 00:41:55,360
כדי לחשב את כל הכפל הזה ואז הם יוכלו לעשות את פעולת הריטרן עם הריטרן value. הם מחכים! אבל הנה אנחנו. קריאה אחרונה לפאו 2, הכי פנימית שיש. n שווה 0, כן ועל כן ערך מקומי חדש כאן ריטרן value שהולך להיות 1.

107
00:41:57,200 --> 00:42:10,060
יאללה, נזינים את זה, תראו מה קרה, Return Value 1, ברגע שהיום יוחץ פה על Next, אז סוגרים את כל הקריאה הכי פנימית הזאת לפאו 2,

108
00:42:11,120 --> 00:42:25,200
והפונקציה פאו 2 עבור n שווה 1, היא מקברת עכשיו Return Value, למה? כי יש לו 2 כפול מה? כפול ה-1 הזה, שפאו 2 0 נתן לנו, ראיתם?

109
00:42:25,420 --> 00:42:54,080
הנה, פאו 2 עבור n שווה 0, ה-Return Value שלה הולך להיות 1, ועכשיו, פאו 2 עבור n שווה 1, נותנת לנו את ה-1, סליחה, כאן, 1 פה, כפול 2, ועל כן, פאו 2 עבור n שווה 1, עם ריטרן ואליו של 2. זה עכשיו יהיה 2, בקריאה הזאת,

110
00:42:54,940 --> 00:43:24,060
Next, ועכשיו, עלינו לקריאה שמעליה, שבאה לפניה, עבור n שווה 2, ועכשיו זה בסגנון של 2 כפול 2, שזה 4. אז עבור ה-Par 2, n שווה 2, ה-Return Value עכשיו הולך להיות 4, וגם זה הולך להתקפל, שימו לב, לקריאת הריטרן שממתינה לנו עוד מעט חיים.

111
00:43:24,060 --> 00:43:54,060
עבור N שווה 3 המקורי עכשיו זה 4 פה כפול 2 יותר נובל ל-8 וכל זה הולך להתקפל לפה למעשה עכשיוow 2 עם הפרמטר 3 עכשיו סוף סוף זה חושב פייתון סיים לחשב את זה להיות 8. עכשיו אין לנו פה פקודת פרינט אז אתם לא תראו פה אאוטפוט,אבל אם פקודת קלטת שנות פקודט הולך להשיג את זה בקיצוני:

112
00:43:54,060 --> 00:44:01,740
אם היינו עכשיו שמים פה פרינט שמקיף את ה-power2,3 אז האאוטפוט באמת היה הולך להיות 8.

113
00:44:06,020 --> 00:44:10,660
אוקיי, אין לנו את זה פה בקוד, אבל יהיה לנו קוד אחר שבודק רקורסיה, אז הכל בסדר.

114
00:44:11,220 --> 00:44:21,660
בקיצור, מה שאתם ראיתם עכשיו זה הקונספט הזה שפונקציה קוראת לעצמה פעם אחרי פעם אחרי פעם, וכל קריאה נפרדת היא במקום אחר בזיכרון.

115
00:44:22,260 --> 00:44:37,960
אז זה לא דרס משהו פה בזיכרון, חס וחלילה. זה עובד. פשוט פונקציה קוראת לעצמה, שקוראת לעצמה, שקוראת לעצמה, עד לתנאי הצירה שלנו.

116
00:44:39,460 --> 00:44:52,220
אז בואו באמת נזכר קצת בחישוב סדרת פיבונאצ'י שאולי ראינו כבר פעם או פעמיים בחיים שלנו. אתם זוכרים איך סדרת פיבונאצ'י מוגדרת? המספר... האפס.

117
00:44:52,220 --> 00:45:22,120
בפיבונאצ'י זה פשוט 0. המספר האחד בפיבונאצ'י זה 1. ואז נגיד עבור כל שאר המספרים החיוביים n, הם פשוט סכום שני מספרי הפיבונאצ'י שקדמו להם. אז שואלים אותנו, תכתבו פונקציה שנקבלת את n ומחזירה את מספר פיבונאצ'י, והפעם כנראה בריקורסיה. איך נעשה את זה? אז... קודם כל ננסה להבין.

118
00:45:22,120 --> 00:45:52,120
איך התוכנית תשים לב לערכים של n בקריאות השונות, איך זה הולך? אז אתם זוכרים, היו לנו מחסניות קריאה נפרדות לכל קריאה, כן? אז הנה הקוד הרקורסיבי הקלאסי, תראו מה זה: אנחנו רוצים לחשב את הfibonacci h old . קודם כל מה אנחנו אומרים, אם ה-n הזה הוא קטן משתיים כלומר אם זה 0 או אחד, בהנחה שמדובר ב-n.

119
00:45:52,120 --> 00:46:12,040
שהוא 0 או יותר גדול, כן? אנחנו לא מדברים פה על n שלילי, חס וחלילה. אז פשוט נגיד "ריטרן n". למה? כי הפיבונאצ'י ה-0 הוא 0, פיבונאצ'י 1 הוא 1, וכל השאר, פשוט מאוד, נגיד, "ריטרן pib n פחות 1" ועוד פיבונאצ'י n פחות 2.

120
00:46:12,980 --> 00:46:21,840
אז מה שיקרה, נניח אם היינו קוראים לפיב 2, אז היינו...

121
00:46:21,840 --> 00:46:51,280
מחשבים, פיב n פחות 1, שזה 1, היינו פה מקבלים 1, ועוד פיב של n פחות 2, היינו מקבלים פה 0, אז 1 ועוד 0 זה 1. היינו מקבלים את הערך. בואו נראה את זה. דרך אגב, בואו נראה את זה רץ. אז הנה פה יש לנו קוד לדוגמה של q3. אנחנו נרצה לחשב את המספר הפיבונאצ'י העשירי.

122
00:46:51,280 --> 00:47:20,760
אז יש לנו פה פיב, ואנחנו נקרא לו אם 10. אתם רואים את הקוד? כתבנו פה, "הטנטף פיבונאצ'י נאמבר איז פיב 10". והנה הקוד, ברקורסיה. בואו ננסה אותו. מעניין אם הוא יחזיר לנו q3.5. "טנטף פיבונאצ'י נאמבר איז 55". וואלה! מעניין.

123
00:47:21,360 --> 00:47:50,520
אם אנחנו עכשיו, דרך אגב, נחפש על סדרת פיבונאצ'י, נגיד פיבונאצ'י סיקוונס, אז בואו נראה אם בויקיפדיה יש לנו את המספרים הראשונים של סדרת פיבונאצ'י. הנה הם, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. וואלה! זה עבד לנו.

124
00:47:50,520 --> 00:48:20,520
איזה כיף. זתירו את הקוד הפשוט הזה. רקורסיה טהורה. זה פיבונצ'י בצורה הכי פשוטה שאפשר לראות אותו בעיניים. עכשיו, יש קטע כזה ברקורסיה שבו אנחנו חייבים לשים לב למתי אנחנו קוראים לרקורסיה עצמה, זאת אומרת, מתי מגיע חלק שבו אנחנו כותבים?

125
00:48:21,480 --> 00:48:51,480
קריאה לפונקציה עצמה עם פרמטר שונה, השאלה היא מתי אנחנו עושים את זה, עד עכשיו אתם ראיתם דוגמאות פשוטות, שזה פשוט הגיע מתי שזה היה צריך להגיע כי חלק מהיחל חזרה, אבל לפעמים זה לא ככה ובואו תראו את הדוגמאה שממש ממחישה הבדל, יש לנו כאן שתי פונקציות קטנות, אחת עושה כאונט דאון והשנייה עושה כאונט אפ

126
00:48:52,380 --> 00:48:53,580
מה ההבדל?

127
00:48:54,580 --> 00:49:21,140
הקוד נראה דומה מאוד, בואו נסתכל, נניח על הקאונט דאון. יש עצם פה דפיין לקאונט דאון, קאונט דאון עם i, ומה אנחנו אומרים? אם i קטן מ0 אז נחזיר כלום, זאת אומרת, נעצור פה וזהו. אחרת, נדפיס את i, ואז נקרא לפונקציה קאונט דאון עם i פחות 1. אוקיי, אבל אז בואו נסתכל על הקאונט אפ.

128
00:49:21,140 --> 00:49:51,140
מה ההבדל בסך הכל? שוב באותו תנאי הצירה אם i קטן מ-0 נעצור כאן ואז אנחנו אומרים count up אם i פחות 1 ואז print i ? רגע חוץ מהעובדה שלשתי הפונקציות יש שמות שונים הן כתובות בדיוק אותו דבר אבל מה ההבדל היחיד? בפונקציה countdown פרינט בה לפני הקריאה הרקורסיבית

129
00:49:51,140 --> 00:50:21,140
ובפונקציה קאונט אפ, הקריאה הרקורסיבית מגיעה לפני הפרינט. מה ההבדל? מה הולך להיות מודפס? אני חייב לראות את זה. אז נלך לקובץ הפייתון שלנו שבאמת מדפיס את זה. הנה שתי הפונקציות מוגדרות קאונט דאון וקאונט אפ. יש לנו פה פרינטים. אז יאללה בואו נקרא לקאונט דאון ואז לקאונט אפ. האם זה באמת עובד ככה? בואו נראה.

130
00:50:21,140 --> 00:50:32,780
פיידון, קאונט דאון אנד אופ, מה קרה פה? קאונטינג דאון, 10, 8, 9, 6, 6 ... עד 0.

131
00:50:34,460 --> 00:50:46,360
ואז קאונטינג אפ, 0 עד 10, מה? אז זאת אומרת כל ההבדל היה בסך הכל הסדר הזה? למה? בואו ננסה להבין ביחד.

132
00:50:47,480 --> 00:51:16,840
בואו נסתכל טיפה על קאונט דאון, למה בקאונט דאון הוא הדפיס ואז בסדר יורד? בואו נראה מה הסיפור. קראנו לקאונט דאון עם 10. ועכשיו נכנסנו לקאונט דאון עם 10, האם 10 קטן מ-0? לא, אז אנחנו מריצים פקודה פרינט 10. ועכשיו קריאה אקורסיבית.

133
00:51:16,840 --> 00:51:46,840
countdown עם 9, אוקיי נכנס לקאונט דאון, 9 קטע מ 0, לא. פרינט 9 ואז קאונט דאון 8, אהה אתם מבינים? לפי הסדר הזה, קודם אנחנו מדפישים את ה-i הנוכחי ואז אנחנו עושים קריאה רקורסיבית עבור i קטע מ 1, ולכן אנחנו מדפישים את המספר הגדול רקורסיה, i פחות 1, מדפישים רקורסיה.

134
00:51:46,840 --> 00:52:16,200
i פחות 1, כל זה ממשיך עד וכולל 0, עושים פרינט ל-0, קאונט דאון עבור מינוס 1, ואז כאשר i הוא מינוס 1, ריטרן כלום, ואז מה קרה? כשזה עושה ריטרן, אנחנו עושים ריטרן חזרה לקאונט דאון עבור i שווה 0, אבל כש-i היה שווה 0, כבר סיימנו את הפקודה שקרה לקאונט דאון עבור i שווה מינוס 1, וזהו.

135
00:52:16,200 --> 00:52:46,200
הוא פשוט סיים וככה התקפלנו מכאונט דאון לכל אורך הדרך עד לכאונט דאון שהדפיס את 10 לא היה לו עוד מה לעשות הוא פשוט סיים את העבודה שלנו ואז מה קורה בקאונט אפ בואו נסתכל קאונט אינג אפ הראשון שהוא הדפיס זה 0, למה? הרי שלחנו לו 10 מה קורה? אז

136
00:52:46,200 --> 00:53:16,200
נניח נקרא לקאונט-אפ עם 10, אז יאללה, קאונט-אפ עם 10, קריאה ראשונה, 10 כתבים 0? לא, אז קאונט-אפ 9, אוקיי? ניכנס לקאונט-אפ 9, נכנסנו ל-9, 9 כתבים 0? לא, וקאונט-אפ 8, לולא, 6, 5, 4, 3, 2, 1, 2, 1 אפשר להכין שזה זה תוכניות מבין הרעיון הזה, אתה צריך לדעת אותה בתוכניות של העזה, אין דברים כזה להוכיח לזה בעצם, אפשר להכיר אותה בדיוק, טבעונה למדי דן של המדינה וחקירה באמת לגן בעיתונאוטיב איתם ישלה בשבוע

137
00:53:16,200 --> 00:53:37,880
0, מינוס 1, ריטרן. אוקיי, סוף סוף יצאנו משם. אז עכשיו אנחנו חוזים חזרה לקאונט-אפ של i שווה 0. ועכשיו אנחנו עושים פרינט 0. אהה, פרינט 0. ועפים החוצה. למי?

138
00:53:38,680 --> 00:54:00,340
עפים החוצה לקאונטאפ של i שווה 1, והוא בדיוק סיים את הפקודה הרקורסיבית, הוא עושה פרינט 1, הבנתם? ו-0 ו-1 ו-2 ו-3 ו-4 ו-5 ו-6 ורק בסוף 10 סוף סוף אנחנו סוגרים את ההרכיה הרקורסיבית הראשונה של קאונטאפ 10, וזה כל ההבדל.

139
00:54:00,340 --> 00:54:30,300
כל ההבדל. אז דרך אגב, שתדעו, בגרסה המקורית של התרגול הזה, על שניהם היה כתוב קאונט-דאון, ואז בכלל הציפייה הייתה שאתם תגלו. אני אמרתי, לא, לא, לא, בוא, בוא נסביר לכם את זה ישירות, שתראו את ההבדל. ככה אנחנו יכולים לספור למטה או לספור למעלה, עם אותו קוד, פשוט לשנות את הסדר, להחליט מתי הקריאה הרקורסיבית שלנו, בסוף או לפני.

140
00:54:30,300 --> 00:54:54,180
לפני הסוף, לעשות פעולה על הקריאה הרקורסיבית הנוכחית לפני הרקורסיה או אחרי הרקורסיה, יש לזה משמעות. ואחד מהקישורים הנחוצים כדי להיעזר בתכונת רקורסיה כמו שצריך, זה לדעת מתי הזמן לזה ומתי הזמן לזה.

141
00:54:56,560 --> 00:55:26,560
בואו נתרגל קצת לקורסיה. אומרים לנו, תכתבו פונקציה שמקבלת רשימה ממוינת של מספרים חיוביים כלשהם, נניח נקרא למטבעות, ואיזשהו ערך אי שלילי n. הפונקציה הזאת היא תחזיר לנו, האם אפשר לפרוט את n בעזרת רשימת המטבעות האלו, אך שפה ספציפית, נותנים לנו ויתור. מותר להשתמש בכל מטבע יותר מפעם אחת. זאת אומרת, זה לא שמותר. ויטר אפשר להיות

142
00:55:26,560 --> 00:55:56,560
שצר לנו רק שימוש אחד לכל מטבע, אלא יותר בקטע של האם n נתון, אנחנו יכולים לבטא בתור, תקשיבו טוב, סכום של מכפלות של מספרים מתוך הרשימה. ואז איך זה בא לידי ביטוי בדוגמאות שאתם רואים פה, אומרים לנו coin נניח 2, 3 ו-10 ו-n שווה 7. איך נבטא 7? נגיד, אם n = 24 אז נניח 8 ונניח 8 ונניח 5 ואז נבטא 6 ואז נניח 6 ואז נניח 8 ונניח 12 ונניח 8 ונניח 4 ונניח 6 ואז נתון 8 ואז נניח 4 ואז נניח 5 ואז נניח 6 וננגיד 8 ונצור 8 וה

143
00:55:56,560 --> 00:56:26,560
שתיים ועוד שתיים שזה ארבע ועוד שלוש שבע או להפך היינו עושים את הספיר ההפוך היינו אומרים שלוש ואז שתיים ועוד שתיים זה מה שהיה עובד היינו מכסים את שבע. מנגד? עם רשימה כזאת של 2 10 ו12? לא משנה איזה קומבינציה שלהם לא נוכל לבטא את 15. זה יחזיר פולס

144
00:56:26,560 --> 00:56:56,560
אוקיי, איך אנחנו נבנה קוד רקורסיבי שעושה זה? מה אנחנו צריכים לחשוב? אז תראו, אנחנו צריכים לחשוב על הגישות שלנו. לדוגמה, אם נותנים לנו n שהוא קטן מהמטבע המקסימלי שלנו, לדוגמא, בעבור הרשימה הזאת, 2, 3, 10, אנחנו יכולים להתחיל מהסוף, למרות שמותר גם להתחיל מההתחלה, זה בסדר.

145
00:56:56,560 --> 00:57:26,460
להגיד, 10, האם אתה גדול מ-n? אם כן, דלג על 10, תעבור לערך הקטן יותר ממנו. ועכשיו, נניח שכאילו התעלמנו מ-10, ועכשיו יש לנו תת רשימה, רק 2 ו-3, מה עושים? שואלים שאלה, 3, האם אתה קטן מ-n? לא, אוקיי.

146
00:57:26,460 --> 00:57:55,660
אז מה אנחנו יכולים לעשות? לעשות n פחות 3, ואז יישאר עם n חדש שהוא 4, ושוב לחזור לתהליך, ואז נעשה את זה עוד פעם, יהיה לנו 4 פחות 3, 1. אבל אז מה קורה? נקבל ש-n הוא קטן יותר מכל המטבעות שנשארו לנו, וזאת לא תוצאה טובה, אז נלך אחורה.

147
00:57:55,660 --> 00:58:25,560
ולמעשה, אנחנו לא נוכל להחזיר 3 פעם שנייה, אלא נצטרך לעבור לשתיים, ואז אנחנו נעשה את ה-4 פחות 2 ועוד פעם 2 פחות 2. זה בערך הרעיון שלנו. עכשיו, כדי לעשות את הדברים האלה, אנחנו צריכים לחשוב על, באמת, מה אנחנו עושים? מה אתם חישים האפשריים עבור n, והמטבע הכי גבוה שאנחנו כרגע נתון לנו לשימוש? אז...

148
00:58:25,560 --> 00:58:55,460
אז כמו שאמרנו, אם הערך של n הוא קטן מהמטבע המקסימלי, אז המטבע המקסימלי לא רלוונטי, נתעלם ממנו, והמקסימום החדש שאנחנו נסתכל עליו יהיה הערך הקודם לו ברשימה הזאת. זאת רשימה ממוינת. עכשיו אנחנו אומרים, אם הערך של n הוא לפחות המטבע המקסימלי, זאת אומרת, n יכול להיות אפילו גדול יותר, אז נחסיר מ-n את המטבע המקסימלי ונתחיל חזרה עם n קטן יותר.

149
00:58:55,460 --> 00:59:25,460
עכשיו. זה בערך הרעיון הרכוסיבי. ואז כמובן מתי מקרי הבסיס שלנו מגיעים, באים לידי ביטוי. אם הגענו ל-N שווה 0 בדיוק. יש, הצלחנו. אם איכשהו הקטענו את N מתחת ל-0, הרצף הזה של סכום מכפלות, לא עבד. נעיף את זה, זה כישלון, נלך אחורה. איך נכתוב את זה בקודבה? אז בואו תראו, בוא תראו...

150
00:59:25,460 --> 00:59:55,460
דוגמה לרעיון, דוגמה לזה, הנה איך אנחנו יכולנו לעשות את זה, אז ככה, יש לנו קוד, פה זה סתם דוגמה, עם רשימה coins ו-n, כמובן שאנחנו יכולים לשנות את זה. אני חושבת שבכל רבע שם, אני רוצה שאת העניינים של מפונקציה פנויה ניתן לך לסגור את זה בשלטון שאתה רוצה לעשות ב-0%

151
00:59:55,460 --> 01:00:25,460
בריקורסיה תמיד מטפלים במקרה בסיס ואז בדרך כלל עושים טיפול בקריאות הריקורסיביות האחרות זה המבנה הכללי. כמובן שבמציאות זה יכול להיות שונה כתעלות במצב שלנו אבל עדיין זאת תבנית הגיונית לעבוד איתה אז הנה מה שאנחנו אומרים, אם n = 0, זאת אומרת שהצלחנו לפרוט הצלחנו להחסיר את n להיות בדיוק 0 אז נחזיר true שזה אפשרי

152
01:00:26,380 --> 01:00:51,560
עכשיו נגיד משהו אחר, אם הגענו למצב שהחסרנו מ-n יותר מדי ועכשיו n הוא קטן מ-0 או לחילופים, הגענו למצב שרוקנו את כל המטבעות ממערך קוינס כי שום מטבע לא טובה לנו לפריטה זאת אומרת כל המטבעות הן גדולות מ-n, זה למה אגב נרוקן מקוינס.

153
01:00:51,560 --> 01:00:56,360
נכון הרי אמרנו שאם המספר גדול מדי אז נתעלם ממנו ונסתכל.

154
01:00:56,360 --> 01:01:26,340
למספר הגדול הבא בתור, כן? אז אם זה קרה גם זה אומר שאין לנו אופציה כאן, נחזיר פולס. אוקיי, אז איך אנחנו נקדם את המקרים שלנו? לפי הרעיונות האלה, קודם כל אם n קטן מהמטבע המקסימלי, אז אנחנו כנראה נרצה לבדוק את התרחיש שלנו שוב עם רשימת קוינס.

155
01:01:26,720 --> 01:01:56,320
בלי המטבע המקסימלי. אופציה אחרת, אם n הוא לפחות המטבע המקסימלי, או שהוא יכול להיות גדול יותר, אז מה שאנחנו נעשה זה להחסיר מ-n את המטבע המקסימלי ואז קרה הרקורסיבית. ואז איך זה נראה? בקוד, שתי אופציות האלה, תראו כאן, נעשה ריטרן, change עם קוינס. זאת אומרת אותה, אותה רשימת.

156
01:01:56,320 --> 01:02:26,320
המטבעות, ואז n, נחסיר ממנו את הקוין הגדול ביותר, זאת אומרת הקוין האחרון רואים כאן? זוכרים סלייסים? אינדקס מינוס 1? זה בעצם האחרון ברשימה, זוכרים? אז נעשה כזה, קריאה ל- change עם coins ו-n פחות המטבע הכי גדולה. זה עצם הניסיון שלנו. לקחת את n, להחסיר ממנו את המטבע הכי גדולה, ככה אנחנו מנסים, כן?

157
01:02:26,320 --> 01:02:55,480
נבנה את הניסויים שלנו בצורה הכי חמדנית שיש, מהגדול לקטן. או אופציה זאת, נחזיר את מה שאופציה זאת תיתן בסופו של דבר, או מה שאופציה שאומרת משהו דווקא אחר, שהמטבע הגדול ביותר הוא גדול מדי, לא רלוונטי לנו, אז תראו מה אנחנו עושים, אנחנו עושים.

158
01:02:55,480 --> 01:03:25,040
קוינס, תראו מה שקורה, קוינס עם הסלייס שאומר, הסלייס של קוינס שהוא מהתחלה אותו דבר, אבל הסוף שלך הוא עד ולא כולל, לא כולל האיבר האחרון. זאת אומרת קוינס פחות האיבר האחרון, והאיבר האחרון אמרנו שזה האיבר הכי גדול, כי אמרנו שזה רשימה ממויינת, אז.

159
01:03:25,860 --> 01:03:54,160
זה בעצם האופציה הזאת. בוא נראה, אמרנו ללא האיבר האחרון, כי r של n, לא סליחה, נראה לי שזה n קטן מהמטבע המקסימלי, נכון? כן, כי אם n קטן מהמטבע המקסימלי, אז אנחנו רוצים להעיף אותו, כי הוא לא רלוונטי, זו דווקא אופציה הזאת, בסדר? אז שתי אופציות.

160
01:03:54,160 --> 01:04:24,160
שהמטבע האחרון גדול מדי, עזוב אותך, או שהמטבע האחרון דווקא נכנס בהן, אז נחסיר אותו מהן, ונמשיך עם אותה רשימת מטבעות. אז אתם רואים? יש לנו כאן, מה שנקרא, שתי קריאות רקורסיביות, והתשובה תהיה האור מביניהן! ואתם מבינים, ברור לכם, שכל קריאה רקורסיבית פה, תקרה לרצף של קריאות רקורסיביות משלה, וכל הקריאות הרקורסיביות, תקרה לטבע הסוגיה שנתחילה לקריא.�

161
01:04:24,160 --> 01:04:47,460
איקרוסיביות האלה בסופו של דבר יעצרו בגלל זה או שהגענו ל-N שווה 0 וסוף סוף אחת מהקטעות האינקרוסיביות תחזיר True ואתם יודעים מה זה אור ור אומר אם רק אחד משני החברים שלי היה true אז אני מחזיר true אז אם מישהו בסוף החזיר true הכל יחזר להיות true בצ'יינג'

162
01:04:47,460 --> 01:05:17,460
מנגד אם כולם היו פולס אז הכל יהיה פה רק או פולס או פולס ותוצאת יהיה פולס. וזה הרעיון שתרגיל ארבע בעצם ברקורסיה. זה טיפה קשוח להבין אם אנחנו לא רגילים לרקורסיה כי היה לנו פה שני מקרה בסיס וגם שני כיוונים אפשריים לפעולה וכל אחד מהם הוא מסלול רקורסי מי של עצמו, אבל עדיין תראו את הקוד.

163
01:05:17,460 --> 01:05:47,460
הוא לא מאוד ארוך, זה מספר עודד של פקודות. רק צריך להבין מה אנחנו חושבים, וזה גם למה. ראיתם שלא הראינו את הפתרון ישר, אלא קודם כתבנו לעצמנו את המחשבות, מה המקרים שלנו, מה נחשב, מה יהיו מקרי הבסיס שלנו. וזה משהו שאני ממליץ לכם מאוד לעשות כמתכנתים, תמיד תכתבו לעצמכם או תחשבו לעצמכם

164
01:05:47,460 --> 01:06:13,940
סתם, תכתבו בטקסט פשוט. אם יש לכם בעיה גדולה מספיק לפתור, תפרטו אותה. תסבירו אותה לעצמכם, תנסו לפרק אותה לתתי בעיות, ואז תוכלו בעצם לפתור אותם, אחת אחרי השנייה, ובסוף תפתרו את הבעיה הגדולה. דרך אגב, יכולנו לפתור את זה בלי רקורסיה. זה אפשרי, לא נגיד שלא.

165
01:06:13,940 --> 01:06:41,920
אני הולך לדלג על הצעת הפתרון הזאת בלי רקורסיה. אם אתם רוצים, אתם מוזמנים לנסות להבין אותה, לבדוק עבור עצמכם אם היא עובדת, או אם היא לא עובדת, אבל מספיק שראינו את הפתרון עם רקורסיה, ובינתיים אנחנו לדעתי נוכל להמשיך. אני רוצה להתרכז פשוט בתרגיל הבא. סבבה, אז תרגיל 5.

166
01:06:41,920 --> 01:07:11,900
אנחנו נגדיר פעולה על קבוצה s ככה. הפעולה היא תחזיר את האיברים הזוגיים ב-s עם גודל הקבוצה s הזוגי, ולהפך, הפעולה תחזיר או תביא את המספרים האיזוגיים של s עם הגודל של s הוא איזוגי. ואומרים לנו תגדירו פונקציה שמקבלת מהכלת סדרה של מספרים שלמים.

167
01:07:11,900 --> 01:07:41,900
שמייצגת את הקבוצה S והיא תדפיס את הפעולה הזאת על S כפי שדיברנו עליה. במילים פשוטות: אם אנחנו נביא קלט שזה 1, 2, 3, 4, 5, זה ידפיס לנו 5, 3, 1. מעניין, מאסוף להתחלה, אוקיי, משהו ברקוסיה. דוגמה אחרת, אם אנחנו נביא בקלט 1, 2, 3, 4 ואז נסיים, זה ידפיס לנו 4, 2.

168
01:07:41,900 --> 01:08:11,900
ואומרים לנו פה לא להשתמש ברשימות. אוקיי! איזה פתרון ריקורסיבי יש לסיפור הזה?  אז כרגיל אנחנו צריכים לשאול את עצמנו, אנחנו רואים את הבעיה, צריכים לשאול שאלות: רגע, איך אנחנו נדע כמה מספרים קלטנו? האם יש איזשהו ריטיון value שאנחנו צריכים להתעסק איתו? יש תנאי יצירה כלשהם? ואז באיזה סדר נעשה הדפסות? אז...

169
01:08:11,900 --> 01:08:41,900
הנה רעיון, אם אנחנו נפתור את זה בצורה קורסיבית, אנחנו נעשה רקור סייה של אנפוט, עד הרגע שבו היה לנו אינפוט שהוא פשוט ריק, ואז עצרנו. זאת אומרת שאם אנחנו נעשה את זה ככה, רק בסוף הכלת שלנו, אנחנו בעצם מהסוף להתחלה נעבוד, כן? נניח ברגע שעצרנו את הכלת, אז שמה אנחנו לא

170
01:08:41,900 --> 01:09:11,900
ה.. ממשיכים בקריאות רקורסיביות, אלא מתחילים לטפל במצב שלנו. אז מה שאנחנו יכולים לעשות, זה.. לקחת איתנו.. אופציה, אנחנו.. לא אופציה, אנחנו יכולים לקחת איתנו סוג של קאונטר. יש.. דרך כלשהי, בפונקציות רקורסיביות, זה.. לשלוח כפרמטר קאונטר, ולהגדיל אותו באחד כל פעם שאנחנו נכנסים עמוק יותר ברקורסייה.

171
01:09:11,900 --> 01:09:41,900
והרעיון הוא שעשינו כלת למספר ואז למספר הבא נגדיל את הקאונטר בקרקרוסיבית ונקלוט קאונט פלוס אחד נקלוט עוד פעם רקורסיה רקורסיה קאון פלוס אחד ורקורסיה קאון פלוס אחד ואז מה הרעיון? אנחנו יכולים קודם כל תמיד אנחנו יכולים לבדוק האם המספר הנוכחי הוא זוגי או אי זוגי ואנחנו גם יכולים לבדוק האם הקאונט שלנו זוגי או אי זוגי. ובגלל שאנחנו

172
01:09:41,900 --> 01:10:10,780
הגענו לסוף הרשימה במצב אקרוסיביה של הקוד שלנו. אנחנו נוכל כבר מהסוף להחליט אם להדפיס את המספר הנוכחי שלנו כן או לא. אז בואו, בואו תראו איך זה יכול לראות בקוד. הקוד פה נראה טיפה יותר אורך, אבל זה לא סוף העולם, בואו תראו. נניח שאנחנו קוראים לו פונקציה, יאללה. אז נגדיר את הפונקציה שלנו עם ההדפסה של ה-O של S הזאת,

173
01:10:10,780 --> 01:10:40,760
אפילו ניתן לה ברירת מחדל של קאונט 0, כי נכנסים לפונקציה בעומק 0, ונגיד נם שווה אינפוט Enter Number, ואז המשתמש מקליד. נניח שהמשתמש הקליד מספר כלשהו, אבל מה אם הוא לא? אז מה זאת אומרת If Not Numb? אם המשתמש ישר לחץ על Enter דבר ראשון,

174
01:10:41,740 --> 01:11:10,720
זאת אומרת שהוא מגיש מחוזת רקע לאינפוט. זאת אומרת שסיימנו להקליד. אז זאת אומרת, If Not Numb סיימנו להקליד, לגמרי. אז מה אנחנו נעשה? אנחנו נעשה פה ריטרן קאונט. זאת אומרת, ברגע שסיימנו להכניס את המספרים, אנחנו יכולים להגיד היי, הנה אורך הקבוצה.

175
01:11:10,720 --> 01:11:40,620
מספר המספרים שקלטנו. אז מה אנחנו נעשה? ריטרן לקאונט הזה. עכשיו אם הבאנו מספר, הבאנו מספר שהוא כן מספר, או לפחות משהו שהוא לא Enter רק, אז ה-If הזה לא יקרה. ועכשיו אנחנו נגיד הגודל של S שווה למה? מה שהקריאה הקרוסיבית של הפונקציה תחזיר לנו עם קאונט פלוס 1. אז הרעיון הוא פה, בפקודות האלה.

176
01:11:40,620 --> 01:11:56,360
אנחנו נמצאים כאן ברצף של קריאות אקרוסיביות שמבודאות שאנחנו קולטים את המספרים אחד אחרי השני, אחד אחרי השני, אחד אחרי השני, בהנחה כמובן שאמנם הוא לא ריק, אז זה כן מספר, עד שסיימנו לקלוט.

177
01:11:56,360 --> 01:12:09,940
ונניח שסיימנו לקלוט, אז בקריאה אקרוסיבית, הכי פנימית שהיא לא הייתה ריק, זאת אומרת, בקריאה אקרוסיבית,

178
01:12:09,940 --> 01:12:39,840
שהכנסנו את המספר האחרון, אז הכי עמוקה שהיא לא ריקה, יש לנו סייז של S שהוא הסייז האמיתי. ועכשיו אנחנו אומרים, נעם שווה אין של נעם, ופה הבדיקה מתבקשת, אנחנו שואלים, האם גודל קבוצה S זוגי? אם כן, האם המספר הנוכחי שלנו זוגי? אם כן,

179
01:12:39,840 --> 01:13:09,840
נדפיס אותם, אחרת השאלה תהיה דווקא הפוך, האם גודל הקבוצה שלנו הוא איזוגי? האם המספר הנוכחי איזוגי? אם שניהם מתקיימים אז נדפיס את המספר הנוכחי. אז סתם דוגמא, בואו ננסה לבדוק את זה עבור רצף הכלת 1, 2, 3, 4, 5, זה רצף איזוגי, וגודל S יהיה 5 גם. מה יקרה? אז עשינו את הקריאות הרקורסיביות הגענו ל...

180
01:13:09,840 --> 01:13:39,840
size s , 5 , unt forever , = 5 אז האייף הראשון לא התקיים, האייף השני כן התקיים, נגיד שהתפסנו את 5 ועכשיו אנחנו עושים return size s , return ה-size s הזה אז אנחנו חוזרים אחורה ותראו size s הזה עכשיו זה עבור ה-counter הקודם זאת אומרת עבור המספר הקודם ש...

181
01:13:39,840 --> 01:14:09,840
קלטנו שנמצא בנאם, הקריאה הקודמת של נאם, אבל החזרנו את אותו סייז s הסופי הזה. ואז הרעיון הוא שיש לנו את הסייז s, עכשיו אנחנו יודעים שאתה מלא דפיס לפי האיפים האלה. אז באמת בואו תראו לדוגמה. אני רוצה להראות לכם מה רצה לדוגמה של הקוד הזה. פייתון q5 enter number 1 enter, 2 enter, 3 enter, 4 enter, עוד פעם enter, והוא הדפיס לי את 4 ואת 2.

182
01:14:09,840 --> 01:14:39,840
32 אני יכול להריס את זה שוב הפעם 1234567 7 531 אז הבנתם בגלל שהחזרנו כל הזמן החזרנו אותו סייז 10 המקסימלי על זה, שימו לב זה היה סייז 10 הסופי גודל של 10 המלא. פשוט החזרנו אותו אחורה בריקורסיה, אחורה בריקורסיה, אחורה בריקורסיה 800 parachusez ואז רק עבדנו פשוט עם ענם

183
01:14:39,840 --> 01:15:09,840
שקלטנו וזהו זה עובד אם אתם מעוניינים אנחנו יכולים לחזור אחור על התרגיל שלנו עם הבעיות הדפים ומטבעות ובשביל אשר אתם יכולים לנסות להבין איך נראה הקוד שפותר את זה בצורה מקבילה בשפת התכנות C בשביל התרגול המוקלט הזה אני לא אעבור על זה עכשיו אני אשאיר את זה לכם, אני רק יכול להגיד לכם

184
01:15:09,840 --> 01:15:15,100
תודה רבה לסבלנות שלכם ונתראה בשבוע הבא.

