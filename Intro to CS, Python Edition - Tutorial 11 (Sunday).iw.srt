1
00:00:00,980 --> 00:00:30,980
אוקיי, טוב, אז בואו שלום כולם, בואו תסיימו להתמקם, אני סוגר עכשיו את הבדיקת הנוכחות, סבבה, אז בואו רק - צפרו לי מהר מאוד, על מה למדתם מהיום איתך רועי? 
מי יודע? 
מבוך? ולאן המבוך הוביל אותנו? גישוש נסוג, גישוש נסוג, להרמית Dead Ends, Dead Ends, טוב, אנחנו נדבר על זה.

2
00:00:30,980 --> 00:01:00,980
לפני כן, מה היה ביום רביעי? ספרו לי על יום רביעי. איך הייתה הרצאת עורך? למה ככה? מה לא שומע? כן, כן, כבר התחלתי. בסדר. כאילו, מתרגם את הנושאים של יציב בינם וגישוש, אז בואו פשוט נתחיל. ויאללה, נצרום על זה. אז באופן כללי לפחות אני מקווה שאתם מבינים את ה...

3
00:01:00,980 --> 00:01:30,980
הרעיון הכללי של כאילו, מה זה רשימה מקושרת, זה אתם עוד זוכרים, נכון? רשימה מקושרת זה סתם כזה אובייקט שיש לו לפחות שני שדות. שדה של נתונים, איזשהו אינטג'ר, איזשהו פלוט, מה שזה לא יהיה, ושדה הבא בתוך זה פשוט מצמיע לאובייקט אחר. ואז ברשימה מקושרת אתם פשוט עוברים על הרשימה הזאת, על ידי זה שאתם עוברים לכל אחד מאובייקטים האלה בנפרד, ואתם אומרים, אוקיי, תראה לי את הנקסט שלך, ואז, תראה לי את הנקסט שלך, נקסט שלך, נק

4
00:01:30,980 --> 00:02:00,980
כושרת אין אגב, יש מישהו פה שלא סגרו על הרעיון הזה באופן כללי? כי זה חשוב, זה הבסיס לכל שאר התרגול. מישהו פה לא סגרו על הרעיון של רשימם כושרת? מישהו? נניח שלא. אוקיי, אז הקטע B בינאי לא מאוד מסובך, תחשבו על רשימה מקושרת, אבל הפעם יש לכם לפחות שני מצביעים, מצביע אחד שנקרא לו Left ומצביע אחד שנקרא לו Right, הטענה שהיא בעצם לא מיידעת

5
00:02:00,980 --> 00:02:30,980
הרעיון, פשוט תחשבו על עץ שהוא הפוך, שהשורש שלו הוא למעלה, וכל העלים שלו הם למטה. הרעיון שיש לכם, נניח, שורש של עץ, ויש לו מצביע לבן שמאלי. בן ימני, ולכל אחד מהבנים יכול להיות מצביע לתת בן שמאלי, לתת בן ימני, וכן הלאה וכן הלאה. זה הרעיון בעץ בינארי. אז בסך הכל, תחשוב על זה כמו רשימה קושרת, אבל שדה של ערך, שדה לבן שמאלי, שדה לבן ימני. אז כן אני קורא לזה בן, ואב, ופה בסיום אני עושה להם מעלה-

6
00:02:30,980 --> 00:02:57,480
זה פשוט המילים שאנחנו בדרך כלל משתמשים בעצמתים של עץ, דרך אגב, יש הרבה מילים לקרוא לעץ צומת של עץ, יש לזה צומת, node, קודקוד, יש עוד מילה באנגלית או בעברית שפספסתי, יש הרבה דרכים לקרוא לזה, הרעיון הוא, הרבה פעמים אנשים יגידו לכם מילים שונות, אבל תמיד תהיה אותה משמעות, אז כשאני אגיד לכם נוד, צומת, קודקוד, זה אותו דבר בעצים.

7
00:03:00,720 --> 00:03:30,720
אפשר לממש את זה בצורה של מילון, כמו שאתם ראיתם מימושן ראשון קושרת אז אפשר עץ במילון, אז פה אני מגדיר מילון של node, מה אני אומר? יש לנו מפתח של value, אוקיי ניתן לו איזשהו value כלשהו, מפתח שנקרא לו left, אז פה נגדיר אותו כרגע כ none, אבל באותה מידה יכולים להגדיר שה-left פה יהיה בכלל איזשהו צומת אחר, ואותו דבר לגבי right, אז בקיצור, צומץ של עץ בינארי זה פשוט כמו node בראשון קושרת אבל...

8
00:03:30,720 --> 00:04:00,720
יש לו מצביע left, מצביע right, לא סתם מצביע next. זה בסך כול ההגדרה של עץ בינארי, אין פה יותר מדי משהו מיוחד. חשוב כמובן להכיר את המונח של שורש או root, הכוונה היא פשוט ראש העץ. זה שממנו והלאה אתם מתחילים, לראש העץ בעצמו, אין לו מישהו שהוא הבן שלו, אז שורש העץ זה פשוט איפה שהעץ מתחיל. ואז פה אתם רואים בכלל דוגמה.

9
00:04:00,720 --> 00:04:30,720
שורש עם שני בנים והבנים האלה הם בעצמם מה שנקרא עלים. אנחנו נקרא לצומת שאין לו בכלל בנים עלה. למה עלה? כי בתכלס אם אתם מסתכלים על העץ, מהשורש של העץ, דרך הענפים שלו עד לעלים שלו, כל עלה הוא קצה מסוים של העץ אם אתם חושבים על זה. אז זה ההיגיון. זה למה אנחנו קוראים לזה עלה. כמובן שלכל עץ יש שורש אחד בלבד אבל זה כבר די באום איליו. אין יותר משהו להגיד על זה

10
00:04:31,240 --> 00:05:01,240
ואנחנו יכולים סתם לתת פה דוגמא לדרך לממש עץ וינארי בעזרת מילון באמת שאין פה יותר מדי משהו להגיד נניח אני הגדרתי פה בהתחלה שני נודס נוד 1 נוד 2 אתם רואים לדעתי להם ויידיו כלשהם הלפט והרייט שלהם שמתי אותם בינן ואז אני הגדרתי את השורש עם וייליומי שלו ובלפט אני פשוט כתבתי את המשתנה נוד 1 וברייט שלו כתבתי את המשתנה נוד 2 זה בערך מסביר את עצמו בכל מקרה, האם יש למישהו שאלות עד כאן?

11
00:05:01,240 --> 00:05:19,720
הגדרות בסיסיות של x בינארי? שאלה? למה עושים בדרך כלל שמה? אה, לא לא לא, מה שאתה רואה פה זה רק אנחנו מגדירים, פה ספציפית הגדרנו את node 1 ו node 2,

12
00:05:19,720 --> 00:05:31,080
כדי שאני אוכל לכתוב ברוט left שווה node 1, right שווה node 2, זאת אומרת, אני הגדרתי משתנה כדי שאני אוכל לשים אותו איפשהו, זה הכל, אין פה, אין פה לוגיקה מיוחדת.

13
00:05:31,080 --> 00:06:01,060
זה הפוך רק כדי שהם יהיו לי קיימים. תחשוב, כאילו, קודם השורה הזאת רצה ואז השורה הזאת רצה ואז השורה הזאת רצה. זה הכל. אם היית שם את זה הפוך, אז כאילו, רוט לא היה יודע מי זה node 1 ו node 2, כי עוד לא הגדרת אותם. זה הכל. סדר כרונולוגי של פעולות. בסדר. בסדר גמור. כן. אך לה. לפחות הקונספט של זה, לא משהו מאוד לא מובן. מדהים. עכשיו, יותר מסתם x בינארי,

14
00:06:01,060 --> 00:06:31,060
באופן כללי, בעולם מדעי המחשב, יש גרסה עוד יותר נוחה למבנה נתונים זה של עץ בינארי, שהיא עץ חיפוש בינארי, או מה שקוראים לו באנגלית Binary Search Tree, והקיצור שלו, שאתם תראו אותו המון בקורס אלגוריתמים, BST. באופן כללי, בקורס אלגוריתמים, אתם תתקלו בקיצורים של אלגוריתמים ושל מבנה נתונים בלי לדפוק רשבון, כאילו כל שנייה אגידו לכם DFS, BFS, BST, ואתם לא תדעו מה...

15
00:06:31,060 --> 00:07:01,060
שנה הבאה. אוקיי, מה זה עץ חיפוש בינארי? זה בסך הכל עץ בינארי, אבל יש תכונה, בעצם שתי תכונות שתמיד נכונות לכל אחד מהצמתים בנפרד, ואני אגיד את זה בצורה ספציפית, בכוונה, אז תשימו לב. לכל צומת בעץ בינארי, לכל צומת בעץ חיפוש בינארי, סליחה, מתקיים לו, שכל הצמתים בתת העץ השמאלי שלו, הם עם value קטן.

16
00:07:01,060 --> 00:07:27,480
שווה לו, וכל הצמתים בתת העץ הימני שלו הם עם value גדול שווה ממנו. שימו לב, אמרתי תת עץ בכוונה, מה זאת אומרת? אם נניח אני מסתכל פה על שורש העץ, בסדר, זה העץ הכי טריוויאלי שבעולם, יש רק שורש ושני עלים, וזהו. אז מן הסתם, שאוקיי, הנה השורש, הבין השמאלי שלו קטן ממנו, והבין הימני שלו גדול ממנו.

17
00:07:28,540 --> 00:07:58,540
מה בתכלס הכוונה, הכוונה היא, עכשיו אני אעלך איתכם טיפה קדימה, אני רוצה להראות לכם דוגמה יותר טובה, הנה, כן, האמת שכן, תסתכלו לרגע על העץ שאתם רואים פה, זהו, תסתכלו לרגע על העץ הבינארי שאתם רואים פה, לפי מה שאמרתי כרגע, עץ חיפוש בינארי, לכל צומת, תת העץ השמאלי שלו מורכב מצמטים קטנים יותר ממנו, ותת העץ הימני שלו מורכב

18
00:07:58,540 --> 00:08:28,540
בצמתים יותר גדולים ממנו, וזה נכון לכל צומת. אז העץ שאתם רואים פה, זה נראה לכם כאחד שמקיים את ההגדרה? תסתכלו, נכון? הנה שלוש עשר, כל מי שבתת עץ ימני גדול מזה, תת עץ שמאלי קטן מזה, אבל גם..אתם שמים לב עוד? כן, יש לך שאלה? אז זהו, פה בדיוק, פה לא יכול להיות תשע, למה? כי זה צומת שנמצא בתת עץ הימנכי. אתה שומע בטתחו שאני עובר איתך אז להגיד לך תשע בטרך יהדם, תלשה תבין המדבר בסדר, שזה לא צומת צמת אל

19
00:08:28,540 --> 00:08:58,540
של השורש הזה, והשורש הזה יש ערך של עשר, אז כל מי שנמצא בתת עץ הזה חייב להיות לו ערך שהוא לפחות עשר, ועכשיו זאת הגדרה שהיא רקורסיבית, אתה מתחיל מהשורש עם הגדרה הזאת, ואתה ממשיך למטה לכל אחד מהבנים, וכל אחד מהבנים גם התכונה הזאת חייבת להתקיים לו, מה זה נותן לנו? זה נותן לנו מה שאגב מוביל אותי, בוא נראה, יש מצב שאני טיפה אוהב

20
00:08:58,540 --> 00:09:09,260
עושה דברים מחוץ לסדר, אבל גם אם כן, זה לא נורא. לא, האמת שזה לא מחוץ לסדר, זה בדיוק בסדר. אז מה זה נותן לנו? כן, שאלה?

21
00:09:09,260 --> 00:09:39,260
עץ בינארי לא משתף שני שני בנים. עץ בינארי, נכון? לא שני בנים בהכרח. לא בהכרח, אבל כאילו, לא, זה כאילו, אל תחליט אותי לדבר על קונספטים של עץ בינארי מלא, כי זה כבר מבנה נתונים. אני בסך הכל מ�רוצה להגיד זאת ההגדרה של עץ בינארי. לכל צומת יש לו את ה Value שלו, ומצביעים לבן שמאל בן ימני, בין אם אתה מילט את המצביעים האלה, זה ההחלטה שלך... יכול להיות שיהיה לי צומץ שהיא תחרות אחת. נכון.

22
00:09:39,260 --> 00:10:09,260
אני רק אומר זאת ההגדרה של המבנה הזה, זה כמו שאני אביא לך עכשיו רשימה מקושרת, אני אביא לך רשימה מקושרת שהיא תגמר מתישהו, אז ה-node האחרון אין לו next, נכון? next הוא לא מזה non, אפשרי.אוקי, אז רגע, אני רוצה שתקשיבו למשהו, זה שנגדרתי לכם עכשיו Binary search tree, אני רוצה להראות לכם את השימוש הראשון לדבר הזה, השימוש הראשון ל-Binary search tree זה בעצם מבנה נתונים של עץ בינארי ששומר דברים ב

23
00:10:09,260 --> 00:10:39,260
בצורה ממויינת, מקטן לגדול, איך אנחנו נראה בתרגיל הראשון של התרגול. הוא מבקש מאיתנו, קבלו Binary SearchTree, ובבקשה תחזירו רשימה ממויינת של כל האיברים בעץ. איך נעשה את זה? על ידי מה שנקרא, Inorder Traversal, בעיקרון, שימו לב, כשאנחנו מדברים על עצים בינאריים, אחד מהדברים שאנחנו גם מדברים עליהם

24
00:10:39,260 --> 00:11:09,260
זה איך אנחנו בעצם עוברים על האיברים שלהם, איך אנחנו סופרים אותם, מאיפה מתחילים, מאיפה מסיימים? אז תחשבו על זה ככה: עבור כל צומת, יש לכם שלושה צמתים לחשוב עליהם: הצומת עצמו, הבין השמאלי שלו והבין הימני שלו. אז השאלה היא, באיזה סדר אתם עוברים עליהם? פשוט, באיזה סדר אתם מסתכלים עליהם? כי יש לכם פה שלוש אפשרויות, אז, מה?

25
00:11:09,260 --> 00:11:13,620
יש לנו כאילו שלוש עשרת אפשרויות,

26
00:11:13,620 --> 00:11:20,780
תחשבו על זה, יש לנו כמה אפשרויות פה. אז בעקרון אותנו יעניינו לפחות ארבע אפשרויות חשובות,

27
00:11:20,780 --> 00:11:32,740
קודם כל, השיטה שהיא תעבוד לנו ב-Binal research tree, היא ריצת in-order, שבה לכל צומת, אנחנו קודם מסתכלים על הצומת השמאלי שלו,

28
00:11:32,740 --> 00:12:02,740
אחר כך על עצמו ואז על הצומת הימני שלו. למה אני עושה את זה בעץ חיפוש בינארי דרך אגב? מה זה נותן לי? זאת אומרת מי הקטן לגדול? עכשיו, שימו לב, כשאני אומר קודם בין שמאלי, אז עצמו ואז בין ימני, זאת הגדרה רקורסיבית. אז תסתכלו על העץ הזה לדוגמה, הנה אני עושה עכשיו זומים כי אני רוצה שתראו גם מאחורה. תסתכלו על העץ הזה. אני מתחיל מהשורש. אני רוצה...

29
00:12:02,740 --> 00:12:32,740
עכשיו לקחתי את העץ הזה ולהוסיף את כל הvalues פה לרשימה כדי שהיא תהיה לי ממויינת. מה אני עושה? אני מתחיל מהרוט, אוקיי, אני רוצה לעשות אינאורדר טריוורס, אז זאת אומרת, דבר ראשון, אני רוצה רקורסיבית להוסיף לרשימה את תת העץ השמאלי, זה לפי הגדרה של BST. קודם, בן שמאל, עצמי, בן ימין, אבל זאת הגדרה רקורסיבית, כלומר כל תת העץ. אז מה אני עושה? אני מתחיל מהשורש, אני עושה קריאה רקורסיבית.

30
00:12:32,740 --> 00:13:02,740
לתת עץ שמאל, עכשיו אני מסתכל על חמש. אבל אני עוד לא מוסיף אותו לרשימה. אני מסתכל על תת עץ שמאל של חמש. מי הראשון שאני אוסיף לרשימה? שתיים. למה? כי שתיים הוא עלה. אין לו בלים. אז כשאני אעשה קריאה קורסיבית לבלים שלו. אין מה לחפש. אז את שתיים אני אוסיף קודם לרשימה. הקורסיה תתקפל. חמש אני אוסיף עכשיו, כי אני אומר. בין שמאל, עצמי, בין ימין. אז הוספתי את שתיים

31
00:13:02,740 --> 00:13:32,740
מתקפל, מוסיף את 5, הולך לתת יצ ימין של 5, 7 הוא עלה, אז מוסיף את 7, ריקורסיה מתקפלת, מתקפלת, עכשיו אני מוסיף את השורש של העץ, 10, ואז אני מתפנה לעבוד על תת יצ הימני, ואיך אני עובד פה? בדיוק אותו דבר כמו שאמרתי לכם שמה, אותו דבר, אני אתחיל מ-15, אבל אני אגיד לא, חכה שנייה, קודם יוסיף את 12, אז את 15 ואז את 17 בסוף אני אקבל רשימה שהיא ממויינת בדיוק זאת אומרת

32
00:13:32,740 --> 00:14:02,640
אפשר להגיד שזה סוג של התאמה מלמעלה מה שנקרא, ריצת inorder על עץ שהיא קודם כל תת עץ שמאל, עצמי, תת עץ ימין, זה מותאם בדיוק לבinary search tree. אז התרגיל הראשון פה שמבקש מאיתנו לכתוב פונקציה שמקבלת binary search tree ומחזירה רשימה ממויינת, זה בעצם במילים אחרות מבקשים מכם תכתבו פונקציה שעושה inorder טרוורסל על bst.

33
00:14:02,640 --> 00:14:32,640
שכזה ,ושומרת את הvalues לרשימה, אז הפונקציה שתממש את זה היא רקורסיבית, אתם כמעט מיידית תעלו על זה, אם אומרים לכם לכתבו את זה ברקורסיה, אז אתם תראו הרי הפונקציה היא מאוד פשוטה, אני מגדיל את הפונקציה הרקורסיבית שלי, היא מקבלת פרמטר אחד, צומת, פה כתוב רוט, אבל ברור לכם שרקורסיבית, כל צומת הוא השורש של תת עץ, של עצמו, אז יש כתוב פה רוט, אל תתבלבלו, זו פונקציה רקורסיבית.

34
00:14:32,640 --> 00:15:02,640
אז אני אומר bST to list עם צומת, קודם כל תנאי הצירה, אם הצומת שקיבלתי היא כבר נאן, איך אני בודק את זה אגב, אני פשוט כותב if not root, מה זה אומר if not? תקשיבו לזה, נאן בין היתר הוא גם פולס מבחינה בוליאנית, כלום, הסוג הזה נאן בפייתון הוא פולס בוליאנית וזה אחלה דרך להגיד שהגענו לסוף רשימה או סוף עץ. אז if not root בכלל בוליאנית זו לא סופה אז אם לא בוליאנית. אז אני אומר if not

35
00:15:02,640 --> 00:15:32,640
נחזיר רשימה ריקה. אנחנו פשוט רוצים להוסיף פה לבנות כאן על רשימה, אנחנו נעשה פה פלוס שווה לרשימה, זה קטע פייטוני, אתם כבר ראיתם את זה. -אתה לא מוצא פה רשימה לקחת מישל מפה? -לא, לא, תסתכל טוב, תסתכלו טוב, זה אחד מהדרכים שעבדנו עם רשימות, אתם גם זוכרים, איך אמרנו שאפשר רשימה שהיא מוטבילית, איך אמרנו שאפשר להגדיל רשימה בלי לשנות את ה-object ID, על ידי אופרטור פלוס שווה? pieces segmentation.shop  פלוס שווה ראינו בכמה דברים שהם

36
00:15:32,640 --> 00:16:02,640
מיוטאבל שהוא שומר על אותו אובייקט, זה פשוט קטע בפייתון אז פה אנחנו בדיוק עושים את זה בדיוק עושים את זה תראו הנה מה שאני עושה פה אם הערוץ שלנו הוא לא כלום אז מה אני אומר? אני עושה את ה-in-order-traverse, אני אומר list שווה מה שהפונקציה האקרוסיבית תחזיר לי כשאני אשלח לה את הבן השמאלי, אחר כך אני עושה list פלוס שווה, זאת אומרת כל מה שקיבלנו מהתת צמול נוסיף לזה, אתם רואים? אני

37
00:16:02,640 --> 00:16:32,640
אני עושה פה פלוס שווה סוגריים רוברות, ככה אנחנו בעצם עושים אקסטנד לרשימה, אומרים כאילו רשימה תוסיף לי לסוף שלך את הרשימה הזאת, מה אני מוסיף? ברשימה פשוט את האיבר שהוא root value, כן? אני פשוט מוסיף את הvalues כבול, אז פה זה האמצע, זה הvalue של עכשיו, ואז אני עושה אפילו return least plus מה שהפונקציה אינקוסיבית תחזיר לי מה... תתאל צימני. כאילו, זה הכל. זה פשוט.

38
00:16:32,640 --> 00:17:02,640
פונקציה אקרוסיבית שתעשה in order, קודם תעשה את שמאל, אחר כך אני ואז תעשה את ימין, יש שאלות? בשורה הזאת, תסתכל: ליסט פלוס שווה ברשימה רוט במקום value, זה בדיוק איפה שזה קורה, עוד שאלות? המקום שהאתה פותח זה? הפונקציה האחת לפני כן, ליסט שווה מה שהפונקציה אקרוסיבית תחזיר כשאני שולח לה את רוט left.

39
00:17:02,640 --> 00:17:32,640
רוט, left. תת Focus שמאל. עוד שאלות? אוקי. יש פה גם דרך פתרון שהיא איטרטיבית, זאת אומרת בלי ריקורסיה, אלא מקבלים את העץ ואנחנו נתחיל לעבוד עליו ואנחנו נעשה את זה בעזרת מחסנית ואני אומר לכם את זה עכשיו, להסביר לכם עכשיו את הפתרון הזה בתרגול זה בזבוז זמן אי טוטאלי, אז skip!

40
00:17:33,400 --> 00:18:03,400
אוקיי, אז איזה עוד דרכים יש לעבור על עץ בינארי? ראינו עכשיו את ריצת האינאורדר, ריצה שהיא פרפקט לעץ חיפוש בינארי, כרגע ראינו למה. יש גם עוד דרכים. אנחנו יכולים לעשות ריצת פרי-אורדר, שמה זה עושה? קודם כל מתחילים מהצומת הנוכחי, ואז תתעץ שמאל, תתעץ ימין,וקיי. יש גם דרך שהיא פוסט-אורדר, שזה דווקא סדר שהוא מתחיל מהסוף ואז

41
00:18:03,400 --> 00:18:18,220
לעצמנו, מה זה אומר? קודם תת עץ שמאל, תת עץ ימין ואז אני. או יש אפילו משהו שאתם ראיתם בהרצאה. אתם ראיתם בהרצאה אני מקווה, ריצה שקוראים לה level

42
00:18:18,220 --> 00:18:48,220
אוורדר, שמה שהיא עושה, זאת ריצה שנעזרת בעובדה שאתם גם יודעים, באיזו רמה בעץ, נמצא כל צומת, זאת אומרת, כמה עמוק הוא, נכון? זאת אומרת, השורש הוא בעומק 0, ואז הבנים שלו בעומק 1, אבל כשאתם כבר מתחילים להתפצל לתתי העצים, אתם עדיין תרצו להדפיס את כל הצמתים שהם באותו עומק מהשורש, אז כאילו,אתם מחשבים פונקציה שהיא מחשבת... אתם בונים פונקציה שהיא מחשבת לכם עומק לכל צומת, ואז הרעיון הוא שאתם תוכלו להדפיס עבור כל צומת

43
00:18:48,220 --> 00:19:18,220
לפי הסדר הזה, אתם ראיתם את זה בהרצאה ביום רביעי, נכון? כרגע אני אוותר, אני לא אומר לכם את הקוד לזה, אבל רק שתדעו, הקוד לזה נמצא כבר במודל, קוד שרץ, אז רק שתדעו. בקיצור, זאת גם אופציה לעבור על עץ. לא שאמרתי פה הרבה דברים, אבל יש שאלות על סוגי הריצות השונות? שאלה מישהו? נניח שלא. או שכן יש, אם כן, אני פשוט לא...

44
00:19:18,220 --> 00:19:48,220
יש, אני חמד, יותר מאוחר כשתגיע לקורס אלגוריתמים אז אחת מהריצות האלה, לא בהכח drinordeור דרך אגב, אחת מהריצות האלה, אני לא אגלה לך מי, וזה לא תירוץ של אני לא זוכר, לגמרי. א אחת מהריצות האלה, היא תשמש אותך לאלגוריתמים שקוראים לו DFS,  שזה Depth First Search, שבאופן כללי בקורס אלגוריתמים אתה תראה הרבה אלגוריתמים לחיפוש ולחישוב מרחקים מינימליים שהם עובדים מעליצים. אבל שוב, נשאיר את

45
00:19:48,220 --> 00:19:49,400
תהיה בראש הזה שנה הבאה.

46
00:19:49,400 --> 00:19:52,300
לעניין איזה גיצה זאת?

47
00:19:52,300 --> 00:19:56,800
לא זאת.

48
00:19:56,800 --> 00:20:14,560
בסדר, כשאתם במצב רוח לזה. אוקיי, לאט-לאט. טכנית גם במי... גם בקורס הזה דרך אגב, אתם נבחנים לא רק על לכתוב פייתון, אתם נבחנים, אני רואה גם, אמרתי לכם בהרצאה. אתם נבחנים פה על אלגוריתמיקה בסיסית, פלוס קצת פייתון. זהו, שאלה.

49
00:20:14,560 --> 00:20:44,540
אני חושב שב-level order אתה עדיין צריך O של N, כי אתה עדיין עובר בעצם על כל, לא, כל הצוותים האלה הם O של N, כאילו, כל ה... היי, אנחנו רצים פה על העץ, הכל פה O של N. אה, האמת שאתה יכול לעשות את הצורה הזאת, אתה יכול לעשות את העבודה הזאת בצורה די חסכונית, אבל בואו נתעכב על זה כרגע. באמת בא לי פעם אחת, תרגול החומר.

50
00:20:44,540 --> 00:21:14,540
החדר, האחרון, כן? בא לי לראות אם נסיים אותו בזמן ה-17. אוקיי. אמונה! בבקשה. אוקיי, תרגיש שני. מה אין, ניקח עכשיו רשימה ממוינת ופשוט ניצור ממנה ב-ST, אז האמת שזה לא כל כך מסובך, בואו נראה אתם צריכים להעלות את זה. תסתכלו על רשימה ממוינת, 2, 5, 7, 10, 12, 15, 17, ואנחנו רוצים לבנות מזה

51
00:21:14,700 --> 00:21:28,820
BST, ממש עץ חיפוש בינארי. תגידו לי, איך אתם הייתם עושים את זה? איך הייתם לוקחים רשימה כזאת והייתם יוצרים פונקציה רקורסיבית שתבנה BST כזה?

52
00:21:28,820 --> 00:21:45,400
מתי אתה מיד כל פעם? -מד כל פעם. -לא עושה לך דרך? -כן. יש. -איך אתה אומר, יש דרך? -אני לא אמרתי שיש רק דרך אחת, אני רק אמרתי תחשבו על דרך ואני מקווה שתעלו על הדרך שהיא הכי אינטואיטיבית בסך הכל.

53
00:21:45,400 --> 00:21:58,640
הדרך הכי אינטואיטיבית לדעתי היא, תקשרו בין הרעיון הזה לבין דברים שראיתם כמו חיפוש בינארי, או קצת הפיצול הזה שעשיתם במרג' סורט. באופן כללי הרעיון הזה של אמצע ואז...

54
00:21:58,640 --> 00:22:00,720
‫זה להסתכל על חצי שמאל, חצי ימין.

55
00:22:02,800 --> 00:22:03,820
‫..15 ו15 ו..פ

56
00:22:05,860 --> 00:22:19,980
‫-12. יש הרבה דרכים, כן? ‫אבל פה ספציפית, מה האינטואיציה שלך אומרת? ‫עץ חיפוש בינארי. ‫עץ חיפוש בינארי. חיפוש בינארי. ‫מיד לבט ריאט. כי אתה מבין?

57
00:22:21,100 --> 00:22:28,600
‫כשאתה אפוי, ‫אתה הולך על דברים הכי מיידיים, כן? אז... ‫אני תמיד אפוי. ‫-בסדר. אז בדיוק בשבילך יש לנו פתרון.

58
00:22:28,600 --> 00:22:58,600
מה נעשה? נכתוב פונקציה, ריקורסיבית, ונגיד הכי פשוט שבעולם, בריקורס כן אנחנו נשלח חתיכות של הרשימה, אז תנאי הצהירה הוא פשוט, אם החתיכת רשימה שקיבלנו רק, נחזיר כלום, כי אין פה מה לעשות, אחרת, נגיד, המידל שלנו הוא פשוט, חצי מאורך הרשימה שקיבלנו, אז נעבוד על זה בצורה של אינדקס, כן, כי יש לנו רשימה, איך ניגשים לרשימה? בעזרת אינדקסים.

59
00:22:58,640 --> 00:23:28,640
אז נגיד middle שווה פשוט חצי מאורך הרשימה, לא מסובך. ועכשיו נגיד הצומת שאנחנו עכשיו בונים, כי אנחנו בונים פה עץ, שימו לב, אנחנו בונים נודס נגיד root שווה נוד של מה? זאת אומרת אנחנו מתחילים אובייקט מסוג נוד. עוד מעט אגב אני אראה לכם איך נגדיר את הנודס אבל תניחו שאנחנו עובדים בצורה שהיא דומה לדאטה-קלאס. אתם זוכרים שאנחנו הגדרנו נודס וזה, נוד נקודה left, נוד נקודה right? אז פה אנחנו קצת לא מתעסקים בצורת מילון, עוד מעט אני אראה לכם

60
00:23:28,640 --> 00:23:37,580
אז אנחנו נגיד, root = node של מה הרשימה שקיבלנו באינדקס מדל שעכשיו בנינו.

61
00:23:37,580 --> 00:23:56,540
אוקיי, אנחנו בונים עכשיו את הצומת שלנו כרגע, אבל עכשיו תראו מה אנחנו עושים. אנחנו בונים פה את חיפוש בינארי, אז אנחנו יודעים שבאמצע, הצומת הנוכחי הוא תמיד האמצע של הרשימה, שתת הרשימה יותר נכון, ואז נבנה פשוט root. информונט וroot. role, מה נעשה?

62
00:23:56,540 --> 00:24:26,540
הרוט נקודה אני אומר את זה בכוונה, שתת העץ שנקבל מקריאה רקורסיבית של הפונקציה, שנשלח לה סלייס של הרשימה שנגמר במידל לא כולל. ורוט נקודה שתת העץ שנקבל מקריאה רקורסיבית כשנשלח את הרשימה בסלייס שמתחיל במידל פלוס אחד. עכשיו, אולי מישהו פה לא ברור ושואל, מה זה אומר לך רק להאיר

63
00:24:26,540 --> 00:24:56,540
‫אל תא אצלירי רועט תמיים בתמיהו. ‫ושבלב אהב, רחוץ מקצוע. ‫אני חושב שזה פלואוף בהיריון חבר. ‫איך אתה מכינה שהפלוטין שלפלוטין? ‫תראה איך הוא Again תחזיר זמן חופ שהפלוטין אצלייך הוא חלק מהחקית של הטבע. ‫על התחלטות שלך בטבע אצלייך

64
00:24:56,540 --> 00:25:26,540
למה? כי הרבה פעמים העבודה שלהם תהיה רקורסיבית. אז כשאני אומר צומת ואז בן שמאל, אבל מה זאת אומרת בן שמאל? צומת ואז כל מה שבן שמאל מחזיר, אבל בן שמאל הוא בעצמו הרוט של תת העץ של עצמו, אז מבחינתי מספיק לעשות את השוויון הזה, במה שהפונקציה רקורסיבית מחזיר לי, כי יותר למטה ברקורסיה, היא תבנה תתי עצים מרבה.

65
00:25:26,540 --> 00:25:55,780
ממויינים כבר, ופה זה ממש לפי הגדרת הרקורסיה, הרקורסיה מבחינתכם היא רק אתם כזה אומרים, אני מטפל בבעיה שלי כאן ועכשיו, הרקורסיה אומרת לי שממני והלאה, הפתרון כבר קיים, אז זה למה זה בנוי ככה, למה אנחנו רק מגדירים את הנוד המקומי, ואומרים נוד שמאל = מה שהרקורסיה מחזירה, נוד ימין = מה שהרקורסיה מחזירה.

66
00:25:55,780 --> 00:26:25,780
זה ברור לכם או שרק בלבלתי אתכם עכשיו? מה אתם אומרים? תסתכלו על זה. מה אתם חושבים? נניח קיבלתם את הרשימה. נניח הרשימה המקורית? 25710, 121517. נניח מי המידל שאנחנו נמצא פה? 10. זה גם אי-זוגי, כן? 10. אוקי, אז נניח שאנחנו נכנסים לקריאה ראשונה עם סורט-אד-ליסט

67
00:26:25,780 --> 00:26:55,780
המלא הוא לא r while אז נמשיך נגיד middle שווה האינדקס של 10, בסדר, ואז אני אומר root שווה node שאני בונה עם הvalue 10 עד כאן ברור ואז אני אומר root נקודה left שווה מה שהפונקציה הרקורסיבית הזאת תחזיר עם החצי שמשמאל ל-10 שזה 257 אז כאילו אני מטחיל להיות ברור לכם איך אנחנו נבנה רקורסיבית את העתק העץ הזה 257 וזה בדיוק מה שהפונקציה ה... מה הפונקציה

68
00:26:55,780 --> 00:27:16,940
שהפונקציה הזאת תחזיר לי הסלייס הזה של סורטד ליסט שנגמר במידל לא כולל, זה אנחנו נשלח לפונקציה רק את 2,5,7, וכל מה שהפונקציה הזאת תחזיר לי, תת עץ שלם, זה מה שאני עכשיו אשייך פה לרוט נקודה לכת שלי, בקריאה הכי ראשונה, הבנתם?

69
00:27:16,940 --> 00:27:46,940
גם אם העורך הרשימה זוגי להקלט את זה? אם אורך הרשימה זוגי בסך הכל זה אומר שהעץ שלך לא יהיה מלא לחלוטין, אלא אחד מהבנים, כאילו יהיה לו רק, כאילו אחד מהצמתים יהיה לו רק בן אחד, לא שניים, זה הכל. אבל הרעיון הוא שהפונקציה הזאת, היא תבנה לכם עץ חיפוש בינארי שהוא די מאוזן האמת, אם תסתכלו על זה, כי הוא די מאוזן ודי מלא, כי בגלל הסימטרייה פה

70
00:27:46,940 --> 00:28:16,940
הוא ימלא לכם הכל בצורה שתשעף, שיהיה לכם צומת ושני בנים. ומתי שהוא תגיעו למצב של אלים? לא שומע? אה, זה נטו עניין של סלייס, תחשוב על זה. אתה הגדרת עכשיו צומת, 10, אתה רואה? אז אתה רוצה שתת העץ הימני שלך יהיה עם כל העברים שמתחילים החל ממדל פלוס אחד עד הסוף.

71
00:28:16,940 --> 00:28:46,300
כי זה מידל, אתה לא רוצה שיהיה לך, אתה יודע, כפילות של עיוורים, נכון? אתה זוכר איך סלייסים עובדים? אז זה שמימין לנקודתיים זה לא כולל מידל עצמו, אותו דבר כמו בריינג', אתה זוכר? אם אני עכשיו כותב לך ריינג' 5, הריינג' הזה הוא בעצם בין 0 ל-4 כולל, זה תמיד בלי האינדקס האחרון עצמו. אז אם אתה כולל מידל ארבע, מה יקרה?

72
00:28:46,300 --> 00:29:16,100
איפה פה? אם הייתי פה כותב מידל פלוס אחד? לא, אם הייתי כותב פה למטה מידל ולא פלוס אחד, זאת אומרת, בתא תצא אם אני, גם היה לי את 10. ואני לא רוצה את זה. זה מה שנקרא בשפה מקצועית נו בואנו. אוקיי. בסדר? אז נניח שהבנתם את הרעיון. בקיצור, רשימה ממויינת, BST. BST רשימה מויינת, לחלוטין אפשר להחליף ביניהם.

73
00:29:16,420 --> 00:29:26,480
אוקיי, בסדר, אז בואו נעשה משהו טיפה יותר מתקדם, בואו נראה שלא פספסתי כמה שאלות, בואו נראה, לא, יפה, טוב.

74
00:29:28,220 --> 00:29:37,080
מרחק בין שני צמתים בעץ, אפילו עץ חיפוש בינארי, בכלל לא עושים לכם את החיים קלים, אוקיי.

75
00:29:38,980 --> 00:29:46,020
תסתכלו על עץ כזה, תסתכלו על איזשהו זוג של צמתים, איך אתם הייתם מחשבים?

76
00:29:46,020 --> 00:30:03,400
את המרחק המינימלי בין שני צמתים כאלה, איך הייתם מחשבים את זה? זאת אומרת, מה זה אומר מרחק מינימלי? אני אומר לכם, תיתנו לי שני צמתים, כמו לא יודע, 5 ו-12, איך אתם, מה השלבים שאתם צריכים לעשות כדי לחשב את המרחק ביניהם?

77
00:30:03,400 --> 00:30:16,000
להחליף לעלות מהשלבים שלהם. זה לא שלהם, זה של חברה שלך. זאת אומרת, אתם צריכים למצוא מ-LCA שלהם, ה-Lowest or Least Common Ancestor.

78
00:30:16,000 --> 00:30:45,980
זאת אומרת, הצומת הכי נמוך בעץ, שהוא אב משותף להם. ואם אתה הולך יותר גבוה, אז אתה רק, כאילו, אתה צריך לטייל עוד. לא, אני מדבר איתך, המסלול הקצר ביותר בין שניהם. אין בעיה. אז מה הרעיון? לא, זה בסדר. אז מה הרעיון? אנחנו נרצה פשוט את האנצטור הכי נמוך, זאת אומרת, הצומת שהוא הכי קרוב אליהם, הכי למטה בעץ שהוא אב קדמון.

79
00:30:45,980 --> 00:31:15,880
ושניהם, ואז אנחנו נחזיר את סכום המרחקים לשניהם מאותו-LCA. פשוט נניח פה, 5 ו-12, מי הצומת הכי נמוך שמשותף, שהוא אב לשניהם? השורש, אין מה לעשות. אז מה אני אעשה? אני קודם כל אמצא את זה ש-10 הוא ה-LCA של שניהם, ואז אני פשוט אחזיר סכום של המרחק בין 10 ל-5, והמרחק בין 10 ל-12. למה זה הפתרון? מ-5.

80
00:31:15,880 --> 00:31:45,880
ל-LCA ואז מ-LCA ל-12. בקיצור, לא משהו בגידיל. מובן הרעיון? אוקיי, אז האמת שזה בערך מה שאנחנו נעשה. אז אם אני עכשיו ארצה להגדיר פונקציית המרחק הזאת, אני מקבל את השורש, אני מקבל שניבייליוס ואני יוצא מרחק ביניהם. אז דבר ראשון, אני מחפש בין שניהם LCA. שזה פשוט, שוב, מה שאמרנו, ה-Lowest Common Lancestor, הצומת הכי נמוך בעץ, שהוא

81
00:31:45,880 --> 00:32:15,880
אב משותף לשניהם, ואחרי זה פשוט מחזיר את סכום המרחקים בין LCA לשני הצמתים, וזהו. אז אם אתם שואלים, סבבה, איך אנחנו מוצאים את ה-LCA, בהרצאה שביום רביעי, אני זוכר שאתם גם ראיתם פונקציה ל-LCA, אבל שמה אתם ראיתם פונקציה שהיא קצת יותר מסובכת, כי זה היה על עץ שהוא לא BST, נכון? הנה, אני עכשיו מהר מאוד אסתכל על זה, כי דווקא כן חשמ... מעניין אותי להסתכל על ההבדלים. אז הנה, בואו לחצי שנייה, אני אפתר.

82
00:32:15,880 --> 00:32:45,400
את המצגת של ההרצאה ההיא, רק שנייה, הנה, לקשר 11, שים מהמסך מלא, או, אוקיי, כן, אני רק עושה לרגע קרוס אובר קטן, את תשימו לב אליי, LCA, איפה אתה? LCA, LCA, איפה אתה? הנה אתה, כן. בעץ בינארי רגיל, שהוא לא עץ חיפוש בינארי, כדי למצוא LCA, אגב, אתם הצלחתם להבין?

83
00:32:45,400 --> 00:33:15,400
בהרצאה איך ה-LCA עובד, לעץ רגיל, לא עץ חיפוש בינארי? יש מצב שלא, אני אתן לכם את התמצית, אני אתן לכם את התמצית. הפונקציה הריקורסיבית, שראיתם בהרצאה, היא עמדה על כזה דבר, קודם כל, זה ריקורסייה, אז דבר ראשון אנחנו בודקים, אם אנחנו כבר יצאנו מעץ, אז נחזיר כלום, אחרת, מה אנחנו נעשה? שימו לב, הריקורסיה עבדה ככה, הבדיקה ראשונה

84
00:33:15,440 --> 00:33:45,440
אומרת, אם אנחנו נצאים כרגע על צומת שהוא אחד משני האנשים שאנחנו מחפשים להם LCA, נחזיר את אותו צומת. כלומר, הנה מצאנו אחד מהם. אחד מאותם שני ווליו ואז מה הרעיון? LCA הוא הראשון. בעצם הצומת הראשון הכי למטה בעץ, בקריאות הריקרוסיביות, שיחזיר לכם את שני הצמתים של ול 1 ובל 2. למה? כי תראו את הקריאה הריקרוסיבית. יש פה קריאה אקרוסיבית אפילו גרועה גרועה

85
00:33:45,440 --> 00:33:54,760
יביץ' אומרת,LCA שמאל שווה מה שפונקציית LCA תחזיר כשנשלח לה את תת עץ שמאל ושני ה-values.

86
00:33:54,760 --> 00:34:14,780
- LCA ימין, מה שהפונקציית LCA תחזיר, היא נשלח לה את תת עץ ימין ושני ה-values. מה הכוונה? - הכוונה היא שככל שאתם תרדו למטה, ברקורסיה, ככל שאתם תרדו למטה בעץ, מתישהו הפקודה הזאת, Return Tree, תתקבל. מה הפקודה הזאת אומרת?

87
00:34:14,780 --> 00:34:44,540
מצאתי צומת שיש לו אחד משני ה-values האלה. למה זה חשוב? אחרי שה-return הזה יקרה, מתישהו, באיזושהי קריאה רקורסיבית, למטה בעץ, לא למעלה, קריאה רקורסיבית עמוקה יחסית, אנחנו נקבל ערך גם ב-LCA left וגם ב-LCA right. אתם יודעים מה זה אומר? הצומת הראשון שבו זה יקרה, שיש לכם גם מ-LCA left וגם מ-LCA right שני צמתים,

88
00:34:45,220 --> 00:35:13,640
הוא ה-LCA. זאת אומרת, הצומת הראשון ברקורסיה, שיש לו Match לצומת כלשהו שהוא value 1, ויש לו match כלשהו לצומת כלשהו שהוא value 2, הצומת הראשון שיחזיר LCA left true וגם LCA right true, כלומר שיש משהו, הוא ה-LCA. ואז תראו מה אנחנו עושים, Return את ה-LCA, ואז כל זה יקפל את הרקורסיות.

89
00:35:14,640 --> 00:35:44,640
עם ה-LCA כבר, וה-LCA הוא מה שיוחזר עד לשורש של העץ. יכול להיות שלא כחצת עכשיו עשיתי את זה מהר ואני לא יודע אם כל כך הספקתם לקלוט את זה בכל כך מהירות, אז בואו אני אנסה להסביר לכם. נניח, תסתכלו על השורש של העץ. והאמת השורש של העץ אני לא יודע אם אני רואה בטח, לא, אני אבחר משהו אחר. אני רק רוצה לעשות לכם סימולציה ל-LCA ואני חושב שזה דווקא כן חשוב, שאתם תבינו את הדבר

90
00:35:44,640 --> 00:36:14,640
LCA בעץ כללי, אפילו לא BST, אני יודע זה מההרצאה, זה לא מהתרגול, אבל זה בסדר, זה מחסר, בוא נגיד את זה ככה. אוקיי, נניח שאני רוצה לחשב LCA של 1 ו-7. בוא תעשה זום פלילס, תודה רבה. חכו שנייה, חכו שנייה, זה כן חשוב, תנסו להיות איטי. אני רוצה לחשב LCA של 1 ו-7, מה יקרה? אני מתחיל משמונה, אוקיי, אין לי פה מה לחפש, אז אני מחפש תת עץ שמאל - שלוש.

91
00:36:14,640 --> 00:36:44,640
עכשיו, אני נמצא בשלוש. בשלוש אני שולח חיפוש לתת עץ שמאל שלו. אני נוחת על אחד. מה יקרה לי שמה? אני אגיד לכם מה יקרה. if tree נקודה value נמצא בval 1 ועל 2, return 3. זאת אומרת פה אני אקבל ריטרן. מה זה אומר? פה אני אקבל ריטרן, שלוש יש לו עכשיו LCA left. אתם עוקבים? זה חשוב. שלוש קיבל LCA left.

92
00:36:44,640 --> 00:37:14,640
הוא קיבל match מה שנקרא. Match Found. יופי. מה שגם קרה, שלוש שלח חיפוש לתת עץ ימין. אז שלוש שלח חיפוש לשש. אוקיי. שש לא מתאים, אז שש שולח חיפוש לתת עץ שמאל שלו ולתת עץ ימין. שימו לב, שש. תקשיבו, שש מצא התאמה בתת עץ ימין בשבע. זאת אומרת, בע אחד מקריאות הקרוסיביות שלנו, שבע הוא גם

93
00:37:14,640 --> 00:37:28,640
החזיר לנו ‫תרו, לא תרו, החזיר לנו כאן את הצומת שלו, למה? ‫איף טרי נקודה value, שזה שבע, נמצא בתוך אחד פסיק שבע, ‫הוא יחזיר את שבע. לממי הוא יחזיר? אני רוצה שתשימו לב.

94
00:37:29,460 --> 00:37:42,500
‫שש מצא מאצ' ל-LCA רייט, ‫אז תהיו איתי. ‫שלוש, מצא התאמה ל-LCA ל�פט. ‫שש מצא התאמה ל-LCA רייט, עכשיו תראו מה קורה.

95
00:37:43,400 --> 00:38:13,400
עכשיו ניכנס לשש, יש לו התאמה ל-LCA רייט, שש הוא יותר עמוק ברקורסיה, אז מה יקרה איתו? הוא יתקפל קודם, איפה הוא יתקפל? תראו, רגע, שש מצא התאמה ל-LCA רייט, אבל לא LCA ל ,אז הריטרן הזה לא יקרה, אבל תראו מה הוא כן מחזיר, הוא עושה ריטרן, או LCA ל,או LCA ר, לא הייתה לו התאמה ל-LCA ל,אבל הוא כן יחזיר את ה-LCA רייט, מה זה אומר? מה זה אומר?

96
00:38:13,400 --> 00:38:43,400
עכשיו, זה הקטע המעניין. 6 מחזיר את זה שהוא מצא את 7 לכאן, חזרה לשלוש. ואתם יודעים מה זה אומר? עכשיו שאנחנו בשלוש, שלוש יש לו LCA left. והוא בדיוק עכשיו קיבל LCA right שהתקפל דרך 6. ואתם יודעים מה זה אומר? עכשיו תסתכלו על הפונקציה שוב, רגע. שוב, 3 מצא את LCA left...

97
00:38:43,400 --> 00:38:53,920
עכשיו הקריאה הרקורסיבית שלו, LCA ראייט התקפלה גם והוא מצא את שבע אז יש לנו LCA left ויש לנו LCA ראייט שהם שני צמטים ועכשיו מה הif הזה אומר?

98
00:38:53,920 --> 00:39:13,360
אם LCA left וLCA ראייט הם צומת שהוא לא none, return את עצמו, אז מי אנחנו מחזירים? יפ, קדימה, אך באגר, בדיוק, שלוש, שלוש מחזיר את עצמו ל  רות, וגמרנו שלוש הוא LCA. זאת אומרת, עכשיו עשיתי פה...

99
00:39:13,360 --> 00:39:22,520
ציון לרגע להרצאה, רק כדי להסביר לכם איך LCA עובד בצורה כללית, שלדעתי זה כן חשוב שתראו את זה. האם אגב יש שאלות על הנושא הזה?

100
00:39:23,580 --> 00:39:53,480
של LCA איך זה עובד, רקוסיבית למצוא אותו בעץ כללי? שאלה. אה אין בעיות. רגע, תסתכל. דבר ראשון, אתה בודק אם הגעת לסוף העץ, אז אתה עושה כלום. אם לא, אתה אולי נפלת על אחד מהערכים שאתה מחפש, להם LCA, אז תחזיר שמצאת אותו, אחד משני הערכים. אוקיי, אחרי זה, אם אתה לא, אז אולי...

101
00:39:53,480 --> 00:40:23,480
כבר אחד מהבנים שלך מצא התאמה, אז פה אתה רואה, lca left ו-lca right שווה מה שהפונקציה תחזיר ‫רקורסיבית כשאתה שולח את החיפוש לבנים. כן. ואחרי זה, אתה שואל, ‫היי, האם אני ה-lca? אין, כן, יופי, ‫אני מחזיר את עצמי. אם אני לא ה-lca, אז ‫לפחות באחד מטאתי העצים שלי מצאתי התאמה, ‫אז אני אחזיר את מימיהם שכן יש בו התאמה. ככה

102
00:40:23,480 --> 00:40:27,340
‫אז מה  יכול אומר לזה? ‫- return LCK left או LCK right.

103
00:40:27,340 --> 00:40:31,640
‫אז תסתכל, אתה יודע מה קורה, ‫ה-end לא יתקיים.

104
00:40:32,360 --> 00:40:36,340
‫אז זה לא ששניהם יתקיימו לך, ‫אבל אחד כן יתקיים.

105
00:40:36,340 --> 00:40:40,520
‫ושים לב, אתה מריץ את הדברים האלה, ‫זה חשוב לאגב שתבינו, אגב,

106
00:40:40,520 --> 00:40:47,220
‫זה פריימר מעולה לבקטרקינג, ‫כי בבקטרקינג, מי שלא מבין רכורסיה, ‫מתעסק.

107
00:40:47,220 --> 00:40:50,740
‫אבל מי שכן מבין רכורסיה, ‫זה כמעט בא בטבעי.

108
00:40:50,740 --> 00:40:53,860
‫אתה יודע מתי אתה בכלל ‫מריץ את השאלות האלה?

109
00:40:54,660 --> 00:41:03,480
‫רק כשחזרת מהרכורסיה, מהפקודות האלה. ‫אבל הפקודות האלה, כשאתה חזרת מהן,

110
00:41:03,480 --> 00:41:09,740
‫או שמצאת התאמה כבר, ‫או שאין לך התאמה. זה הרעיון.

111
00:41:09,740 --> 00:41:16,320
‫כשאתה חוזר מכזה דבר, אז גמרנו. ‫יש לך לפחות LCA left או LCA right אחד כלשהו.

112
00:41:16,320 --> 00:41:27,940
‫ואז, או שיש לך את שניהם, מצאת LCA, ‫או שלא, לפחות מצאת אחד מהם, ואתה אומר, אוקיי, ‫אני הולך חזרה למעלה, מצאת לפחות אחד מהם, תהנה. זהו.

113
00:41:27,940 --> 00:41:33,360
‫אז למה אתה מופיע לו על אחד מהם? ‫-כי שניהם, לא עבד לך, לא מצאת ה-LCA, ‫אבל מצאת כן אחד מהם.

114
00:41:33,360 --> 00:41:46,240
‫אז אתה אומר להם, ‫אני רץ עם מין שקטן. ‫-לא, רגע, אבל, שוב, שנייה, רגע, תחשוב על זה. ‫נניח שאתה עכשיו בצל שלוש, LCA left מצאת אותו.

115
00:41:46,240 --> 00:42:16,240
זה הבן השמאלי שלו, אבל שלוש אתה, אבל זה בסדר, כן? LCA left שווה מה שהבן השמאלי שלו הכזיר, זאת פקודה שחזרה לחדי מהר בשביל שלוש, נכון? הנה שלוש, LCA left, אבל שלוש גם מחפש LCA right שלו, אז שלוש שולח לשש, אבל שש לא מתאים, אז שש מחפש את בן שמאל, בן ימין, שש לא מצא כלום בבן שמאל, שש מצא בבן ימין, בן ימין שנכנסנו ברקורסיה לשבע,

116
00:42:16,240 --> 00:42:46,240
אז פה קיבלנו ריטרן, ריטרן ה"טעמה" לשבע, אז מה קורה? לשש יש עכשיו LCA רייט, כן? אין לו LCA ל רעט, אז אתה יודע איפה הוא soullNERSE RITERN? בפקודה הבאה, האחרונה. לא שומע? זאת אומרת שש מחזיר את שבע, וזה עולה לשלוש.

117
00:42:46,240 --> 00:43:16,240
זאת אומרת, רקורסיה מתקפלת, זאת אומרת, תת קריאה, קריאה יותר עמוקה, עשתה ריטרן. אז 7 עשה ריטרן ל-6, 6 עושה ריטרן ל-3, ואתם יודעים איפה זה קרה? בדיוק פה, 6 עשה ריטרן ל-3 אחרי שהוא סיים את הפקודה הזאת. יש LCL-Left ויש LCL-Right. ועכשיו, 3 פה, יש לו את שניהם, הוא מעשה ריטרן פה לעצמו, ב-end הזה, כי יש לו שני בנים.

118
00:43:16,240 --> 00:43:37,140
יש לו שני LCA, הוא מצא, הוא מחזיר את עצמו, ואתם יודעים למה זה טוב? שלוש מחזיר את עצמו ל-Root, שמונה. ואתם יודעים מה קורה כשאנחנו... Root זו הקריאה הראשונה של הפונקציה, כשהיא תעשה return, סיימנו להריץ את הפונקציה, מצאנו ל-LCA, זהו, יש LCA. שאלה.

119
00:43:37,140 --> 00:44:07,080
לא, להחזיר ל-Root, אצל Root הפונקציה הקריאה הראשונה שלה תיסגר. כשאתה מחפש LCA בעץ, אתה שולח כפרמטר את השורש של העץ. אני אומר, שלוש מחזיר את עצמו, אתה יודע איפה? תחשוב על הקריאה הראשונה שלך לפונקציית LCA, הראשונה, לפני שפתחת את הקריאות, שנייה, אתה יודע איפה אתה תהיה? אתה תהיה ב-LCA שורש.

120
00:44:07,080 --> 00:44:29,000
ועל אחד ועל שתיים ובדיוק עכשיו LCA Left מצא התאמה, Return LCA Left. זה לא משנה, הרעיון הוא כל עוד שה-End שלך לא עבד לך. ודרך אגב, כמובן שהשורש עצמו יכול להיות LCA, אתם יודעים למה?

121
00:44:29,000 --> 00:44:59,000
כי לפני בדיקת האור, יש לכם את הבדיקת אינד. אתם יכולים להתקפל אל שורש העץ עם LCA 
לפ וLCA  
רייט, ואז פשוט אסור ריטרן את השורש. זה גם עובד. שאלה, או שאולי ענינו עכשיו. מאחורה יותר, שאלה הייתה לך? אז זהו, פשוט מאוד, הריטרן אחד לפני הסוף, זה מה קורה אם אתה ה-LCA . הריטרן האחד לפני זה53

122
00:44:59,000 --> 00:45:02,200
‫אז אם יש לך גם LCA Lפט, ‫גם LCA רייט, אתה LCA.

123
00:45:02,200 --> 00:45:13,200
‫אם לא, אז... ‫או שאתה פשוט מחזיר את מה שקיבלת ‫מאחד משני הבנים שלך, שהייתה לך או התאמה, ‫או LCA עצמו.

124
00:45:13,200 --> 00:45:23,300
‫כל היופי באלגוריתם הזה, ‫שזה לא... שאין פה את ההבדל, ‫אין פה את ההבדל פה, ‫אתם כבר לא מבדילים ‫אם אתם מחזירים LCA, ‫או רק התאמה אחת מתוך שניהם.

125
00:45:23,300 --> 00:45:53,300
בסופו של דבר בקריאות הראשוכסיביות זה די מתמזג להיות תנאי אמת וזהו. לא שומע? עכשיו, עכשיו עשינו סימולציה לדוגמה, עכשיו. כן, כן, כן. שוב. כשאמרתי לך, קח את 1 ו-7, 1 ו-7, נכון? אתה מתחיל מערוץ 8, 8 קורה ל-LCA left. 3,3 קורה ל-LCA  אתה מתחיל מ-8, 3 קורה ל-LCA קגם הל conflicts בלבב הזה, והאוקטיב בגידול הזה, ו Cryptose יצא לעובדה של your name, בלשון מעולם. וצריך להכניס את זה, ולשחוק את זה, ותחזור מהצורה לדבר שמקורים באמת שלך

126
00:45:53,300 --> 00:46:23,280
מצא התאמה, שלוש קורא ל- LCA ראייט, שש, שש לא מתאים, שש קורא ל-LCA לפט, כלום, שש קורא ל-LCA ראייט, מצא התאמה, אז זה חוזר לשש, שש מסיים את הרקורסיה שלו, יש לו רק התאמה אחת מתוך שתיים, אז הוא עושה ריטרן לשבע, שש מחזיר, הקריאה של שלוש ל- LCA ראייט שהביא אותו לשש, מחזירה לו שבע.

127
00:46:23,280 --> 00:46:50,840
עכשיו לשלוש, יש LCA left ו-LCA right. שלוש מחזיר את עצמו לשמונה. שמונה סיים את LCA left, הוא קיבל את שלוש, ושמונה סיים את LCA right, הוא קיבל כלום. סליחה על הסימן המעליב, הוא קיבל כלום, אבל זהו, שמונה קיבל את LCA left, אז הוא מחזיר את LCA left.

128
00:46:50,840 --> 00:47:16,580
מה שמעביר את שבע לשש בצורה האחרונה. מה שמעביר את שבע לשש, אתה צודק לחלוטין, זה הפקודה הזאת. ריתר, LCA Right. כי LCA Left היה כלום. כן, כן, כן. And, זה רק אם אתם מצאתם שתי התאמות, ואז אתם אומרים מצאתם LCA, אני LCA. לא, אז אתם מחזירים או את Left או את Right.

129
00:47:16,580 --> 00:47:44,760
וזה הפואנטה, זה נמצא בסוף הרקורסיה, כי אתם מניחים רקורסיבית, שמצאתם לפחות אחד מהם, בעזרת שתי הפקודות האלה. ופה, אם שניהם לא מתקיימים לך, אתה יודע מה אתה תעשה פה ריטר? False. כי כלום או כלום שווה False. זאת אומרת, אין LCA לשני צמתים שלא קיימים בעץ. בבקשה.

130
00:47:44,760 --> 00:48:03,600
לא, אם אתה מחפש LCA, שולח לו את הרוט, בשני values, אבל, שאחד מהvalues לא נמצא בעץ, אתה תקבל, בסופו של דבר, הכל יחזיר לך ריטרן פולס, או נא.

131
00:48:03,640 --> 00:48:33,640
לא יכול בלפני -בלפני? -אם היה לנו  ב...דם... זה היה 7, נכון? אז היה, אז היתה מחיאה 8? לא יכול להיות להחזיר... רגע. אם יש לכם עץ, שבו יש יותר מערך, יש יותר מהופעה אחת של אותו ערך, אז הקוד שאתם ראיתם כאן לא ידע להבדיל, הוא יחזיר לכם את ההתאמה הראשונה שהוא ימצא. איזו? רמז? התאמה שתתעדף.... תעדפת, תעדפת, תתקשר את האמצע הזה, מאז המא slash dry?21

132
00:48:33,640 --> 00:49:03,540
את שמאל, אתם יודעים למה? כי זאת הקריאה הריקורסיבית הראשונה מתוך שתיים, זה הכל, לפעמים מי שנכנס קודם בתור פשוט מקבל את זה ראשון. אתה אומר מה היה קורה אם היה לך שבע נניח פה או פה, נכון? אז זה בדיוק הקסם, כשאתה נכנס לקריאה הראשונה של הרוט, LCA left, ואם LCA left... אה, אתה יודע משהו?

133
00:49:03,540 --> 00:49:33,540
‫לא, רגע, רגע, ‫יש משהו במה שאתה אומר, אתה יודע למה? ‫יש משהו במה שאתה אומר, ‫אני עכשיו יורד לסוף דעתך, ‫כי תחשבו, LCA Left, נניח שהוא יחזיר את... ‫נניח שLCA Left, רגע, רגע, ‫זה משהו, קטע, – LCA Left נניח יחזיר את 3? ‫אם אמרנו 1 ו 7? ‫אבל מה אם 8 ימצא 7 כלשהוא נניח פה, ‫אז ה-7 הזה יעלה, יעלה, יעלה ל-LCA Right? ‫אז תיאורטית זה יחזיר את 8.

134
00:49:33,540 --> 00:50:03,540
בתור האב המשותף הקדמון לא לשב, לא הפנימי אלא דווקא הכי חיצוני אז אם כבר אפשר או אפשר להגיד שה-LCA הזה, LCA שמחזיר LCA שהוא משותף ל-values האלה שהם הכי רחוקים אחד מהשני...תחשוב, מה זה מרחק? פשוט יותר... אתה יודע... כאלה...

135
00:50:03,540 --> 00:50:33,540
עץ המשפחה יותר מרוחקים, המדרגה החמישית, שישית. זה מה שאני אומר, אם יש שבע פעמיים, אז זה... זה למה, אם יהיה... תחשוב, אם היה לך פה שבע, אם היה לך כאן שבע, אתה יודע מה היה קורה? זה... עדיין היה מחזיר את עצמו בתור LCA ל-1 והשבע הזה, אבל שמונה, היה לו LCA-Right עכשיו, אתה יודע? השבע שהיה אולי נמצא לך פה. זאת אומרת, היה לך LCA-Right ו-LCA-Rght

136
00:50:33,540 --> 00:50:53,480
אז 8 יחזיר את עצמו בתור LCA. אוקיי, עכשיו אני באמת חייב לחזור חזרה לתרגול, כי סליחה, אני איכשהו מהתרגול הסברתי לכם משהו בהרצאה, בואו לא נעשה את זה שוב, אבל בסדר, זה לא היה תרגול שלי, אם לא הייתי עושה כזה דבר, בואו נודה באמת.

137
00:50:54,480 --> 00:51:03,400
כל הסיפור, כל התיירייד הארוך הזה, רק כדי להגיד לכם שלחפש LCA בעץ חיפוש בינארי זה הרבה יותר קל, כי ב-LCA אנחנו פשוט.

138
00:51:03,400 --> 00:51:33,400
כבר יודעים, את הערכים של הצמתים שלנו מבחינת עצמנו, או תתי בנים, אז כשאני מחפש LCA בעץ חיפוש בינארי, אני פשוט אומר, אם המקסימום שבין שני הערכים שאני מחפש להם LCA, הוא קטן מהערך של ,עצמי, אז ה-LCA הוא פשוט יימצא לי בתת עץ שמאל, אותו דבר, אם הערך, המינימלי מבין שניהם, הוא יותר

139
00:51:33,400 --> 00:52:03,400
גדול מערך של עצמי, ה-LCI חייב להיות בתת עץ ימין שלי וכששני ה-IFים האלה לא מתקיימים אז זאת אומרת, מצאנו צומת שהוא נמצא בין המינימום למקסימום ששני ה-values ובגלל שזה BST אני erזיר אותו. בגלל, שזה BST. זה כל ההבדל, בגלל שזה עץ חיפוש בינארי, רק חשוב לי לבדוק בתנאים את התחום ערכים. בין המינימום למקסימום

140
00:52:03,400 --> 00:52:33,400
ואז אני מחזיר פשוט את השורש שבין המינימום למקסימום.אה,  עם שני הifים האלה לא החזירו לי משהו. זאת אומרת עם שני הifים האלה, אה..אתה יודע מה אולי חסר פה תנאי יצירה של, לא יודע, if not root אז return כלום. לנהיה. אבל הרעיון פה הוא שאתה רק משווה פה מבחינת מינימום ומקסימום של ערכים בשני הvalues. כי אתה יודע שהlca שלהם.

141
00:52:33,400 --> 00:52:58,360
אז יהיה לך משמאל וימין. טוב, אתם יודעים משהו, אני חושב שאני מדכא בזה יותר מדי ויש דברים יותר חשובים. רגע רק שנייה, יכול להיות שאני מדמיין אבל כן, זה יעבוד, זה יעבוד אם ננחך אותו. Not anymore. אוקיי, בסדר.

142
00:52:58,720 --> 00:53:43,320
בקיצור, בקיצור, התרגיל הזה היה בסך הכל למצוא מרחק בין שני צמתים בעץ חיפוש בינארי, אז חיפשנו, מצאנו את ה-LCI בין שניהם, אם אתם לא השתכנעתם מה-LCI BST פה, תביאו את פונקציית ה-LCI מההרצאה שעכשיו הסברתי רבע שעה, היא תעבוד, וחוץ מזה, פונקציית מציאת, מציאת מרחק מהשורש, רקורסיבית, פשוטה מאוד. מה אתם אומרים? תנועה יצירה. אם עכשיו נפלנו על, אם עכשיו יצאנו מהעץ, נחזיר 0, או מינוס 1 אפשר להשכיר.

143
00:52:58,720 --> 00:53:28,720
בקיצור, בקיצור, התרגיל הזה היה בסך הכל למצוא מרחק בין שני צמתים בעץ חיפוש בינארי, אז חיפש, מצאנו את ה-LCA בין שניהם, אם אתם לא השתכנעתם מה-LCA BST פה, תביאו את פונקציית ה-LCA מההרצאה שעכשיו הסברתי רבע שעה, היא תעבוד וחוץ מזה פונקציית מציאת, מציאת מרחק מהשורש, רקורסיבית, פשוטה מאוד. מה אתם אומרים? תנאי עצירה. אם עכשיו נפלנו, אם עכשיו יצאנו מהעץ, נחזיר 0 או מינוס 1 אפילו.

144
00:53:28,720 --> 00:53:58,720
אז נגיד שמינוס 1 כאילו לך אחורה, זה לא חלק מהמסלול, לך אחורה. כי פה find debt אנחנו מחזירים אינטגר. ופה אנחנו אומרים, בסך הכל, if value קטן מ root value או if value גדול מ root value, זה בסך כל הערך שמנחליט ללך שמאל או ימינה, זה הכל. ואז מה אנחנו עושים? return 1 פלוס שאר הדרך. ואלס פה, זה מה קורה אם הגענו בדיוק לצומת שאנחנו מחפשים מהשורש, אז נחזיר 0 כאילו...

145
00:53:58,720 --> 00:54:24,300
אין עוד, אין עוד דרך להמשיך. For what is your point height? זה פיין דפט, זה לא

146
00:54:24,300 --> 00:54:28,260
SA, זה למצוא מרחק מהשורש. זה בסך הכל אומר, זה פיין דפט, כאילו, אתה פשוט מחשב את המרחק מהשורש אל הצומת שאתה מחפש. אם נחתת בצומת כבר, אין לך עוד דרך לחשב, ואם עוד לא נחתת על הצומת שאתה מחשב, אתה מוסיף אחד פלוס למה שאתה תמצא.

147
00:54:28,260 --> 00:54:58,260
ואז הרעיון שהקריאות הרקורסיביות האלה יחזירו 1 פלוס מה שמתחתיי. אבל מה שמתחתיי יחזיר 1 פלוס מה שמתחתיי. בקיצור. כן, בדיוק. בקיצור, זה ה-Find Depth. זה ה-LCAPST, באמת מטעמי זמן. ואני אומר לכם, בואו לא נתעכב על זה יותר בבקשה. אתם זורמים איתי להמשיך הלאה? יופי, מעולה. אוקיי, האם יש לי זמן לזה? רגע חכו שניה. לא, לא, זו שאלה שכן נעבור עליה. רגע שנייה. אז בקצ'ק ראיתי להעין רק כדי להגיד לך מה יהיה עובד בא�ינ

148
00:54:58,260 --> 00:55:28,260
יש לנו חצישה. בסדר, בסדר. יש מה? אוקיי, בואו תהיו איתי. יש לכם פונקציה, והתפקיד שלכם הוא להגיד לי מה הפונקציה הזאת עושה. רמז, זו שאלה מהסוג הזה שאוהבים לשאול במבחנים. אז, אתם ראיתם בבאך אני אמצא את השאלות שהיו לכם, לפחות לקראת ההתחלה, נכון? שאלות של הנה קוד, מה הוא עושה, מה הוא מדפיס, מה הוא אמור לעשות, שאלות כאלה, נכון? זה שאלות שאוהבים לשאול במבחנים.

149
00:55:28,260 --> 00:55:58,260
אז בואו נתעכב על השאלה הזאת לרגע. נתונה לכם פונקציה, הפונקציה הזאת מן הסתם עובדת על עץ בינארי, לפי מה שכתוב בה. אני שואל אתכם, מה הפונקציה הזאת בעצם עושה? מה היא בודקת? בואו נפענח את הפונקציה וננסה להבין, קודם כל, פונקציה מקבלת צומת של עץ בינארי, תנאי הצירה שלה, אם הצומת שהיא קיבלה הוא כלום, אז היא תחזיר תרור. כלומר,

150
00:55:58,260 --> 00:56:28,260
כוונה ראשונה, אני באמת צריך שתתרכזו, עברנו לשאלה אחרת, הנה פונקציה צריך להבין מה היא עושה, התנאי יצירה שלה אומר ש אם כלום, אז ריטרן true, כלומר זאת פונקציה שבאופן רת היא נכונה, אז זאת אומרת, אם היא לא רתה אז יכול להיות משהו שישבור את הנכונות שלה, בסדר, נסתכל על התנאים הבאים בתור, אם בין שמאל הוא כלום, ובין ימין הוא כלום, זאת אומרת אם זה

151
00:56:28,260 --> 00:56:36,580
‫אלה, אז נחזיר את הבדיקה ‫של האם הערך של הצומת שלנו הוא 0, כן או לא?

152
00:56:38,340 --> 00:56:41,580
‫לאט-לאט, רגע, רגע, ‫זו אינטואיציה לא רעה, נתחיל...

153
00:56:42,180 --> 00:56:52,460
‫בואו נמשיך לבנות עליה. ‫העיף הזה שואל, אם אני עכשיו על אלה, ‫אני אחזיר True רק אם הvalue שלי הוא 0, ‫אחרת אני אחזיר False.

154
00:56:52,740 --> 00:56:57,380
‫אוקיי, אז אלים חייבים להיות עם ערך 0. ‫נשמור את התובנה הזאת, נמשיך הלאה.

155
00:56:57,380 --> 00:57:25,300
‫אם הבן השמאלי שלי כלום, ‫זאת אומרת, יש לי רק בן ימין, ‫אז אני מחזיר אם ה-value שלי ‫שווה ה-value של הבן הימני שלי ועוד אחד, ‫וגם אם הפונקציה הזאת מתקיימת ‫על הבן הימני שלי. ‫זאת אומרת, הרעיון הוא, בין היתר, ‫הערך של צומת שיש לו רק בן ימני, ‫חייב להיות 1 פלוס הערך של הבן הימני. ‫שאלה?

156
00:57:25,300 --> 00:57:51,300
תשובה? סימן שאלה? הקוד הזה בודק מה? הערך של כל צומת? כן. אני חוזר על מה שאתה אומר רק כדי שמישהו בזום ישמעו אותך פשוט. זה לא...היא לא שומעים אותך פשוט.

157
00:57:51,400 --> 00:58:21,400
הבנתי, הבנתי, יש לך סטייג' פרייט, בסדר. טוב, בקיצור, תנאי שבודק אם יש לי רק בן ימין, אז הערך שלי חייב להיות 1 פלוס הבן ימין, אם יש לי רק בן שמאל, אז הערך שלי חייב להיות 1 פלוס הערך של בן שמאל, ואם יש לי שני בנים, אז הערך שלי חייב להיות 1 פלוס

158
00:58:21,400 --> 00:58:24,640
המינימום שבין הערך של בן שמאל לבן ימין.

159
00:58:28,540 --> 00:58:58,540
אז לא בדיוק, מה אתה מציע בעצם? מה שאלה? איפה יכול להיות value עצמו? value עצמו? ל root מ-facet. אה, אני יודע מה זה עושה. זה לא עושה לך? זה עושה לך? לא, לא. אצלך, מעליך. ובמה בשבילך איזה? אצלך, מאות. רוט מוות ורואה רעד. לא, כשאסתום עושה root נקודה right נקודה value

160
00:58:58,540 --> 00:59:28,540
זאת אומרת, root נקודה ראי, זאת אומרת, הבין הימני שלי, הvalue שלו. נכון, זאת אומרת, אתה ריטרן עם הערך ש... יכול לצפור פה את זה, אבל זה להאט סינירי. לא, לא, אני אומר לך, שוואת value, שדה value, זה אינטגרים. לא, זה שדה של אינטגר. value אינטגר. לכל צומת יש לו value משלו, אינטגר. לא, אבל זה להאט סינירי, אני מניח, אמור להיות חלק יותר, חקיר לך מזה. לא, לא, עשינו פה, זה לא...

161
00:59:28,540 --> 00:59:35,220
רגע, פה אנחנו משווים values על עץ בינארי שאנחנו לא יודעים אפילו מה הערכים שלו.

162
00:59:36,080 --> 00:59:58,260
אבל אתה יודע שעץ בינארי תמיד מבט על הצבעים שלך, נכון? לא עץ חיפוש בינארי. אה, עץ בינארי? אני אתם מעניין. אף אחד לא אמר לך שזה BST. כן, מה אתם מציעים? בודקים? צוקר לגדול. בודקים? אלמניה,  טוב, קרן, וגדול. אוקיי.

163
00:59:58,260 --> 01:00:01,520
אוקיי, זה לא בודק אם העץ הוא בי-אס-טי, אז?

164
01:00:01,520 --> 01:00:31,520
‫זה בודק אם זה סכום, ‫זה בודק אם זה בי-אס-טי, ‫אבל לא באמת בסדר דבר. זה סכום. ‫- אוקיי, לא, זה לא בודק אם זה בי-אס-טי - ‫זה לא בודק אם זה בי-אס-טי, ‫אני חשוב לי שאתם דווקא תסתכלו ‫על התנאים הראשונים, תסתכלו. ‫כל עלה, הגדרות פה מתחילות ‫מעלים ועולות למעלה. ‫עלים הערכים שלהם חייבים להיות אפס. ‫צומת, שאחד מהבנים שלו הוא עלה, ‫הערך שלו חייב להיות אחד.

165
01:00:31,520 --> 01:01:01,520
האמת, שיש לו שני אלים כבנים, הערך שלו עדיין יהיה חייב להיות שווה אחד,לא בדיוק, אתה מתקרב, זהו. מי שאמר עומק, זהו, מי שאמר עומק, היה הכי קרוב לתשובה, אתם קצת מאבדים ריכוז, אני צריך שתתעשמו לב, אתם קצת מאבדים ריכוז בכיתה, חברה, אני באמת צריך, כאילו, אם לא הייתם פה, יכולתם פשוט לראות ההקלטה בבית, אם אתם כבר פה, אתם פה בשביל זה.

166
01:01:01,520 --> 01:01:12,440
אוקיי, בקיצור, הפונקציה הזאת בודקת אם הערך של כל צומת הוא מינימום המרחק לעלה כלשהו ממנו והלאה.

167
01:01:13,320 --> 01:01:26,660
עוד פעם, הפונקציה הזאת בודקת אם העץ מקיים שכל צומת שלו הערך שלה הוא מינימום המרחק לעלה הכי קרוב שלה, למה?

168
01:01:26,660 --> 01:01:42,760
קודם כל, כל עלה, המרחק של עלה לעלה הוא 0, אם לצומת אין בנים, הvalue שלו חייב להיות 0, עלה הוא 0, אם צומת יש לו נניח לא יודעים...

169
01:01:42,760 --> 01:01:54,660
אבל אם לצומת יש רק בן אחד, שזה עושה לנו את החיים פשוטים, אם לצומת יש רק בן אחד, אז הערך שלו חייב להיות: 1 פלוס מה שיש בבן שלו.

170
01:01:54,660 --> 01:02:10,140
זאת אומרת, פלוס אחד למרחק, נכון? אבל אם יש לנו שני בנים, אז אנחנו מוסיפים 1 פלוס.1 פלוס למה? 1 פלוס למינימום שבין שני הבנים שלנו.

171
01:02:10,140 --> 01:02:40,140
כי שוב, הפונקציה הזאת מחשבת את מינימום המרחק לאלה, אז נניח עץ כזה, יחזיר טרור, למה? כל עלה הוא 0, כל אבא של עלים, הערך שלו זה באמת המינימום של הבנים שלו פלוס 1, זאת אומרת, תסתכלו, נניח הצומת הזה, יש לו שני בנים כאלים, אז באמת הערך שלו זה 1,0.

172
01:02:40,140 --> 01:03:08,760
פלוס המינימום של הערכים שלהם, 1 פלוס מינימום של 0,0, אחד, אז תסתכלו על שורש העץ כולו, הערך שלו זה 1 פלוס המינימום של בין ימין ובין שמאל, מרחק מינימלי של צומת לעלה, מרחק מינימלי של צומת לעלה וזה תנאי שהוא נכון לכל הצמתים פה, זה מה שהפונקציה הזאת באה לבדוק.

173
01:03:08,760 --> 01:03:38,640
יכולת ללפוס את העץ מול בראש, זה לא רציחה את זה איפה. בסדר, לא, לא, בסדר, אבל זה העניין, תקשיב, זה העניין, הדוגמה שאני אמרא לך פה, זה מה שנקרא It's a courtesy, אתה לא היית רואה אותה אפילו במבחן, במבחן, לא, בסדר, לא, לא, כן, כן, כן, אבל היי, נו, אתה מכיר את הביטוי של קשה באימונים, anyway, רק שנייה, אני רואה שמישהו הזיז את המצלמה, אני לא אענקוף בשמות, רק שנייה.

174
01:03:38,640 --> 01:04:08,640
אני אמרתי אני לא מוקב בשמות, לא מוקב בשמות, הכל בסדר, אוקיי, בסדר, בקיצור, אה, כן, סקרול דאו, אם אני אקח את האפס הימני שם, בסדר, ואני אשנה אותו לשתיים, אז עכשיו, הלמעלה, צריך להיות שתיים כי זה יהיה אחד ועוד אחד בשבילי פה יש הרבה, אם אתה תשנה את זה לשתיים, אז הפונקציה סבירה. ממש רגעת לגרום להכיר את זה לו בדרך ממשלה אתה מביא לך לעשות בדרך לגרום טוב הרבה בגרופה שלך או לגרום טוב גרום יסופו, אתה יכול להכיר את זה במטרה ואתה צריך להתחיל למגן בגפ הז

175
01:04:08,640 --> 01:04:38,640
הוא תחזיר לך פולקס אבל אתה יודע למה? כי הלערך שלו חייב להיות 0, אני מזכיר לך? לא אבל אם אתה תתקן כאילו את זה ל-2 ואז חווי שנים לו עוד שני עורך מלון... אוקיי אתה יודע משהו בסדר, אוקיי נניח שאתה משנה את זה ל-2, יש לו בין אחד ימני 1, בין אחד ימני 0. אוקי ואז העליון, עכשיו הוא היה חייב להיות 2. לא הוא היה יכול היה להיות 1. לא לא נכון...

176
01:04:38,640 --> 01:05:08,640
לא, לא, אחד פלוס המינימום, היי, היי, היי, היי, שוב. רגע, רגע, רגע, בוא תדע, בואו תהיו איתי, רגע. וואו, זה פעם ראשונה בחיים שלי שאני רוצה טוש. למישהו יש טוש? טוש, מצאתי טוש, תודה. קלטו קטע. מאג'ק. נניח יש פה שתיים. אחד. אפס. תקין.

177
01:05:09,960 --> 01:05:39,960
לא תקין, חה, שנייה, אוקיי, תקין, למה זה מרחק מינימלי להיעלב? זה שאמר לאני, זה שם אחד! רגע, לא, שנייה, כן, זה תקין, למה? תסתכלו, תסתכלו, מרחק המינימלי של השורש מעלה, הנה, אלים פה, לא, לא עלה הזה, עלה הזה, עוד פעם, תסתכל על הפונקציה, אם יש לי שני בנים, אחד פלוס המינימום!

178
01:05:39,960 --> 01:05:43,480
‫מרחק של... מהשני בנים שלי, מינימום.

179
01:05:45,960 --> 01:05:51,760
‫מה, מרחק מאסטרון 3? ‫רגע, שימו לב, הפונקציה הזאת,

180
01:05:51,880 --> 01:05:59,280
‫היא בונה את המרחקים מהעלים ומעלה. ‫היא בודקת את המרחק מהעלים ומעלה, אז...

181
01:06:00,960 --> 01:06:05,320
‫מי, מי אתה שואל? ‫מי אתה שואל? תגיד לי.

182
01:06:05,320 --> 01:06:19,360
‫היא יצאת דרכה, ‫היא נחתת את זה, ושם. ‫לא, רגע. השורש? ‫תסתכל. השורש, מה המרחק המינימלי ‫מהשורש להעלה? ‫-2.

183
01:06:21,960 --> 01:06:29,160
‫יופי. ‫מה המרחק המינימלי של הצומת הזה מעלה? ‫-2.

184
01:06:32,160 --> 01:06:41,360
‫אז תסתכל על צומת השורש. ‫אני לא אכתוב פה 3, כי המינימום מרחק ‫הוא דווקא לאחד משני העלים האלה, לא העלה הזה.

185
01:06:46,120 --> 01:07:01,560
‫נכון מאוד. 1 פלוס מינימום. ‫למה 1 פלוס? כי בכל זאת, הבנים שלו הם מרחק, ‫אז אתה 1 פלוס הבנים שלך, ‫מבחינת חישוב מרחק, לעלה. ‫זו הגדרה אקורסיבית.

186
01:07:02,560 --> 01:07:32,560
טוב, נניח שהבנתם, אין לי מ... לא,  אתה צודק, אתה צודק, עכשיו בגלל שאין לי מחק, I am just gonna make it disappear, maggic trick, מדהים, יופי, ראינו את זה, טוב, בזמן שנשאר בתרגול, אני אעבור איתכם על backtracking שזה קשוח, קשוח, קשוח, קשוח, אז לצערי, גם הפעם אנחנו נפג לעפסקה, עםיכם סליחה, אבל...

187
01:07:32,560 --> 01:08:02,560
תאמינו לי, שאתם רוצים את זה. כי מי שלא ידע בק-טראקינג, ואם יהיה במועד א' בק-טראקינג, אז... נתראה במועד ב' מה שנקרא. ו... (צחוק ידעתי יחד מכול), -טלוי! -אני ללך עכשיו? -תשמע, לא, זה טלוי, זה תלוי בו מבנה מבחן. אני רק יודע שכשאני נתקלתי במבחן בבק-טראקינג פעם, ולא יודעתי לפתור בק-טראקינג, נפגשתי עם מועד ב', לא משנה. כן, מה שנקרא באמת, לא האמת, כן. לא נמצא פתרון במועד א',

188
01:08:02,560 --> 01:08:16,560
בק׳טצ'רק, נעבור לאיטרציה של לולאה למועד ב. אוקיי, בסדר, אוקיי, אז בואו תתרכזו לרגע. עכשיו אני רוצה להסביר לכם בק׳טצ'רקינג בצורה שתהיה הכי מובנת לכם.

189
01:08:16,560 --> 01:08:45,760
בעיקרון, בק לוואןט ג ז, למצוא פתרון או אפילו לספור פתרונות בעזרת רקורסיה, אבל הרקורסיה שלכם, היא יכולה להיות רקורסיה עם תנאי והיא יכולה להיות רקורסיה בתוך לולאה, בגלל פגרים. בגלל פגרים זה לא נחתה רחוק משפחה שמסתכל עלינו, בכלל לא אלא האפשר להזיג

190
01:08:16,560 --> 01:08:46,560
לכם, בעיקרון Back-Tracking זה למצוא פתרון או אפילו לספור פתרונות בעזרת רקורסיה, אבל הרקורסיה שלכם, היא יכולה להיות רקורסיה עם תנאי, ויכול להיות רקורסיה בתוך לולאה, יותר מזה, זה יכול להיות רקורסיה, ואז אתם יוצאים, חזרתם מהרקורסיה, ואתם משנים את דעתכם, וחוזרים ל רקורסיה עם פרמטר אחר, זהו, זה Back-Tracking.

191
01:08:46,560 --> 01:09:16,560
סיימנו, אפשר לסגור את התרגול, ועכשיו ברצינות, בואו ננסה להבין את זה, מצדכנים אתכם מדוגמה שהיא ספק אקטריריית וספק לא, אבל אנחנו נבנה את הרמת קושי מכלום, לקצת יותר מסובך, נתחיל ממששהוש יחסית פשוט, תסתכלו על עץ בינארי, עץ בינארי, אנחנו רוצים לכתוב פונקציה, שמה היא תעשה? בהיא ניתן סכום כלשהו, סכום, מספר.

192
01:09:16,560 --> 01:09:46,560
שהוא נקרא לו סכום כלשהו, אנחנו צריכים לספור את מקסימום, לא מקסימום סליחה, אנחנו צריכים לספור כמה מסלולים יש מהשורש לעלה כלשהו, ככה שסכום הvalue בדרך הזאת שווה בדיוק לסאם שקיבלנו. אז דוגמה, עבור העץ הזה, עבור סאם שווה 14. אז אמורים שטכנית זה עץ פשוט כי יש לכם רק 4 מסלולים לעלה.

193
01:09:46,560 --> 01:10:02,540
אפשריים ממילא, פה פה פה, פה ככה ככה, זה זה זה וזה זה זה, אז כמה מסלול, כמה מסלולים יש לי שהסכום שלהם הוא ארבעה רעשרה, תראו למה הקוונה, חמש, בעוד שלוש, שמונה, בעוד שש, ארבעה עשרה.fahrana.com Priest.

194
01:10:07,560 --> 01:10:37,560
זאת אומרת, התנאי יצירה, מן הסתם, אם אני הגעתי לנאן, אז זה לא מסלול, נכון? אתה מציאミー אפס. אה, לא, בדיוק, התנאי יצירה שלי כן, אז זהו. אם אתה מגיע לערב, אתה מחזיר... זהו, בדיוק, בדיוק. אז רגע, אז רגע, אז כן, מה אתה מציע? לפחות בלילה, זהו. כולם למועץ

195
01:10:37,560 --> 01:11:07,560
קודם כל, אם אני אעשה את זה בצורה רקורסיבית, אז אחד מהאינטואיציות שאני רצוץ שתיקחו אתכם, בעיקר בבקטרקינג, זה לשלוח כפרמטר ברקורסייה, אני אשלוח לה פרמטר רקורסייה, משהו כמו סאם, פחות רות נקודה value, זאת אומרת, בואו נבדוק את שאר המסלול, פחות המחיר של מי שאני אמצא בו כרגע, הגיוני, נכון? אני נמצא עכשיו בשורש, בואו נחפש בבין שמאל, בן ימין, אבל נחסיר מהם, מהסאם הזה, את הvalue של השורש

196
01:11:07,560 --> 01:11:19,020
נכון? בדיוק, באיזשהו שלב מעורבת פה בדיקה של השוואה עם אפס, נכון? חייב להיות כי אנחנו לוקחים סכום, מחזירים ממנו את הvalues של צמתים על הדרך.

197
01:11:19,020 --> 01:11:37,440
זו הדרך הכי פשוטה למצור מסלול תקין. אוקיי? מספר מסלולים, זאת אומרת, כל פעם שסיימת מסלול תקין, בדיוק, אתה מחזיר, כן, אתה יכול לעשות ריטרן לאחד או טרו, כי אתה יודע שטרו זה כמו אחד.

198
01:11:37,440 --> 01:12:06,540
ואתה עושה פשוט קאונט פלוס שווה מה שאתה תקבל מזה. אוקיי, אז בואו נבדוק הצעת פתרון. אז יאללה, נבדוק הצעת פתרון, נכתוב את זה בצורה של nodes עם נקודה left, נקודה right, נקודה value, הכי טבעי. אז הנה הצעת פתרון לפתור את זה, בואו נסתכל על זה. פונקציה רקורסיבית, אוקיי, אז ככה, פונקציה רקורסיבית שיש לה שני פרמטרים, צומת והסכום שנשאר לנו.

199
01:12:07,380 --> 01:12:37,040
אז מה אני אומר, אם הצומת הוא נאן, כלומר אם יצאתי מהעץ אז כאילו סיימתי מסלול פוטנציאלי ומה אני אומר, אני עושה ריטרן אם הסם שקיבלתי כפרמטר הוא 0, כלומר אם סיימתי מסלול והסכום שלי שנשארתי איתו הוא 0 אז זה כאילו טוב ואני עושה ריטרן true, true זה בוליאן שאתם יכולים לתרגם אותו לאחד מבחינת אינטג'ר שזה אחלה בשביל לסכום קאונטר.

200
01:12:37,040 --> 01:13:07,040
כל פעם שקיבלתם true, counter גדל ב-1, קל מאוד. אוקיי, משהו אחר, אני יכול להגיד אם הסכום שנשאר לי הוא קטן מ 0, זאת אומרת, חישבתי מסלול יקר מדי, אני אצטרך  return 0, זה לא מסלול, לא לספירה, בסדר? ומה אני יכול להגיד? אם אני לא הגעתי לסוף 22, אז מה אני אעשה? אני אחשב את ה... counter...

201
01:13:07,040 --> 01:13:11,200
‫אני חושב כאילו כמה מסלולים ‫יש לי משמאל ולמטה,

202
01:13:11,280 --> 01:13:16,800
‫אז אני עושה פה left-pass counter שווה ‫קריאה רקורסיבית ל-בן שמאל,

203
01:13:16,920 --> 01:13:21,280
‫עם הסם שקיבלתי פחות הvalue של עצמי.

204
01:13:21,480 --> 01:13:25,640
‫ככה אני בעצם מחסיר כל פעם ‫בקריאה רקורסיבית, מחפש בדרך למטה.

205
01:13:25,880 --> 01:13:34,680
‫אני עושה left-pass counter, right-pass counter, ‫ובסוף אני פשוט מחזיר את סכום המסלולים, ‫גם מתת את שמאל, גם את ימין.

206
01:13:35,040 --> 01:13:42,980
אז אני אשאל אתכם, מה אתם אומרים? זה יעבוד? אם אתם אומרים לא, תנסו לחשוב על אפשרויות ללמה זה לא יעבוד.

207
01:13:46,980 --> 01:14:04,940
אם הסם גדול מאפס, האם הוא אחד מאופן. אוקיי, בוא נניח, אוקיי, בוא נעשה הנחה מקלה. הנחה מקלה שלא תשבור, נניח הנחה מקלה, שסכום כל, כאילו המסלולים שלך עד להעליך.

208
01:14:04,940 --> 01:14:26,440
הם או בגודל של הסם הזה, לא, האמת זה לא, זה בסדר גמור, אתה יודע למה, אתה יודע למה? תסתכל עליו, תסתכל על זה, תסתכל על זה. ריטרן עם סם שווה שווה 0, אם אתה הגעת עכשיו, יצאת מעץ, והסם שלך הוא לא 0, הוא גדול מ-0, זה בסדר גמור, זה פשוט יהיה false, לא לספירה.

209
01:14:26,440 --> 01:14:56,140
אם סם קטן מ-0, זה כאילו, אתה יודע משהו, לא, מה שזה אומר, אם סם קטן מ-0, זה אומר, כאילו, אתה ירדת לנקודה מסוימת בעץ, זה דרך לתמוך בעץ, שבו, יש לך מסלול לעלה, שהוא ארוך יותר ממה שאתה יכול לשלם כבר, ואז אתה אומר, enough, I give up, זה סתם, זה דרך לעצור אותך מללכת סתם למקומות שאתה לא רוצה. אוקיי, אבל אני שואל אתכם, חוץ.

210
01:14:56,140 --> 01:15:26,140
‫חוץ מזה... ‫-אבל יכול להיות שהערכים למטה יהיו כאילו שליליים נגיד. ‫-נניח שהם כולם חיוביים. ‫בסדר גמור, לא, אני איתך, ‫צריך לחשוב על דברים האלה. ‫בסדר, נניח שזו לא בעיה שליליים, ‫ונניח שלא בעיה להגיע לסוף העץ. ‫אני שואל אתכם שאלה אחרת, ‫האם הספירה כאן תהיה תקינה? ‫בבקשה, שמישהו ינסה לחשוב. ‫האם הספירה כאן תהיה תקינה? ‫בואו נעשה סימולציה, בסדר?

211
01:15:26,140 --> 01:15:56,140
יש לי באמת 14, סם שלי 14, אני מתחיל את הפונקציה. אני פה ב 5, 5 הוא צומת והוא לא סוף הדרך ‫אז האיף הראשון לא, האיף השני לא, אוקיי. ‫אני שולח את עצמי ל left path counter בסדר? אני נוחת בשלוש, ועכשיו הסם שנשאר לי הוא 14 פחות 5 - 9, אוקיי, 9. בואו עכשיו נניח אני אלך איתכם ברשותכם ל right path ‫

212
01:15:56,140 --> 01:16:26,140
קאונטר של 3, זאת אומרת אני עכשיו עושה קריאה אקרוסיבית לתת ימין שלו לשש, אני עכשיו פה בשש והסם שנשאר לי הוא תשע פחות שלוש, שש. רגע, עוד רגעתי, אני עכשיו ברשותך לוקח אחד מטתי המסלולים, תת-מסלול, לא אומר לך זה כל האקרוסיה, אבל זה תת מסלול שיגיע לסם שווה 0, זה מה שאנחנו רוצים, אני פשוט עושה לך סימולציה מה קורה, אני עכשיו בקריאה אקרוסיבית שבה רוט נקודה value שי

213
01:16:26,140 --> 01:16:56,140
שווה שש, שם שווה שש, תעכבו, כי זה היה פה 14, רגע 14, 11, לא לא לא, שנייה שנייה, לא לא, 14 רגע, לא לא לא, רגע רגע, מה 14? 14, 9, 6, איך איך איך הפס нет ללעבד אריתמטיקה פסוטה, anyway, הנה טענת מסלול רקורסיבי, בסדר? איך איך אתן אסירים לפי אקספירופילים? איפה אתן מסלולים לחופים, האם אתן חופים, אפר־ו בערבית, נאצים בגרסיות של מה שחומצן, משלומתם מיאורטיות השרפאת. הסתכלו יותר מדפקות ממעשיחוק של האונד

214
01:16:56,140 --> 01:17:26,140
בסדר? התחלנו. 14, 9, 6. יופי, עכשיו תראו מה קורה, אני נמצא פה, תסתכלו, אני נמצא פה, ב-6, ואני עושה את הקריאה הזאת ללפט ורייט, תראו מה קורה, גם ב-f וגם ב-right אני מחסיר מ-scum את root value. אתם יודעים מה זה אומר? אני ארד לנאן השמאלי שלו, אני ארד לנאן הימני שלו, ובשניהם root is non ו-scum שווה שווה 0. בקיצור, הפונקציה הזאת, דפוק הנפטראל מסמך כל העולם, תצריך לעשות את זה בדרך. ארד חוט של רט של המטוניה שלך,48 מש 320 שנים, 25 מש

215
01:17:26,140 --> 01:17:56,140
כי תספור כפול. למה? כי גם בן שמאל יענה על התנאי הזה כתרו, וגם בן ימין, זאת אומרת, הנן שמאל שלו והנן ימין שלו של העלה הזה, שניהם יחזירו פה תרו. בקיצור, הפתרון האלטרנטיבי הוא בסך הכל אחד שמחסיר את זה, לא בהקריאה אקרורסיבית, אלא לפני. ואז, אנחנו עושים את השאלה.

216
01:17:56,140 --> 01:18:26,140
תשמע, אפשר לעשות הרבה דברים, אני רק אומר, מי שעימן חדה, היה עושה את הסימולציה הזאת, והיה קולט, היי רגע, יש פה ספירה כפולה. אז כדי לתקן את הספירה הכפולה הזאת, אני בסך הכל אומר, שינוי קטן, במקום להחזיר מהסאם את ה-value הנוכחי ברקורסיה, אני פשוט עושה את זה קודם, ואז אני אומר, אם אני עלא, אם ה left שלי וה right שלי הם כלום, אז אני מחזיר,

217
01:18:26,140 --> 01:18:56,140
if current sum = 0, יש פה אפילו דרך מאוד מגעילה לכתוב את זה, תראו מה כתוב פה, ריטרן 1 if current sum = 0, else 0, בשורה 1. אפשר לעשות את זה בפייתון, אל תעשו את זה אבל אני רק אומר אפשר. בסדר תהנה. בקיצור, בקיצור, תיקנו את הפונקציה הזאת, אוקיי. וואו לא נשאר כלום לתרגול וזו הדוגמא הכי חשובה לכל תרגול, אוקיי.

218
01:18:56,140 --> 01:19:26,140
תתרכזו, בבקשה, זאת הדוגמה הכי חשובה בתרגול, בקורס אחר שפעם הייתי מתרגל, הייתי מקדיש שני שליש תרגול רק לדוגמה הזאת. אני יודע, אבל זה בעיה שהיא וריאציה  על זה. אוקיי, תקשיבו, אני עכשיו חייב שתתרכזו כי זאת דוגמה שהיא הבסיס להבנה של בקטרקינג מי שמבין את הדוגמה הזאת, יבין בקטרקינג ברמה של הקורס הזה. נקודה.

219
01:19:26,820 --> 01:19:56,820
אוקיי, תהיו איתי, יש לנו פה בעיה שבה אנחנו צריכים לספור פתרונות. זאת אומרת, יש לנו פרמטרים, אנחנו צריכים לספור כמה פתרונות מתאימים לדרישה שלנו, וזה ידרוש בקטרקינג עם רקורסיה ולולאות ותנאים, אז תעכבו איתי. הינה הקטע. קודם כל, אני מניח שכולכם ראיתם פעם לוח שחמט או דם כאן, נכון? אני מניח שכולכם ראיתם. בתרגום המוקלט מראש, אפילו את ההנחה הזאת, לא עשיתי, והראיתי תמונת

220
01:19:56,820 --> 01:20:26,820
שזה באינטרנט, אבל בסדר, אנחנו בלייב - אין את הזמן לזה. מה צריך לעשות? נתון לכם לוח כזה שהוא משבצות אלטרנציה - שחור לבן, שחור לבן, בלה בלה בלה. הלוח הזה הוא בגודל n על n, זאת אומרת - ה-n הזה יכול להיות כל מספר שלם: 1 על 1, 3 על 3, 8 על 8, ועכשיו תניחו, שעל כל לוח n על n כזה, יש לנו n מלכוד.

221
01:20:27,160 --> 01:20:57,160
משחק שחמט, שאנחנו צריכים לשים על הלוח, וזה רק נחשב פתרון תקין, אם אף אחת מהמלכות, לא יכולה לקחת את המלכה אחרת כלשהי, במהלך אחד. מה זה אומר? בשחמט, כל כלי מלכה, יכולה בתור אחד, לעשות כזה דבר. יכולה ללכת לכל מקום בעמודה שלה, יכולה ללכת לכל מקום בשורה שלה, ויותר מזה, מלכה יכולה גם...

222
01:20:57,160 --> 01:21:27,160
לכל מקום באלכסון מיידי שלה כזה, אלכסון הזה, או אלכסון הזה. כלומר x, אלכסון x שלה, שני אלכסונים. זאת אומרת, היא לא יכולה לעשות תנועה של אלכסון ואז ישר, לא, בתור אחד היא יכולה או עמודה, או שורה, או האלכסון המיידי שלה כזה, או אלכסון המיידי שלה כזה. מה זה פתרון אם מלכות ? פתרון שמצליח לשים על לוח אין מלכות אין מלכות, אין מלכות, אין מלכות. חיים בלבבות. נצלחת להחזיר איזשהיא הלהחזירה להחזירה מלא קטטנים וחייבתא לבל

223
01:21:27,160 --> 01:21:57,160
על אן, אן מלכות, ככה שאף מלכה לא מאיימת על מלכה אחרת בתור אחד. ואנחנו צריכים, והבעיה כאן היא, שימו לב, לא למצוא פתרון כלשהו. הבעיה היא לספור את כל הפתרונות האפשריים עבור לוח אן על אן, אם אין מלכות. לספור את כולם, ואם יש פתרון, אם אתם בונים פתרון שלא סופר את כולם, לא תקין.

224
01:21:57,160 --> 01:22:27,160
יופי. איך נגשים לכזה דבר? שאלה קודם כל? -אם אין שם

225
01:22:27,160 --> 01:22:57,160
במקום הראשון, באפשר הנציגה. רגע, קיבלתי פה שאלות בצ'ט אם אני יכול לחזור אחורה, טוב, שאלות ישנות כבר, אני לא יכול לענות עליהן עכשיו, מצטער, אבל בסדר, יש הקלטה וגם יש הקלטה pre-recorded אז, סליחה, לא ראיתי בצ'ט, אוקיי, כן, מה אתה מציע? יכול, בוא נשים, אפס, אפס, את המציאה, ואז לראות איפה היא כאילו בולקת, איפה אפשר, איפה היא איפה

226
01:22:57,160 --> 01:23:07,580
בצורה, בעמודה ובעקנסון, והנפגעה על הכיוון, ואז במקומות שאי אפשר, אנחנו עושים מתגיית שנייה ונפגע אותו בבאא-אקצט.

227
01:23:07,580 --> 01:23:14,180
אתה בכיוון, אתה בכיוון, בסדר, אתה בכיוון, לגמרי בכיוון, אוקיי, אז אני צריך להראות לכם איך אנחנו נעשה את זה.

228
01:23:14,180 --> 01:23:26,720
אנחנו נלך בפתרון שהוא סוג של brute force. זאת אומרת, אנחנו נבדוק, לכל משבצת, כמה פתרונות אפשר לשים, כמה פתרונות אפשר למצוא, אם שמנו מלכה במשבצת.

229
01:23:26,720 --> 01:23:38,720
במשבצת הזאת, ואז המשכנו רקורסיבית הלאה. אחרי שספרנו את כל הפתרונות, נבטל את המיקום הזה של המלקה פה, ונשים אותה בעמודה הבאה בתור "ושוב נספור את כל הפתרונות"

230
01:23:38,720 --> 01:23:56,040
הדרך היחידה לספור את כל הפתרונות היא לנסות את כל המיקומים, אבל עדיין, אנחנו במדעי המחשב, יש מילימום שאנחנו כן נעשה, זה לכתוב פונקציית עזר שנקרא לה isValid, והיא רק תבדוק האם אפשר במשבצת הספציפית הזאת להניח מלכות,

231
01:23:56,040 --> 01:24:26,000
בהינתן כל המלכות שכבר הנחנו מקודם לכן, זו כן בדיקת חוקיות שצריך לעשות. אתה אמרת לבדוק שורה עמודה ואלכסונים, אתה צודק, אבל הבדיקה שלנו תהיה, האם אפשר לשים מלכה בנקודה XY, בהינתן כל המלכות שכבר הנחנו מקודם לכן, אחרת אין פואנטה. אנחנו לא נבדוק אבל מעצמנו והלאה, כי עוד לא בנינו.

232
01:24:26,000 --> 01:24:56,000
את זה, אנחנו נבדוק את התקינות הזאת תוך כדי החסמת מלכות, אז באמת מה אנחנו נעשה? קודם כל נפשט את הבעיה, נפשט את הבעיה. אנחנו נבין, לפי התכונות של מלכה בשחמ"ט, יכול להיות רק מלכה אחת כל שורה, רק מלכה אחת כל עמודה, וכמובן מלכה אחת כל הלחסון, אבל למה זה נוח לנו מלכה אחת כל שורה? כשאתה יורד שורה אתה חשב... בדיוק, אתם זוכרים איך אנחנו הגדרנו מטריצה דו-ממדית בפייסבק

233
01:24:56,000 --> 01:25:26,000
רשימה של רשימות, הרשימות הן פשוט שורה, פסיק שורה, פסיק שורה, מטריצה בפייתון ראינו את זה, זה פשוט כל אוויר ברשימת המטריצה הוא פשוט שורה של המטריצה אז מבחינתנו הכי נוח לנו לולאה חיצונית שתשים מלכה בכל שורה, לולאה פנימית שתבדוק הסמה של מלכה בכל מקום בעמודה

234
01:25:26,000 --> 01:25:56,000
עבור השורה הנוכחית, נקרא לפונקציית העזר שלנו 1939Valid טוב, אם תקין, נשים שם מלכה ונקרא רקורסיבית לפונקציה עבור השורה הבאה בתור, אחרי שהנפנו מלכה פה. והרעיון הוא שכל הסמת מלכה כזאת היא תספור כמה פתרונות אפשריים מכאן והלאה. ואחרי שנסיים את כל זה, אנחנו נצא חזרה מאותה קריאה רקורסיבית

235
01:25:56,000 --> 01:26:26,000
נבטא את המלכה ששמנו פה, ונבדוק עבורה עמודה הבאה בתור. וככה אנחנו נעשה לכל עמודה, לכל שורה, תמיד הקריאות הרקורסיבית היא דווקא תספור את שאר הפתרונות ממנו והלאה, וכל זה בסך הכל, בסך הכל, בסך הכל, יהיה בסך הכל, סכום כל הפתרונות האפשריים עבור n על n, עם n מלכות. I'll tell you how to do it in code, and I hope you'll understand. What we're going to show you now is an illustration of how to make things easier.

236
01:26:26,000 --> 01:26:56,000
לא לבדיקה את האיס ואליד שלנו, רק לבדוק, עבור תת הבנייה שהספקנו עד עכשיו, היא מתקינה. אם כן, נמשיך. אם לא, אוקיי, העמודה הזאת לא תעזור לנו, נעבור לעמודה הבאה בטון. אז בואו נראה לאט לאט את הפתרון, ואני באמת צריך את הריכוז המלא שלכם, זה דוגמת הדגל לבקטרקינג. אז ככה, הנה פונקציית הבקטרקינג הראשית שלנו, אני מגדיר אותה, סולף אין קווינס, מסתובב בו נחתה אלא להגיד רק שנתעשה את זה, שמתי את שאתה צריך לעשות את זה, ופת

237
01:26:56,000 --> 01:27:26,000
היא תקבל שני פרמטרים, מטריצה, שזה בשבילנו פשוט רשימה אדום ממדית, נקרא לה בורד, לוח, ופרמטר אחר, שורה. הקריאה הדיפולטיבית, תביא לנו, תתחיל משורה אינדקס אפס, יהיה לנו השורה הראשונה. נתחיל, אפילו פה, אתם רואים, אני כותב פה דברים ברורים אליהם, n גדול שווה לנקף של הבורד, זאת אומרת כמה שורות יש. בסדר? ועכשיו אני עושה כזה שאלה. אם

238
01:27:26,000 --> 01:27:56,000
אינדקס השורה שקיבלתי בקיאה אקורסיבית הוא n גדול, זאת אומרת, length של הבורד, זאת אומרת סיימנו לבנות, סיימנו לבנות פתרון עד הסוף, ואז מה אני עושה? אני קורא לפונקציה שתדפיס את הפתרון הזה בשביל המשתמש, ואז אני פשוט עושה return. אוקיי, הפונקציה הזאת ספציפית היא לא בדיוק תספור פתרונות, היא תדפיס פתרונות. אבל

239
01:27:56,000 --> 01:28:26,000
אבל ברור שאפשר היה לשמת את זה במקום ריתרן כלום, יכולנו לעשות ריתרן אחד, או כאילו... כן, בדיוק, יכולנו להחזיר מספר. זה פונקציה שתדפיס את כל הפתרונות התקינים. בסדר? שינוי אלגוריתמי קטן הופך את זה לספירה של מספרים, לא הבעיה, זה לא מה שישבור אתכם, בסדר? אם אתם תגיעו לכזה קוד, עשיתם 99% מהעבודה, זה בסדר. בקיצור, אם יצאנו החוצה מה שנקרא מהאינדקס של השורות, בקרייה הקורסיבית, סיימנו לבנות פתרון כלשהו,

240
01:28:26,000 --> 01:28:56,000
נדפיס אותו, ואז נצא מהקריאה הקרוסית. אם לא, אם אנחנו לא ברואו אחד הכי האחרון, יש לנו לפחות מלכה אחת לשים. אז הנה מה שאנחנו עושים, עבור השורה שאנחנו כבר נמצאים בה, נעשה לולה. לולה שתעבור על העמודות. grape for עמודה בריינג' העמודות. מה אנחנו נעשה? תראו את זה, אנחנו בעמודה כלשהיא, ואנחנו שואלים if is safe,

241
01:28:56,000 --> 01:29:10,560
‫למקם מלכה בבורד שקיים במצב כרגע, ‫בשורה הנוכחית, בעמודה הנוכחית, ‫אם זה בטוח לשים פה מלכה, ‫אני אומר "מטריצה בורד בשורה row, ‫בעמודה column שווה true".

242
01:29:10,560 --> 01:29:17,820
‫מבחינתכם, true זה כאילו יש פה מלכה. ‫שוב, אנחנו עובדים בצורה הכי פשוטה שיש, ‫מטריצה של true ו-fole סין, כן?

243
01:29:18,420 --> 01:29:25,540
‫נמקם פה מלכה, ואז תראו מה אני עושה, ‫קריאה קורסיבית לפונקציית הבקטרקינג,

244
01:29:25,540 --> 01:29:55,540
עם מה? עם המטריצה שעכשיו שמתי בה את המלכה פה ברואו פלוס 1, זאת אומרת, אני אומר שמתי פה מלכה, עכשיו תמשיך רקורסיבית הלאה לכל הפתרונות האפשריים, כשיש כאן מלכה ואתה ניסית לשים מלכות איפשהו בשורות שיותר מלמטה. כשאנחנו נצא מהרקורסיה הזאת, שימו לב, כשאנחנו נצא מהפקודה הזאת, אנו...

245
01:29:55,540 --> 01:30:20,540
אנחנו נעשה יופי, הדפסנו את כל הפתרונות האפשריים, אם היינו שמים פה מלכה. מה עכשיו? נעיף את המלכה ששמנו פה ונחפש אופציה אחרת. אני עושה בורד בשורה row בעמודה column שווה false, אין מלכה בדיוק ואז אתה יודע לאן זה מביא אותי? ל column הבא בתור, ל column הבא בתור, באותה שורה.

246
01:30:21,300 --> 01:30:34,220
זאת הדרך שלנו לחפש, להדפיס את כל הפתרונות, כי עבור לכל row אנחנו בודקים לכל column הסמת מלכה ואז משם והלאה את כל שאר הלוח.

247
01:30:42,280 --> 01:30:50,900
לא, זה בסדר גמור, לא, זה בסדר גמור, אתה רואה, four column של נושא מלכתחילה, in range. ברור, תראה, אה, למה?

248
01:30:50,900 --> 01:31:20,900
רגע, שנייה, למה? כל פעם כolve שלחת את הבורד. אני שלח את הבורד, כן, כשאני שולח אותו עם row1קולוס, אז בשורה הבאה בתור, הוא יבדוק את כל העמודות. זה הרעיון. כן, מה אתה רוצה להגיד? האם המפקר המקומי יגיע אינסכלפור? אה, אני לא זוכר את זה בעל פה. את זה אני לא זוכר בלפח. השאלה אחרת. שהשאלה אחרת יש לך. אנחנו רוצים להעשה עם...

249
01:31:20,900 --> 01:31:50,900
או עצרת העבור ב-0 ב-0, שלך עבור ה-0 שלו, אנחנו נשים פה מלכה, פה  מלכה, פה מלכה, מלכה, למרידים, ולא לרבים... 187 00:30:00,600 
תקשיב, אני אגיד לך מה יקרה במציאות. במציאות, אתה מתחיל מ-row = 0.אחרי זה אתה נכנס ל-lat בקודום 0.האם זה בטוח לשים מלכה כשאין מלכות על הלוח? כן, כי אתה רוצה לשים מלכה ב-0,0? אתה בודק רק עד ה-0,0, זה נכון בצורה ר outputs, אז אתה תשים שם מלכה, ואז אתה...

250
01:31:50,900 --> 01:32:20,900
תקרא לפונקציה הזאת עבור row 1 ומשם אתה תבדוק ב-col 0, אסור לשים פה מלכה בגלל שזה לא safe, אז אתה עובר עבר בתור לכולום 1. ועכשיו אתה ברוא 1, כולם 1, גם אי אפשר לשים פה מלכה כי יש לך מלכה באל עחסון שלך שמאלה למעלה. לא תשים פה מלכה ואז אתה תעבור לקולם 2, כאילו אי 0 1 2, ואז מלכה היא לא סוס, אתה יכול לשים פה כאילו פרש או איך זה קוראים לזה בש"א

251
01:32:20,900 --> 01:32:50,900
אסייף פה יחזיר לך טרו ופה אנחנו נעשה בורד ב-rOW 1 קולום 2 שווה טרו ואז נעשה קריאה רקורסיבית עבור רOW 2 וכן הלאה וכן הלאה וכן הלאה כן כן עד שבסופו של דבר הסיימנו לבנות את כל הפתרונות האפשריים רקורסיובית, נצא מזה, נבטל את המיקום מלכה פה ב-ROW 1 קולום 2, נעבור ל-קולום 3, נמקם מלכה

252
01:32:50,900 --> 01:33:20,900
ושוב נעשה את כל הפרוצדורה הזאת. שאלה. שאלה מולה, איך הפונקציה e-safe נראית? התשובה היא, לא מאוד מסובכת. לא באמת, הפונקציה e-safe אם תסתכלו עליה יש פה רק ור, יש פה ארבע פורים, לא e-safe היא הפונקציה הפשוטה, היא רק פונקציה שבודקת האם אפשר לשים פה מלכה, בהינתן כל הלוח שנמצא שמאלה ומעליי.לא רק שמאלה מעליי.

253
01:33:20,900 --> 01:33:50,900
גם ימינו מעליי, הרעיון הוא האם אפשר להניח פה מלכה בהינתן כל מה שקורה בשאר המקומות, אז מה אנחנו עושים? הפור הראשון הוא בודק האם השורה שאני רוצה לשים פה מלכה היא פנויה ממלכות. אתה רואה את זה? תראה 4 i in range עמודות. 
- זה זיפ עם... 
- לא, הזיפ עוד מעט, זה זיפ זה סתם, זה זוגות, חכו שנייה, הפונקציית אי סייף זה הפונקציה יחסי פשוטה כי תראו מה היא אומרת, אתם מקבלים את הלוח במצב...

254
01:33:50,900 --> 01:34:20,900
בניה חלקי, אתם מקבלים אינדקס שורה, אינדקס עמודה וגם N גדול והפונקציה היא בסך הכל יש לך תפקיד אחד לעשות, אם לא חוקי לשים פה מלכה, נחזיר False, אם כל הבדיקות צרדנו, נחזיר true חוקי לשים פה מלכה, כיף, אני כבר אסביר, כבר אסביר, רגע, אני כבר מסביר, רגע, הפורה הראשון אתם רואים מה הוא עושה, for i in range של העמודות, if bord בשורה הנוכחית, באמונט all ABC בסך הכלל אני שלח מתאים ואתה מקביל ברית הקודש בהאם היא ישרת בעצמך כן האם היא יצרת בעצמ�

255
01:34:20,900 --> 01:34:50,900
אעמודה I, true, זאת אומרת, יש מלכה, נחזיר false. זאת אומרת, בודקים את השורה, יש מלכה, false. 4 רבה בתור, עכשיו זה 4 אין ריינג' של שורות. אם יש מלכה בעמודה הזאת, false. יופי. עכשיו אנחנו צריכים לעבוד על הלאכסונים. עכשיו תראו, זה יכול להיות תסבוכת להבין את ה... ריינג' פה, אני אזכיר לכם עכשיו בקצרה, ה-שני 4ים האלה, הם בודקים בנעני

256
01:34:50,900 --> 01:35:20,900
בדיוק שני אלכסונים, הפור הראשון בודק את האלכסון מהמקום כאן שמאלה למעלה, והפור השני בודק מכאן ימינה למעלה. למה לא למטה דרך אגב? כי לא בנינו שם כלום. זה אי סייף שהיא חלקית. אז אני עכשיו חוסך לכם את הלנסות להבין את זה. הפור הזה, בודק מלכה שמאלה למעלה, כך אגב זה למה הרנג' הוא בסטפ שלילי, הוא מתחיל מהמלכה והולך שמאלה למעלה...

257
01:35:20,900 --> 01:35:49,660
זיפ זה בסך הכל הדרך שלך לעשות איטרציה שהיא כאילו בזוגות, תחשוב על זה ככה, אתה רוצה נניח, לא יודע, נניח יש לך שתי רשימות ואתה רוצה לעשות איטרציה על שתי הרשימות בפעולה אחת, אז נניח יש לך 4 IJ in zip של שני ליסטים, מה שיקרה?

258
01:35:49,660 --> 01:36:19,660
ה-IJ הראשון שלך יהיה האיבר הראשון בשתי הרשימות, ה-IJ הבא בתור יהיה האיבר השני בשתי הרשימות. כאילו ZIP זו דרך מאוד נוחה לעשות איטרציה על פני יותר מדבר אחד במקביל. זIP זה הפתרון לאנשים מצלנים שרוצים פשוט איטרציה מקבילית. זה הכל,זה הכל. אז פה זה בסך הכל איטרציה באינדקס שורה, אינדקס עמודה, זה הכל. ואני כבר הסברתי לכם עכשיו את המשמעות של זה. ה-PHONACT

259
01:36:19,660 --> 01:36:25,880
‫הפוער הראשון זה ממלכה שמאלה למעלה, ‫והפוער הזה ממלכה ימינה למעלה.

260
01:36:25,960 --> 01:36:29,960
‫מי שיקרא את הזיפ לעומק אחר כך, ‫יראה שזה באמת איך שזה עובד.

261
01:36:30,680 --> 01:36:35,840
‫בקיצור, זה כל מה שהפונקציה e-safe עושה. איך? ‫-ימינה למעלה?

262
01:36:36,040 --> 01:36:40,240
ימינה...? לא, ימינה למעלה. ‫איך היה לבדוק למטה באלעכסונים?

263
01:36:40,500 --> 01:36:44,020
מה זה? להחזיק? ‫-כי אתה בונה, אתה בונה, אין שם כלום.

264
01:36:44,180 --> 01:37:12,760
זהו, וגם הסיבה היחידה שפה, לבדוק אם יש לך מלכה בעמודה נוכחית, ולא עצרנו את זה, זה מהצלנות, זה היה לוקח יותר זמן לכתוב בקוד לעצור את זה עד ל-ROW מסוים, אז פשוט השארנו את זה על כל העמודה, זה הצלנות. שאלה, סיבוכיות הזמן של זה היא מאוד גבוהה, כי זה פתרון שהוא מאוד מאוד brute force, הוא בודק.

265
01:37:12,760 --> 01:37:42,760
אני לא זוכר כרגע בעל פה, כרגע בעל פה אני לא זוכר בדיוק, אפשר לבדוק את זה אחרת, טוב חכו שנייה, אנחנו עכשיו בעשר דקות איחור, רגע, לפני שאני משחרר אתכם לחדר למעלה, אני רק רוצה לרפרף עליכם, אתכם בזריזות, את הדוגמה השנייה, אז תנסו להיות איתי אם אתם עדיין פה. הדוגמה השנייה, אני חושב שהיא דווקא פשוטה יותר מהN מלכות, היא דוגמה שבסך הכל אומרת, קחו לוח ברחב N גובה

266
01:37:42,760 --> 01:38:12,760
מה זה לא יהיה? יש לכם תאים שהם טרו ותאים שהם פולט. המשימה שלכם לספור כמה דרכים יש לכם להגיע מהתא השמאלי עליון לתא הימני עליון. מה אתם יכולים לעשות? לעשות תנועה אחת ימינה לתא שהוא טרו, או אתם יכולים לעשות תנועה אחת למטה ל�תא שהוא טרו. זה בדיוק, ורק טרו, רק אם זה טרו, לאן שאתה הולך.

267
01:38:12,760 --> 01:38:31,120
והאתם צריכים לספור, פה באמת לספור, כמה דרכים יש לכם לעשות את זה, jęינה, למטה, כמה זה יהיה, כמה דרכים יש לכם לעשות כאלה מהלכים, עד שתגיעו ליעד שלכם. לא שמע?

268
01:38:32,440 --> 01:38:42,660
לא, פשוט בערך כשאתה מגיע ל.. לאטופ. תראה, אז בואו, אני רק רוצה להראות לכם זריז, זריז את הפתרון, תראו רק בזריזות את הפתרון.

269
01:38:42,660 --> 01:39:12,660
הפתרון הוא לא מאוד מאוד מסובך, יש לנו את, פה באמת יש לנו כאן את המייז, שימו לי, יש לנו את המבוא, יש לנו את הפוזיצ'ן, נתחיל מפוזיצ'ן 0-0, בסדר, שמאלה למעלה, נגדיר אינדקס שורה אינדקס עמודה, נגדיר את ה-m שלנו, שיהיה, ונגדיר קאונט שווה 0, פה אנחנו באמת עושים ספירה, מה נעשה, אם הפוזיצ'ן שלנו הוא mpsqm, זאת אומרת, חרגנו ב.. מקורסיה, הגענו לסוף.

270
01:39:12,660 --> 01:39:42,660
כמו במלקות, הגענו לסוף, יצאנו החוצה מהמייז, מה שנקרא, ריטרן אחד. 
- לא , זה לא אם חרא אתה, זה לגעת באופן הראשון.
- לא, לא, תסתכל, תסתכל, אה, אתה צודק, אתה צודק, אתה צודק. אתה צודק, כי היה מינוס אחד, בסדר. זה בסדר גמור, בסדר. זה אותו דבר גם אם זה לא היה מינוס אחד ואז כאילו היינו משנים את הלוגיקה קצת, לא משנה, בסדר גמור. אז אם הגענו לסוף, ריטרן אחד, מסלול, מוצלח. אם לא הגענו לסוף, אז תראו, לא מאוד מסובך. יש לנו פה בסך הכול,

271
01:39:42,660 --> 01:40:12,660
שני איפים, מה האיף אומר? האיף הראשון אומר, אם אני לא הגעתי לשורה התחתונה עדיין ומתחתיי במס זרועוד פלוס אחד אותה עמודה אפשר לעבור, זאת אומרת אן זה ט רו, כלומר אם אפשר לעבור שמה, שימו לב, המבוך הגדרנו אותו, ט רו אם אפשר לעבור, פולס אימי אפשר, אז זה למה האיף פה הוא מאוד פשוט, הוא פשוט עושה אין התה ההוא. זאת אומרת מלבד קט את האפשר לעבור ומלבהד קט מלנקה הרסבונר יכולה לעבור קורה שוב וצריך לעבור מאוד מאוד מאוד הרבה מה שאזצר הייתה דעתה להשמוע את זה

272
01:40:12,660 --> 01:40:17,200
‫אם אתה הוא טרו אפשר לעבור שם. ‫בקיצור, יש פה בסך הכול שני,

273
01:40:17,400 --> 01:40:20,840
‫יש פה שני מעברים שאנחנו בודקים. ‫העיף הראשון בודק:

274
01:40:20,960 --> 01:40:25,400
‫אם אני לא הגעתי לשורה התחתונה עדיין, ‫ואני יכול לרדת שורה למטה,

275
01:40:25,600 --> 01:40:31,040
‫אז קאונט פלוס שווה צפירת ‫כל המסלולים שאני אקבל,

276
01:40:31,260 --> 01:40:34,800
‫אם אני אעשה את המעבר הזה, ‫אחד למטה.

277
01:40:36,220 --> 01:40:41,200
‫אחרי העיף הזה עוד עיף: ‫אם אני לא הגעתי לעמודה הכי ימנית,

278
01:40:41,400 --> 01:40:50,340
‫בתא אחד ימינה פנוי, אז קאונט פלוס שווה ‫כל הדרכים האפשריות שאני אספור,

279
01:40:50,500 --> 01:40:56,500
‫כשאני אזוז תא אחד ימינה. ‫ואז אתם רואים שהריקורסיה הזאת פשוט תתקפל,

280
01:40:56,700 --> 01:41:01,820
‫תתקפל עם קאונטים שגדלים וגדלים וגדלים, ‫עד לקריאה של פוזיישן 0,0,

281
01:41:02,020 --> 01:41:05,420
‫והיא תחזיר את הקאונט הסופי. ‫וזהו.

282
01:41:05,660 --> 01:41:11,260
‫אם היה אפשר גם לדבר עליו, ‫לפחות לפני שנכנסתי... ‫-לא, רמות הסיבוכיות היו עולות לך.

283
01:41:11,260 --> 01:41:39,780
כן, הסיבוכיות שלך היו עולות משמעות, הייתה עולם משמעותית, פה זה כאילו הגרסה הכי פשוטה של זה. זה למה התרגיל השישי הזה הוא דווקא קל יותר לדעתי, מה- n-queen. אז אם אתם שואלים אותי, אלון, איזה תרגיל לנסות להבין אותו לעומק, בשביל להבין backtracking? n-malcott. ואל תדאגו, בתרגול הזה לא הספקתי להראות לכם טיפה אחת של קוד רץ בזמן אמת, אבל יש לכם במודל טוטוריאל 11 אינטראקטיב ואינטראקטיבי.

284
01:41:40,560 --> 01:41:43,920
יאללה, בואו תעלו לחדר 110, אני עוצר את הקלפה.

