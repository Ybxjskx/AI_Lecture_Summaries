1
00:00:00,000 --> 00:00:17,000
היי, ברוכים הבאים לתרגול הראשון של הקורס מבוא למדעי המחשב. שמי אלון פפיני ואני אחד מהמתרגלים שיעבירו את הסמסטר הזה חורף 2024-2025.

2
00:00:17,000 --> 00:00:28,000
אז במקרה שאתם אולי רוצים לדעת למה יש את ההקלטה הזאת כאשר התרגולים הללו מועברים בצורה פרונטלית ממילא, ובכן שתי סיבות.

3
00:00:28,000 --> 00:00:57,000
ראשונה כדי שאני בתור מתרגש שלכם אקבל מעין חזרה גנרלית כדי שאני אוכל לתת לכם תרגול שהוא חד ומשומן נקרא לזה ככה. סיבה שנייה היא אולי אתם רוצים לשמוע את התרגול מועבר אבל בצורה רגועה, מעין ראש מדבר לתוך מיקרופון. ובכן אם זה קורה אצלכם אז הקלטה הזו ואחרות כמוה שיבואו אחר כך.

4
00:00:58,000 --> 00:01:27,000
עלולה לעזור לכם. בכל מקרה אני חושב שאנחנו יכולים להתחיל. לפני שניגע קצת בחומר בעניינים של מחשב וכולי נדבר קצר מאוד על המנהלה והדברים המשעממים. ובכן אתם נמצאים בקורס אקדמי בחוג למדע המחשב באוניברסיטת חיפה וכרגע אנחנו מתכננים 12 שבועות בקורס. כל שבוע מחולק לשתי הרצאות שאתם מקבלים.

5
00:01:28,000 --> 00:01:57,000
בסמסטר זה ההרצאה הראשונה מועברת ביום ראשון והשנייה מועברת ביום רביעי. ואחר כך יש לכם את התרגול ואת המעבדה של אותו שבוע אקדמי. עכשיו על מנת למנוע מכם בלבולים כדאי שתדעו שהתרגולים והמעבדות מועברים בסבבים שונים. כל סבב זה בעצם מתרגל אחר. אז הסבבים הם הולכים בסדר כזה. אחרי שהיו לכם.

6
00:01:58,000 --> 00:02:28,000
את שתי ההרצאות אחת ביום ראשון והשנייה ביום רביעי ובכך כיסיתם את חומר ההרצאות של אותו השבוע. יש לכם סבב של יום חמישי סבב של יום ראשון מיד אחריו ואז יום שני מיד אחר כך. אז מי שלדוגמה יגיע לתרגול של יום ראשון. למעשה מקבל את התרגול הרלוונטי לשבוע שהיה מיד לפני. ככה זה הולך אבל אל תלעגו.

7
00:02:28,000 --> 00:02:58,000
אתם כולכם תקבלו את כל מה שאתם צריכים בזמן טוב. בסדר אז מה זאת אומרת הרצאות תרגולים ומעבדות. אז בהרצאות אתם תקבלו ממש את התיאוריה את ההסבר אתם תקבלו את ההצגה של הרעיון של הנושא של החומר שאתם צריכים לדעת. אחר כך בתרגולים אתם תחוו מעין חזרה לרעיונות האלה קצת דיבור בצורה שונה.

8
00:02:58,000 --> 00:03:28,000
שיעזור לכם קצת יותר להבין ויותר לקבע את התחושה של בסדר אנחנו קולטים את מה שאנחנו צריכים לדעת פה. ובתרגולים יהיה קצת יותר דגש על לענות על שאלות במשותף. משהו שממש יעזור לנו להבין ככה להתחכך עם הנושא. מיד אחרי תרגול מועברת גם מעבדה. הרעיון של המעבדות הוא ממש כדי שאתם.

9
00:03:28,000 --> 00:03:58,000
יוכלו מול המחשב שלכם לפתור שאלות. אתם תקבלו ממש כל מיני סעיפים נפרדים של תכתבו קוד שעושה כך וכך. והתפקיד יהיה שלכם ממש לפתור את השאלות בעצמכם. זה אמור ממש לתת לכם את החיכוך שאתם צריכים כדי להרגיש יותר טוב עם ההבנה שלכם והמוכנות שלכם. המעבדות בעיקרון הן בעיקר עבודה עצמית כאשר המתרגל שיהיה

10
00:03:58,000 --> 00:04:28,000
איתכם שמה ינסה לעזור לכם. חוץ מזה יש גם את העניין של בגלל שזה קורס התחלתי שבעצם זאת הפגישה שלכם עם הרעיון של מדעי המחשב וכולי. אנחנו נרצה להתעקש על נוכחות חובה ככל האפשר. כמובן עם היכולת שלנו להתייחס בצורה מכבדת לאנשים שהנסיבות האישיות שלהם לא מאפשרות את זה. חוץ מזה

11
00:04:28,000 --> 00:04:58,000
כמובן בענייני שעות קבלה זה ילך ככה. יש לנו בשביל הקורס, לפחות בסמסטר זה, שרת דיסקורד שדרכו אנחנו נתחזק את הקשר איתכם. הודעות, שאלות תשובות על החומר, תרגילי בית וכולי. אנחנו נבקש שדברים כאלה יעברו דרך הדיסקורד. אם אתם תרצו לשאול אותנו שאלות בנושאים פרטיים או אישיים, זה משהו שתוכלו להפנות למדי

12
00:04:58,000 --> 00:05:28,000
מיילים שלנו, אותם אתם תוכלו למצוא במודל של הקורס ובמקרים ממש קיצוניים שאתם צריכים הרבה זמן פנים אל פנים איתנו, אתם כמובן תוכלו לבקש מאיתנו שעות קבלה וגם הדרך לעשות את זה נמצאת במודל של הקורס. אבל רק תזכרו, לפני שעות קבלה, אם יש לכם פשוט שאלה על חומר או שאלה על תרגילי בית, תוכלו לשאול אותנו בשרת הדיסקורד, באמת שאנחנו נסתדל לענות.

13
00:05:28,000 --> 00:05:58,000
חוץ מזה, כדאי לכם לדעת שזה קורס שיש לו מבחן סוף, שבסמסטר זה הוא יהווה 80% מהציון הסופי שלכם בקורס, אז תוודאו שלפני שיגיע המבחן אתם תתכוננו אליו. וחוץ מזה, אנחנו מתכננים שיהיו לכם כ-5 תרגילי בית, שאתם אתם תצטרכו לעשות ולהגיש אותם, והמשקל שלהם מהציון הסופי שלכם אמור להיות כ-15% מהציון.

14
00:05:58,000 --> 00:06:10,000
והוא יהיה תקף, תקף זה אומר אתם חייבים להגיש את תרגילי הבית, כי אם לא, אז זה 15% מתוך 100 פוטנציאלי שפשוט לא יהיה לכם.

15
00:06:10,000 --> 00:06:27,000
חוץ מזה, אנחנו מבקשים שתעשו את תרגילי הבית האלו בצורה יחידה, ללא שותפים, כלומר כל אחד ואחת מכם עושים את תרגילי הבית, בכל זאת אתם מתחילים תואר במדעי המחשב, כדאי שאתם תכתבו קצת קוד, אחרת.

16
00:06:28,000 --> 00:06:53,000
מה אתם עושים פה? כמובן שזה אומר שאתם צריכים להבין את מה שאתם מגישים, להיות מסוגלים לדעת להסביר את זה, כדאי מאוד שאם אתם תגישו תרגילי בית, זה לא יהיה סתם קוד שמצאתם איפשהו, עשיתם קופי פסט וקראתם לזה יום, כי אם אנחנו נתפוס את זה, זה יהיה חבל, סתם בעיות, אף אחד לא רוצה את זה, אף אחד לא צריך את זה.

17
00:06:53,000 --> 00:07:21,000
חוץ מזה, אנחנו מקווים גם שאתם תהיו נוכחים במעבדות ותעשו אותן, כי אנחנו מעוניינים שהמעבדות יהיו חמישה אחוזים מהציון שלכם, גם תקף, כלומר, שאתם צריכים לעשות את המעבדות, כי אחרת אולי זה יוריד לכם קצת הציון. בכל מקרה, נכון לרגע ההקלטה הזו, אנחנו עדיין לא סגורים במאה אחוז על איך אנחנו נעריך את הציון של מעבדות, זה ייקבע בהמשך.

18
00:07:21,000 --> 00:07:43,000
בנוסף, אם הכל יעבוד ולא יהיו תקלות טכניות, אתם מתישהו תתחילו לראות החל משבוע מסוים, מעין בחנים שבויים כאלה שהתפרסמו, אבל הם לא חלק מהציון, הם פשוט שאלות כאלו שהן שם בשבילכם, בשביל תרגול עצמי, לראות שאתם על החומר, מה שנקרא.

19
00:07:43,000 --> 00:08:12,000
ועכשיו סוף סוף אפשר להתחיל את החלק הכיפי, שזה הקורס עצמו. אז אנחנו במבוא למדעי המחשב, ולפני שאנחנו יכולים לדבר על החלקים המדעיים כביכול, קודם כל אנחנו צריכים טיפה תזכורת, או שאולי היכרות, מה זאת אומרת מחשב? אז תראו, אתם אולי יודעים, אולי יצא לכם להתעסק עם לפטופ, מחשב נייח, הסמארטפון שלכם, טלפון.

20
00:08:13,000 --> 00:08:43,000
אנדרואיד, אייפון וכולי. הם כולם מחשבים, וואלה, זה פשוט מכשירים חשמליים דיגיטליים, שיש בהם אחדות ואפסים שם איפשהו, ומאבדים צ'יפים של סיליקון שעושים עבודה וכולי וכולי. אז בואו ניקח את כל מה שאנחנו יודעים בידע כללי, וממש נתמצת את זה לבסיס של הבסיס. מבחינתכם, הצורה אולי הכי בסיסית,

21
00:08:43,000 --> 00:09:13,000
של מחשב, לפחות אבסטרקטית, זה הרעיון הזה. מחשב, אז אולי אתם חושבים על המעבד שלו, החלק שחושב, שעושה פעולות, אתם כנראה יודעים שלמחשב יש זיכרון, אחרת איפה דברים היו נשארים או נשמרים, וכדאי שאתם לפחות תכירו את הרעיון של כלת פלט. כלומר,

22
00:09:13,000 --> 00:09:43,000
עכשיו מכאן והלאה, כשאנחנו נדבר על הרעיון של מחשב, לפחות תחשבו על זה שיש כלת, מידע שנכנס אל המחשב בצורה אחת או אחרת, המחשב על המעבד שלו, על ה-Central Processing Unit שלו, עושה חישוב, בעזרת כלת, על הדרך, יש שם גם אינטראקציה עם הזיכרון של המחשב, אולי המחשב רצה לקחת מידע מהזיכרון שלו כדי לעשות

23
00:09:43,000 --> 00:10:13,000
חישובים, ואולי גם אחרי החישובים האלה הוא שומר את המידע הזה אל הזיכרון, והרי איך אתם משתמשים במחשב, בדרך כלל אתם גם מקבלים ממנו פלט כלשהו, אז אולי אתם רואים משהו, אולי אתם שומעים משהו, אז תחשבו על הדברים האלו שאומרים לכם מחשב, מחשב עושה חישוב, פעולות, יש לו לקיחה או קבלה

24
00:10:13,000 --> 00:10:43,000
או כתיבה אל הזיכרון, אתם מביאים מידע למחשב, והמחשב מוציא מידע. בסדר, אז מה, איזה דוגמת באמת למחשב יש, או לאמצעי כלת פלט, אז זה באמת הדברים שאתם מכירים, מקלטת ואכבר, שאני כרגע משתמש בהם עכשיו בשביל סמן הלייזר פה שאתם רואים, אז אני בעצם מכניס כלת למחשב, אני לוחץ עכשיו על הכפתור קונטרול, מחזיק אותו לחוץ, אני לוחץ על כפתור

25
00:10:43,000 --> 00:11:13,000
עכבר שמאלי של המחשב, ומזיז אותו, וזה סמן הלייזר שאתם רואים, אז זאת אומרת, אני עכשיו מכניס כלת בצורה מתמשכת אל המחשב, חוץ מזה כמובן, אני מדבר אליכם דרך המיקרופון שלי שנמצא על השולחן, וכמובן על המחשבים שלכם יכולים להיות מצלמות, יכולים להיות לכם בקרי משחק, יכולים להיות לכם בכלל מכשירים אחרים כמו פקסים או סקנרים שאתם מחברים למחשב, בקיצור, אין גבול, יש...

26
00:11:13,000 --> 00:11:43,000
אין ספור אמצעי כלת שמכניסים מידע אל המחשב, אז המחשב מקבל מידע, הוא עושה עם אותו דברים, והוא גם מוציא את זה החוצה, אז מה זאת אומרת פלט? מה זה מידע שיוצא החוצה? זה בעצם דברים ברורים אליהם, הרי איך אתם משתמשים במחשב? יש לכם בדרך כלל מסך, המסך של הטלפון, מסך של מחשב, מסך

27
00:11:43,000 --> 00:12:13,000
של לא יודע, של מכונת הכביסה, שאתם בוחרים את המצב של מה... איך לכבס, והוא כותב לכם כמה זמן זה ייקח. כן, זה פלט, זה האאוט, אתם מכניסים מידע, היה לכם את האין, המחשב עשה עבודה, ואז אאוט, מוציא לכם מידע, אז זה יכול לעבוד דרך מסך, זה יכול להיות סאונד שהוא משמיע לאוזניות, רמקולים וכולי וכולי.

28
00:12:13,000 --> 00:12:43,000
אז אני מניח שלפחות אם אתם הגעתם עד לנקודה הזו, אתם מבינים את הרעיון האבסטרקטי, המופשט של מחשב, מידע פנימה, חישוב, אינטראקציה תוך כדי עם זיכרון, אולי צריך מידע בזיכרון כדי לעשות חישוב, בסוף החישוב אולי גם שומר לזיכרון, ופלט החוצה, אתם יכולים לראות דברים שהמחשב בעצם עשה.

29
00:12:43,000 --> 00:13:13,000
נפלא, אז בואו ניכנס לזה טיפה יותר עמוק, תראו, מחשבים בסופו של דבר זה חומרה, זה דברים פיזיים, זה הצ'יפים שאתם אולי יודעים שיש שם בפנים, האלקטרוניקה שבפנים, זה בסופו של דבר משהו מוחשי, תקראו לזה כלי, אבל איך הכלי הזה, כאילו מה גורם לכלי הזה לעבוד? מה בכלל

30
00:13:13,000 --> 00:13:43,000
מאפשר את האינטראקציה בינכם לבין הדבר הזה שנקרא לו מחשב? אז בואו נדבר לרגע על מערכת הפעלה, לפחות בצורה פשוטה. אני לדוגמה, נמצא כרגע על מחשב, שיש לו מערכת הפעלה שקוראים לה windows, ספציפית אצלי windows 11. אז מה זה בעצם בשבילנו? אז מערכת ההפעלה זה בכלל הדבר שנותן הוראות לחומרה של המחשב.

31
00:13:43,000 --> 00:14:13,000
כדי לעשות דברים, אז בכלל אם תסתכלו פה בדיאגרמה שנמצאת משמאל, אתם באמת תקבלו קצת רעיון. יוזר זה המשתמש, זה הבן אדם שמשתמש במחשב, אז המחשב הוא בעצם החומרה, הhardware, אבל יש דברים בדרך לשם. אז לדוגמה, אני כרגע המשתמש, אני משתמש בתוכנה, אפליקיישן.

32
00:14:13,000 --> 00:14:43,000
פרוגרם, פאוור פוינט, אני עושה אינטראקציה איתה, זה הקלט שאני מביא אל התוכנה, והתוכנה גם עושה לי פלט, היא מראה לי את עצמה, אז הקלט שלי כרגע זה המקלטת והכפר, והפלט זה סמן הלייזר הזה, בסדר גמור. אבל על מה פאוור פוינט, התוכנה שלי כרגע, רצה? פאוור פוינט רצה על מערכת ההפעלה, על windows. זאת אומרת,

33
00:14:43,000 --> 00:15:13,000
כן, אני משתמש בתוכנה כרגע, אבל מה התוכנה, מה זה אומר בעצם? הרי הפעולות של התוכנה, לאן הן נשלחות? זה בעצם נשלחות למערכת ההפעלה. אז בעצם, מה שאני עושה בתוכנה הזאת, זה נשלח במרכאות כקלט לתוך מערכת ההפעלה, במקרה שלנו פה, windows, ועל הדרך, ה-windows גם יכולה לתת פלט אל התוכנה.

34
00:15:13,000 --> 00:15:43,000
אז במקרה שלנו זה יכול להיות, מה אם אני הולך לפאוור פוינט, ואני רוצה שפאוור פוינט תפתח מצגת? אז פאוור פוינט שולחת קלט, בבקשה למערכת ההפעלה, בבקשה, תתני לי לפתוח את המצגת כך וכך. ומערכת ההפעלה, תיגש אל המצגת, איפה שהיא נמצאת, והיא תביא לתוכנה, את התוכן. אוקיי, ואז יש את השלב הזה, שבין מערכת ההפעלה לחומרה, וזה באמת השלב הנמוך נמוך.

35
00:15:43,000 --> 00:16:13,000
איפה שאנחנו מתקרבים לפקודות ישירות שהחומרה יודעת כבר לזהות. החומרה שלנו, המחשב שלנו, יש לו ארכיטקטורה משלו, יש לו את הדרך שבה הוא רץ, הפקודות שהוא יודע להעריץ, מה שנקרא, על המטכת, על הברזלים, אם זה אומר לכם משהו, מכירים את הביטוי הזה? אז האינטראקציות האלה שבין מערכת ההפעלה והחומרה, זה באמת הדברים הכי קטנים שיש,

36
00:16:13,000 --> 00:16:43,000
כל דבר קטן, גישה לזיכרון, השמעת סאונד, וואלה, אני יכול באמת להגיד לכם כל דבר, כל תזוזה קטנה של העכבר, זה אומר שצריך לחשב איפה הסמן של העכבר יהיה אחר כך, כל הדברים הקטנים האלה, באמת, הכל הכל הכל בסופו של דבר מתורגם לפקודות שהברזלים מריצים, ואז הם יביאו פלט, אולי שינוי בזיכרון.

37
00:16:43,000 --> 00:17:13,000
אולי פיקסל חדש הולך להצטייר על המסך. וכל זה בעצם עולה את השרשרת עד שבסופו של דבר המשתמש רואה את השינוי. אז עכשיו אתם ממש קיבלתם צלילה כזאת אל ההלוך ושוב שקורה בין המשתמש עד לחומרה. אז אם אני עכשיו מסתכל ימינה לרגע על הטקסט שכתוב פה, אז אני מניח שאתם גם יכולתם להעסיק את זה. ברור שאפילו גם על הטלפון הנייד שלכם.

38
00:17:13,000 --> 00:17:43,000
כמו אייפון או טלפון של אנדרואיד, ברור שיש לו מערכת הפעלה, ויש את האפליקציות שמה, יש את הלחיצות שאתם עושים, כל החישובים שקורים שמה, הפעולות שקורות. מערכת ההפעלה, בסוג אחד או אחר, יש בכמעט כל דבר שאנחנו יכולים לקרוא לו מחשב. וכל הדיבורים שדיברנו עד עכשיו, אני מניח כבר נראים לכם דומים כאן, נכון? הרי מה זה מחשב?

39
00:17:43,000 --> 00:18:13,000
זה מערכת ההפעלה בשביל המשתמש, אני כמשתמש פותח תוכנות על מערכת ההפעלה, אני מתעסק עם הקבצים, לוחץ על מקלט וחבר ומצפה שהם יעבדו. אז מה זאת אומרת, מה זה מערכת ההפעלה מבחינת אבל המתכנת? ובכן, אנחנו פה בקורס מבוא למדעי המחשב, אנחנו כנראה נלמד תכנות, ובשביל לנו תכנות, אם אתם רוצים פרופורציות, זה בעצם...

40
00:18:13,000 --> 00:18:43,000
לכתוב את השלב הזה, את האפליקיישן. למרות שבמציאות הרבה פעמים זה גם לכתוב אלמנטים שבשלב הזה של ה-Operating System. אני לא יודע כמה עכשיו אתם תראו, אבל אולי אתם תגלו בעתיד, שיש הרבה יותר גמישות וקווים הרבה פחות ברורים בין אפליקיישן ו-Operating System. אבל אני לא אלך איתכם יותר מדי רחוק, בואו נשמור דברים לאחר כך. אבל

41
00:18:43,000 --> 00:19:13,000
רק שתדעו שמערכת ההפעלה היא גם חשובה מאוד בשביל מי שמתכנת את התוכנות שרצות על מערכת ההפעלה. כי בסופו של דבר, המתכנת צריך לדעת מה יקרה עם הזיכרון. המתכנת צריך לדעת איך הוא כותב קוד שיגרום לתוכנה לרוץ מהר. זאת אומרת, איזה קוד לכתוב שמערכת ההפעלה תבין, ככה שחלקים של הקוד לדוגמה ירוצו במקביל. ואז אנחנו פשוט נחכה פחות

42
00:19:13,000 --> 00:19:43,000
זמן. אבל שוב, אלו כבר נושאים יותר מתקדמים, אני רק רוצה שאתם תכירו אותם, שהם תהיו מודעים שהם קיימים, מבלי שנלך רחוק מדי. מבחינתנו, אנחנו רק כרגע מנסים להבין, יש כזה דבר. מחשב, על מחשב יש מערכת הפעלה שרצה ומאפשרת את השימוש בו, ושכמובן זה הולך לכל הכיוונים, משתמש קצה, מי שתכנת והכין את הסיפור,

43
00:19:43,000 --> 00:20:13,000
ולפני שאני בכלל יכול לדבר איתכם על נושאים יותר ספציפיים כמו הזיכרון, אני רק רוצה לתת לכם תזכורת, אולי משהו שכבר הספקתם לשמוע בהרצאות. זיכרון, זאת אומרת, מידע. לפני זה, איך? איזה סוג של מידע זה? אז אני רוצה להזכיר לכם על הקונספט של סביות ובתים. זאת אומרת, מה קורה במחשב? איך זיכרון?

44
00:20:13,000 --> 00:20:43,000
איך הוא נשמר? אז כדאי שתכירו, יש יחידות מידע דיגיטליות. זאת אומרת, בואו נסביר מה המספרים שאנחנו הולכים לראות אומרים. אז אני רוצה להכווין אתכם אל היחידת מידע דיגיטלית הקטנה ביותר שיש, וקוראים לה בעברית סיבית, באנגלית בית. מה זה בית? פשוט מאוד. או אפס, או אחד.

45
00:20:43,000 --> 00:21:13,000
או כלום, כבוי, או דלוק. יענו, יש מתח. למרות שבמערכות מחשוביות מסוימות הסדר הוא הפוך, אבל לא שמעתם את זה ממני. בקיצור, on או off, true או false? 0 או 1. אתם אולי שמעתם על בסיס 2 של ספירה, כלומר, מספרים שיש רק את הספרות 0 או 1, אז 0 זה 0, 1 זה 1.

46
00:21:13,000 --> 00:21:43,000
2 זה 1 ואחר כך 0, כלומר, מה שאתם מכירים בתור 10, לא בדיוק, כי זה פשוט, אחרי שהיה לכם את 1, אתם חייבים פשוט להוסיף עוד ספרה. אז 1, 0 זה 2, 1, 1 זה כבר 3, וכן הלאה וכן הלאה. בסיס 2. בקיצור, בית. on או off, true או false? עכשיו, אם אנחנו ניקח מספר ככה בבינארי,

47
00:21:43,000 --> 00:22:13,000
נרכיב אותו משמונה ביטס, זאת אומרת, אם אני עכשיו, בואו נסתכל. אנחנו יכולים לכתוב נניח מספר 11101100. אתם רואים כאן? יש לנו פה שמונה ביטס. אז מה אנחנו עושים כזה מספר? אנחנו נקרא לזה בייט. זאת אומרת, מספר שמורכב משמונה ביטס קוראים לו בייט. אז אתם מכירים את המילים קילו בייט?

48
00:22:13,000 --> 00:22:43,000
מגאבייט? גיגאבייט? אז זאת אומרת, זה יחידות גדולות יותר שהבסיס שלהן הוא בייט. בהרבה מאוד ארכיטקטורות מחשוב ישנות או פחות מסובכות, וגם בחלק מהארכיטקטורות שעדיין בשימוש היום, בייט היא בדרך כלל הייתה ידועה בתור יחידת הזיכרון הקטנה ביותר של המחשב, שאפשר היה לגשת אליה ולעשות איתה אינטראקציות בנפרד.

49
00:22:43,000 --> 00:23:13,000
אז תכירו את המילים ביט או סיבית ואת המילה בייט. חשוב מאוד. אוקיי, יש לנו את יחידות המידע. אז מה זאת אומרת זיכרון במחשב? בואו נצלול לזה. אז אולי כדאי שתדעו, כשאנחנו מדברים איתכם על זיכרון במחשב, אנחנו לא בהכרח מדברים איתכם על ההרדיסק או על ה-SSD או על איזשהו דיסק אונפולקט.

50
00:23:13,000 --> 00:23:43,000
כי אתם יכולים לחבר לא בדיוק. כשאנחנו מדברים איתכם על הזיכרון הראשי של המחשב, אנחנו מדברים איתכם על הרם. זאת אומרת, אנחנו מדברים איתכם על הזיכרון שהמעבד של המחשב יכול לגשת אליו עכשיו, כאילו, לבקש גישה, לעשות גישה לקרוא או אולי לכתוב אליו, וזה המידע שהמחשב שלכם יכול להשתמש בו באותו רגע בשביל דברים. אז נניח, יש לכם

51
00:23:43,000 --> 00:24:13,000
אולי לפטופ עם 8 או 16 גיגאבייט רם, אומרים? אז הרם זה הזיכרון, בסדר? אז מה זאת אומרת זיכרון? זה היה בדיוק המקום שהמחשב או התוכנות שרצות על המחשב יכולות פשוט לעשות הלוך ושוב של לקרוא או לשמור מידע תוך כדי עבודה. אז איזה סוג של מידע? טוב, זה יכול להיות משתנים של תוכנה שרצה או...

52
00:24:13,000 --> 00:24:43,000
מה זה משתנים בכלל? אנחנו נדבר על זה אחר כך. אני אתן לכם דוגמה יותר פשוטה. נניח שאתם הדלקתם את המחשב, ואתם רוצים להתחיל לשמוע מוזיקה, אוקיי? אז אתם ככה... טוב, אני באתי להגיד פותחים קובץ mp3, אבל בוא נגיד את האמת, רובכם פשוט פותחים ספוטיפיי או משהו, אז תהיו איתי, תדמיינו לרגע שאין ספוטיפיי ושאנחנו באמת הולכים לפתוח קובץ מוזיקה על המחשב עצמו, בסדר? אז אנחנו נלך למחשב.

53
00:24:43,000 --> 00:25:12,000
נפתח קובץ מוזיקה, יכול להיות mp3, פלאק, או מה שאתם רוצים, ומה קורה? התוכן של הקובץ הזה נטען אל הזיכרון של המחשב, יענו אל הרם, ואז המחשב עצמו, החומרה שלו, יודעת לקרוא את המידע הזה, ואז להוציא את זה החוצה אל האוזניות או לרמקולים. אז זה סוג של תוכן שנטען לזיכרון הראשי בשביל שימוש.

54
00:25:12,000 --> 00:25:13,000
זה סתם דוגמה שתדעו, אז איך הזיכרון הזה נשמר במחשב? אז תראו, בעיקרון יש אין ספור דרכים ספציפיות שבהן הזיכרון נשמר במחשב, אבל קונספטואלית, אני רוצה שתדעו שלמידע שיש על המחשב, שזה יכול להיות ביחידות של, כמו שאמרנו מקודם, בייטס, או...

55
00:25:42,000 --> 00:26:12,000
אם אתם במחשב מודרני, זה יכול להיות ביחידות של 32 ביטס, או 64 ביטס, שזה מתורגם לארבע בייטס, או שמונה בייטס, או איך שתרצו לקרוא לזה. בקיצור, זה פשוט יחידות של זיכרון, לפעמים שמורות בצירה רציפה, לפעמים לא, ולכל יחידת זיכרון כזאת, אנחנו פשוט ניתן כתובת. אז... כי תחשבו, זה הגיוני. יש...

56
00:26:12,000 --> 00:26:42,000
יש לכם פשוט נפח מקסימלי של... במרכאות זיכרון, נכון? תחשבו לדוגמה לרגע על הרם שלכם. אומרים, יש לו 8 גיגאבייט, 16 גיגאבייט, זה נפח זיכרון מקסימלי. אז, מן הסתם, שלכל יחידת זיכרון צריך שתהיה לה כתובת, צריך שיהיה לה שם כזה, שנדע מי לגשת אליה. אז, לרגע, בואו נחשוב על זה בדוגמה. נניח שיש לכם מערכת הפעלה, שהיא מה שנקרא

57
00:26:42,000 --> 00:27:12,000
מבוססת 32 ביט, או במילים פשוטות, מערכת הפעלה כזאת, שיחידת הזיכרון הקטנה ביותר שלה, מיוצגת על ידי 32 ביטים, שזה אומר, אם אני אפתח פה את זה, תחשבו על... יש פה 8 ספרות, אז 3-3 נקודות, עוד כמה ספרות, וזה בעצם, יש פה 32 ספרות בינאריות, וזאת כאילו יחידת זיכרון אחת, שיש לה כתובת

58
00:27:12,000 --> 00:27:42,000
ספציפית. אז הרעיון הוא, אם ככה, אם יש לנו מערכת כזאת אפשרית של 32 ביט, פר מילת זיכרון, אז כמה את הזיכרון המערכת הזאת בכלל יכולה למצוא, כמה יכולים להיות לה, אז אני רוצה שתחשבו על זה ככה. כל מילת זיכרון שיש לנו, כמו שראינו, היא פשוט מורכבת מ-32 ספרות, ככה. אז אני רוצה לשאול אותך,

59
00:27:42,000 --> 00:28:12,000
בצורה אחרת, אם ככה, כמה כתובות נפרדות, אנחנו יכולים לייצג, ככה שכל כתובת בעצמה, היא תהיה מספר של 32 ספרות בינאריות? זאת התשובה לשאלה. כי תחשבו, מערכת שבה, זה היחידת זיכרון הקטנה ביותר שלנו, אז יש לנו 32 ספרות אפשריות, כל אחת מהן יכולה

60
00:28:12,000 --> 00:28:42,000
להיות או 0 או 1, אז יש לנו משהו שאני מקווה שאתם גם תלמדו במתמטיקה דיסקרטית, זה קומבינטוריקה. זה היכולת לספור את כל האפשרויות שיש, תחת תנאים מסוימים. אז אני רק אגיד לכם, התשובה לשאלה שכזאת היא, יש לנו, עבור כל ספרה, שתי אפשרויות, ועבור כל שתי אפשרויות שספרה, יש

61
00:28:42,000 --> 00:29:12,000
לנו גם את השתי אפשרויות עבור הספרה הבאה, אז 2 כפול 2, ועבור כל האפשרויות האלה, יש לנו גם את השתי אפשרויות של הספרה הבאה, כפול 2, וכן הלאה וכן הלאה, עד שנגיע לספרה 32. כלומר, במילים אחרות, יש לנו פה 2 בחזקת 32 כתובות אפשריות במערכת הפעלה,

62
00:29:12,000 --> 00:29:42,000
שיחידת הזיכרון הקטנה ביותר שלה היא בעצמה מילה או מספר שמוגדר מ-32 ספרות בינאריות. עכשיו, אם כל זה נשמע לכם טיפה מסובך, טיפה מוגזם, יש מצב. אולי זה משהו שאתם אולי לא תהיו חייבים לזכור בעל פה כרגע, אבל אני אומר לכם, ככל שיעבור זמן, זה מסוג הדברים שצריכים לבוא לכם קצת בתור אינטואיציה.

63
00:29:42,000 --> 00:30:12,000
האינטואיציה שלכם צריכה להביא אתכם למסקנה של, אה, זה מערכת של 32 ביט, זאת אומרת, המקסימום יחידות זיכרון שלה יכול להיות להיות ככה. אבל לא משנה, אולי קצת הגזמנו. איניווי, בואו נמשיך הלאה. אז בדיוק מקודם דיברנו על הזיכרון הראשי, שזה בעצם הסטיקים של רם שיש לכם על מחשב, אבל מן הסתם, שזה לא העיסוק היומיומי שלכם, העיסוק שלכם הוא...

64
00:30:12,000 --> 00:30:42,000
רגע, כמה מקום פנוי יש לי במחשב? רגע, אני רוצה לשמור סרט או לשמור תמונות שצילמתי וזה. אין בעיות, פה מגיע הזיכרון המשני של המחשב, המידע שנשאר שם כשאתם מכבים את המחשב. אז פה באמת מגיע דיסקים קשיחים או SSDים או דיסקונקים, זה באמת הזיכרון שנשאר גם כשאתם חיביתם את המחשב או חיביתם את הטלפון, חיביתם את המצלמה, המידע יישאר מהר שם.

65
00:30:42,000 --> 00:31:12,000
עכשיו רק שתדעו, זה מידע שהגישה אליו, גם הלוך וגם השוב, היא הרבה יותר איטית מהזיכרון הראשי שלכם. אז זה למה אנחנו בכלל צריכים את השלבים השונים האלה של זיכרון. אז אפילו שכשאומרים לכם מידע במחשב, אפילו כשאתם פותחים קבצים במחשב, שבפירוש נמצאים בזיכרון המשני שלכם, שתדעו שמה שקורה זה שהמחשב

66
00:31:12,000 --> 00:31:42,000
טוען את המידע מהזיכרון המשני שלכם, וכשאני אומר טוען את המידע, כנראה הכוונה היא שהמעבד של המחשב עושה פקודות שמעתיקות את המידע מהזיכרון המשני שלכם אל הזיכרון הראשי שלכם. אז בכלל סיבכתי לכם את החיים, אבל קרבתי אתכם קצת יותר להבין איך דברים עובדים במציאות. אז דיברנו על מה זה מחשב, קצת מה זה מערכת הפעלה, זיכרון,

67
00:31:42,000 --> 00:32:12,000
ביטים, בייטס, ואולי סוף סוף אנחנו יכולים להתחיל לדבר על דברים שיותר מתקרבים לתכנות, אני ממש מקווה. אז יאללה, בואו נתחיל לדבר במונחים שהם צריך לדעת בתכנות. אז נתחיל מהדבר הכי פשוט שיש, קבוע, שזה פשוט ערך כלשהו, זה פשוט איזשהו ערך, נו אתם יודעים, יכול להיות מס...

68
00:32:12,000 --> 00:32:42,000
מספר, יכול להיות מספר שלם, או מספר ממשי כלשהו, זה יכול להיות סתם אמת או שקר, מה שנקרא True or False, 1 או 0, או שזה יכול להיות רצף של תווים, מחוזת, שזה פשוט בשבילכם טקסט, אז גם בשפות תכנות, לגמרי, יש לנו את הערכים האלה, אז יכול להיות לנו דוגמה, מחוזת, שזה פשוט

69
00:32:42,000 --> 00:33:12,000
רצף של טקסט, נקרא לו, Hello World, זה ממש התוכן עצמו, אתם רואים אותו פה במרכאות, אז אנחנו יכולים לשמור את הקבוע הזה, או אפילו לא לשמור אותו, פשוט להגיד את הקבוע הזה, אנחנו יכולים להדפיס אותו בשפת תכנות כלשהי, ולראות את זה, מה משמעות לנו, למעשה, בואו נראה אם אני יכול להראות לכם את זה עכשיו, נניח, אני אפתח לרגע את שפת התכנות שלנו, פייתון, ואני פשוט אשתמש בפקודה,

70
00:33:12,000 --> 00:33:42,000
שקוראים לה פרינט, ואני אנסה לכתוב, הלו וורלד, אבל בלי ה-w, כן, ומדהים, לחצתי על Enter, וזה הדפיס לי את מה שכתבתי לו, במרכאות, להדפיס לי, הלו וורלד, סבבה, אז, אבל קפואים זה נחמד וזה, אבל זה לא, זה לא, כאילו, כל מה שאנחנו יכולים לעשות, כן, קבוע יכול להיות כלפי עצמו,

71
00:33:42,000 --> 00:34:12,000
או זה יכול להיות איזשהו ערך שאנחנו נשים בתוך משתנה, ומשתנה זה איפה שסוף סוף אנחנו מתחילים לעשות דברים אינטראקטיביים, דברים שאנחנו יכולים להשתנות. אז, מה זה משתנה? אז בואו נגדיר את זה ככה, בשבילנו משתנה, זה יהיה ייצוג, זה יהיה השם, שאנחנו ניתן לאיזשהו מקום בזיכרון של המחשב, כן, זוכרים? זיכרון?

72
00:34:12,000 --> 00:34:42,000
אז המשתנה זה יהיה ייצוג שאנחנו ניתן למקום כלשהו בזיכרון, כדי שאנחנו נוכל להשתמש במקום הזה בזיכרון, כדי שאנחנו נוכל לשמור שם מידע, או לשנות מידע, כן? אנחנו יכולים, לדוגמה, להגדיר משתנה כלשהו, זאת אומרת, יהיה לנו איזשהו טייטל עבור מקום איפשהו בזיכרון, יכול להיות שאנחנו עושים חישובים, ואנחנו חייבים לשמור,

73
00:34:42,000 --> 00:35:12,000
את החישובי ביניים שלנו, את התוצאות ביניים, את הדרך לשם, כדי להגיע לתוצאה הרצויה שלנו. אז בשביל זה אנחנו יכולים להגדיר משתנה, לעשות שם שינויים, לשמור עליו שינוי, או לבדוק את הערך שם, ולפי זה לעשות שינוי, וכן הלאה וכן הלאה. אז נניח, לא יודע, אולי אנחנו רוצים לעשות איזושהי פעולה, שתקבל מידע מהמשתמש, או מה...

74
00:35:12,000 --> 00:35:42,000
הפעלה, או מה שזה לא יהיה, ואנחנו נעשה לו פלוס ארבע, ונשמור את התוצאה שזה. אז איך אנחנו נתעסק עם המשתנה? מה, אנחנו כזה, נגיע לאיזושהי כתובת בזיכרון, כתובת מאה, סליחה, אלף מאתיים עשרים ושלוש, נכניס לתוכה איזשהו מספר, או אני לא יודע מה, ואז כאילו, אנחנו נשמור כתוצאה במקום אחר, בכתובת אלף מאתיים עשרים ושלוש,

75
00:35:42,000 --> 00:36:12,000
פלוס ארבע, את מה שהיה באלף מאתיים עשרים ושלוש, פלוס ארבע, מה? מה? לא. אנחנו נעבוד עם משתנים, אז אנחנו ניתן למשתנים שלנו שם. והשם הזה, היא הדרך שבה אנחנו נדע להתייחס לאותו מקום בזיכרון. כי לתת למשתני שם, כמו שבמתמטיקה, היה לכם X ו-Y בשביל חדווה, בשביל גרפים, זה פשוט היה הגיוני ונוח יותר.

76
00:36:12,000 --> 00:36:42,000
יש נעלם, משהו שאתם לא יודעים, תנו לו שם X או-Y ותעבדו עם הנעלם הזה. אז אנחנו נעבוד בעולם של תכנות, ובעולם של תכנות יהיה לנו משתנים עם שמות, יהיו לנו דרכים לעשות פעולות על המשתנים, ואנחנו נוכל לעשות פעולות חשבוניות על המשתנים, ובסוף אנחנו גם נשמור את התוצאה למשתנים אולי אחרים, או אולי לא אותו משתנה.

77
00:36:42,000 --> 00:37:12,000
ההחלטה תהיה שלנו. אז באמת המשתנה הזה, מה, איך אנחנו מגדירים אותו בשפת תכנות שלנו? אנחנו יכולים בכלל סתם ככה לקבוע משתנה עם איזשהו שם כלשהו, פשוט לזרום עם זה? אז תראו, זה קטע שעובד, לא אותו דבר, בשפות תכנות שונות. לדוגמה, בשפת תכנות שקוראים לה C,

78
00:37:12,000 --> 00:37:42,000
למעשה זאת שפת תכנות שאותה למדנו בקורס מבוא למדעי המחשב בשנים מוקדמות יותר. זאת הייתה שפת תכנות שבה יכולנו ממש, מה שנקרא, להצהיר, שזאת אומרת, להגדיר בצורה כזאת שהשפת תוכנה מבינה שהגדרנו משהו. יכולנו להצהיר בעצם על משתנה כלשהו, עם שם, אפילו סוג משתנה, אבל נדבר על זה אחר כך.

79
00:37:42,000 --> 00:38:12,000
ולא היינו חייבים לקבוע מה יהיה הערך של המשתנה הזה לפני שהיינו ממשיכים הלאה. אבל יש סיבות ללמה יכולנו לעשות את זה. לפחות אתם צריכים לדעת שבשפה פייתון אנחנו חייבים להגדיר ערך למשתנה שאנחנו מכחיזים, כאילו משתמשים בו בפעם הראשונה. אוקיי, אבל זה קצת בלבול. מה?

80
00:38:12,000 --> 00:38:42,000
מי מאמור? למה להצהיר איתחול? מה זה? אוקיי, לאט לאט, תראו. במערכת הפעלה שלנו, בזיכרון שלנו, נניח שאנחנו רוצים באמת לשמור שם מידע, נניח דרך משתנה, כן? אנחנו רוצים לשמור, כמו שאמרנו, במקום זיכרון איזשהו ערך. השאלה היא איזה סוג של ערך? זה מספר? זה מכרוזת?

81
00:38:42,000 --> 00:39:12,000
איזה סוג של ערך? תראו, אתם בטח יודעים שלקבצים שונים, לדוגמה, במחשב שלכם יש גדלים שונים. אתם יודעים שווידאו זה בדרך כלל קובץ גדול, ותמונה זה בדרך כלל קובץ קטן יותר, נכון? אז מה זה גודל קובץ? זה בעצם מקום בזיכרון שזה תופס. כמה שורות זיכרון זה צריך בשביל להיות. אז גם במשתנים יש את הקטע של

82
00:39:12,000 --> 00:39:42,000
כמה מקום בזיכרון משתנה תופס. כי משתנה יכול להיות בעצם הכותרת עבור יותר ממילאת זיכרון אחת בזיכרון. כי מה לעשות? יש סוגים שונים של מידע, כמו שדיברנו בקבועים, אמרנו מספר, יכול להיות גם אמת או שקר, true או false, אבל גם יכול להיות מכרוזת. ואני רוצה שתדעו, למחזות בעורקים, בעורקים שונים, יכול להיות הם...

83
00:39:42,000 --> 00:40:12,000
גודל שונה בזיכרון, לפי כמה טקסט אנחנו שמים שמה. אם תכתבו עכשיו קובץ טקסט ענק, תעשו copy paste, הרבה paste paste paste paste paste, ותשמעו את זה בזיכרון, וואלה זה גדול יותר מקובץ טקסט ריק. אז יש את הקטע הזה, שבשפת תכנות, שם אנחנו גם אומרים, הנה סוג המשתנה, סוג התוכן שיש שמה, אז אותה שפת תכנות יודעת כמה מקום מראש היא תקצה. זאת אומרת, כמה מקום מראש

84
00:40:12,000 --> 00:40:42,000
היא תשים בצד, ותיתן לו כותרת, זה שם המשתנה. והיא כבר מראש תקווה, מקום בזיכרון, אתה הולך להיות הסיפור הזה. אבל פייתון הולכת להיות שפה דינמית. שפה שבה אנחנו יכולים קצת להיות יותר who is equal בשימוש שלנו במשתנים. אז אנחנו לא יכולים סתם ככה להגיד, משתנה חדש, קוראים לך גרייד, תהנה. זה לא אומר כלום לפייתון, כי פייתון

85
00:40:42,000 --> 00:41:12,000
לא יודע מה יהיה שם, הוא לא יודע כמה מקום זה יתפוס. אז הוא פשוט יגיד, זה לא מוגדר לי, אני לא יכול להשתמש בזה, השם הזה לא אומר לי כלום. אז באמת בואו באמת עכשיו נסתכל על השקופיות במצגת שאומרות את מה שדיברתי עכשיו, אז אתם מבינים שאם אנחנו ניקח משתנה כלשהו, נניח נקרא לו מי קו תחתון ואל, ונשים בו ערכים שונים. אז תראו, כזה דבר.

86
00:41:12,000 --> 00:41:42,000
בשפת התכנות פייתון יעבוד, כי אנחנו כזה אומרים, אוקיי, משתנה שקוראים לו מיי ואל, הערך שלך עכשיו יהיה חמש. אחר כך אנחנו אומרים לו, משתנה שקוראים לו מיי ואל, הערך שלך יהיה 1.8. אז כאילו פייתון יקבל את זה בתור פקודה. הוא יגיד לעצמו, אה אוקיי, אני בכלל צריך כמות שונה של מקום בזיכרון, כדי לאחסן את הערך הזה. אז הוא באמת ישמור מקום אחר בזיכרון, וישים את ההערך הזה שמה. וכמו שאמרנו

87
00:41:42,000 --> 00:42:12,000
עכשיו, סוג שונה של מידע ידרוש כמות שונה של מקום בזיכרון. אז למעשה, כל הפעולות האלה ישמרו את המידע השונה הזה במקומות שונים בזיכרון. מספר שלם, מספר ממשי, תו יחיד, סתם בוליאן, אמת או שקר, כמו שדיברנו מקודם על ביט, באמת, זה יתפוס את המקום הכי קטן בזיכרון, או מחוזת שלמה, בעל אורך שיכול להשתנות. אז אתם מבינים

88
00:42:12,000 --> 00:42:42,000
זה יתפוס מקום שונה בזיכרון. לדוגמה, רק מקודם אמרתי לכם שפת תכנות אחרת. אז אם נסתכל עכשיו על שפת תכנות, כמו שיא, ונסתכל על שלושה סוגים של משתנים, פופולריים, או לפחות בסיסיים, בשפה הזאת, כמה מקום בזיכרון הם יכולים לתפוס? אז זוכרים שאמרנו על יחידת זיכרון בייט, שזה כאילו שמונה ביטים? אז תסתכלו. נניח תו יחיד כלשהו, ממש אתם נוחצים על כפתור אחד,

89
00:42:42,000 --> 00:43:12,000
במקלדת, זה תו. אז זה יכול לתפוס בייט אחד בזיכרון. אז אמרנו שמונה ספרות בינאריות, אנחנו גם דיברנו על הרעיון הזה של כמה מספרים זה יכול לייצג, אז נניח מספר של 32 ביט, אמרנו אנחנו יכולים לייצג 2 מחזקת 32 ערכים אפשריים, אז יכול להיות לנו גם באמת את הרעיון הזה של תו.

90
00:43:12,000 --> 00:43:42,000
אחד שתופס בייט אחד, זאת אומרת, 1, 2, 3, 4, 5, 6, 7, 8 ספרות, כן? ספרות של מה? של אפסים ואחדים, כן? אז הנה, יש לנו פה 3, הופה, יש לנו פה 7 ספרות, עוד הספרה. בקיצור, זה יכול להיות בייט פוטנציאלי, אז בסך הכל יש לנו 2 מחזקת 8 אפשרויות שונות, שלרך אגב, 2 מחזקת 8, 7, 2, 5,

91
00:43:42,000 --> 00:44:12,000
56, 256 אפשרויות שונות, כלומר, 0 עד 255, שזה בעצם העמודה הזאת של טווח ייצוג. אז אולי עכשיו אתם קצת יותר מבינים את מה שאתם רואים פה, אז באמת, בשפת תכנות שבה אנחנו גם מגדירים או שאת הסוג משתנה שאנחנו עכשיו שומרים, אז...

92
00:44:12,000 --> 00:44:42,000
אתם אולי גם יודעים איזה ערכים אפשריים יכולים להישמר שמה. עכשיו, מן הסתם, שיש כזה דבר, מספרים שליליים בעולם, ואנחנו יכולים לשמור מספרים שליליים במחשב, איך? על ידי זה שאנחנו נייצג אותם בצורה שונה בזיכרון. עכשיו, אתם רואים פה לדוגמה, אינט, היה לנו אינטג'ר, מה שאנחנו קוראים לו מספר שלם, כתוב פה שהוא תופס בזיכרון, לדוגמה,

93
00:44:42,000 --> 00:45:12,000
ארבע בתים, או כמו שאמרנו מקודם, 32 ביטס, אז אתם רואים פה שמשהו שהוא כאילו תופס 32 ביטים, אז יכולים להיות לנו במקסימום 2 בחזקת 32 ערכים אפשריים. עכשיו, אם 0 נחשב ערך, אז זאת אומרת 0 עד 2 בחזקת 32 פחות 1, כי כל זה ביחד זה 2 בחזקת 32 אפשרויות שונות.

94
00:45:12,000 --> 00:45:42,000
אבל מה אנחנו רואים פה? 2 חזקת 31, פחות 1, ופה בקצה זה מינוס 2 חזקת 31? אז כן, מתברר שאם אתם תגנבו ספרה אחת, ובעצם תקדישו אותה בשביל מינוס, אתם יכולים, בעצם, קצת הקטנתן את הטווח בספרה כלשהי, אבל יכולתם להגיע למינוס של כל המספרים האלה. תראו, זה כבר...

95
00:45:42,000 --> 00:46:12,000
טיפה יותר מתקדם, אולי אתם תדברו על זה בהרצאות, או אולי אתם תקבלו את זה בקורס אחר, אבל סתם שתדעו, יש דרך לייצג מספרים שליליים בזיכרון. זה פשוט להשתמש בספרה כלשהי בשביל היצוג השלילי. אז כן, דיברנו עכשיו הרבה מאוד על משתנים ייצוג בזיכרון, בלה בלה בלה, אבל שתדעו, בפייתון יהיה לכם קצת נוח, אתם לא תוכלו להצהיר על משתנה מראש,

96
00:46:12,000 --> 00:46:34,000
בלי ערך, כי בפייתון כל משתנה יכול להיות כל סוג אפשרי, האחריות היא פשוט תהיה לכם, אתם רוצים ערך כלשהו בפייתון, אז אתם תגידו, נניח x שווה ככה וככה, או y שווה ככה וככה, ופייתון פשוט יבין, אוקיי, זה סוג הערך שהולך להיות שם.

97
00:46:34,000 --> 00:46:35,000
אז באמת, בואו אתם רואים דוגמה, שנניח אתם רוצים לשים את המספר 5 בתוך משתנה שקוראים לו נאם, זה יעבוד. מיד אחר כך אתם תריצו את הפקודה נאם שווה 1.8, וזה גם יעבוד. אבל בשפת תכנות כמו C, נניח הייתם מאחיזים אינט נאם, כלומר, משתנים נאם מסוג אינטג'ר, שזה מספרים שלמים, והייתם...

98
00:47:04,000 --> 00:47:34,000
שמים את הערך 5, אז אחר כך הייתם מנסים לשים לו 1.8, זה לא היה עובד. בסדר. יש פה חידה קטנטנה, שזה סתם לראות איך האינטואיציה שלכם עכשיו מתפתחת במחשבים. אז בשורה הראשונה פה, אנחנו שמים את הערך 5 במשתנה שקוראים לו נאם, וזה נשמר לאיזשהו מקום בזיכרון. נקרא לזה נניח x, איזושהי כתובת. מה יקרה אחרי שנריץ את הפקודה הזאת? נאם...

99
00:47:34,000 --> 00:48:04,000
שווה עכשיו ל-1.8. השאלה היא, האם עדיין נאם יהיה בעצם הכוונה לאותה כתובת x בזיכרון? אז אם איכשהו הצלחתם לעקוב אחרי כל מה שנאמר עד כאן, יכול להיות שאתם תגידו, יש מצב שלא, וזה נכון. יש מצב שאם עכשיו אנחנו נריץ את הפקודה נאם שווה 1.8, אז נאם בעצם הולך לייצג מקום אחר בזיכרון.

100
00:48:04,000 --> 00:48:34,000
למה? אנחנו, יכול להיות שאנחנו מבינים שמספר, כזה מספר לא שלם, אלא מספר ממשי, יכול להיות שהוא ידרוש קצת יותר מקום בזיכרון לייצג אותו, כי תשמעו, יש לכם גם את כל המספרים השלמים שיכולנו לייצג ממילא, אבל גם יש לכם את כל הנקודה, ואז כל הספרות האלה, אכן נקודה עשרונית. הרבה יותר מספרים לייצג, לא?

101
00:48:34,000 --> 00:49:04,000
אז, זאת אומרת, אותו מקום בזיכרון שאנחנו הקצינו מראש בשביל הייצוג הזה של מספר שלם, כנראה לא יספיק. אז אנחנו בעצם, זה שעשינו פה, גם שווה 1.8, אנחנו הגדרנו משתנה חדש, בעצם, במקום אחר בזיכרון, שיתפוס יותר מקום בזיכרון. פשוט, אנחנו כמתכנתים, נוח לנו,

102
00:49:04,000 --> 00:49:34,000
לקרוא לו באותו שם, אז, עכשיו אתם ראיתם דוגמה, פייתון, בהרבה מובנים, קצת מקלה עלינו לחשוב, כדי שאנחנו לא נהיה עסוקים בשטויות האלה של סוג משתנה. משהו לדעת. אז בואו נסתכל על תוכנית פשוטה. בואו נראה, קצת בצורה מוחשית יותר, איך זה יכול להיות בזיכרון שלנו. אז נניח שאנחנו נכריז,

103
00:49:34,000 --> 00:50:04,000
על, נכריז, זה פייתון, מה זה נכריז? אנחנו פשוט נגדיר, נגדיר משתנה A עם הערך 85, אז זה יישמר איפשהו בזיכרון. נגדיר משתנה אחר, B שווה 95, אז הוא יישמר באיזשהו מקום בזיכרון. ועכשיו אנחנו נגדיר משתנה בשם C, שהערך שלו יהיה פשוט, תוצאת הפעולות האלו, על שני המשתנים A ו-B, ואיזשהו מספר קבוע. אז

104
00:50:04,000 --> 00:50:34,000
במקרה שלנו, A ועוד B, כל זה חלקי 2, כלומר הממוצע. אז אנחנו נחשב את הערך הזה, הממוצע מן הסתם הולך לצאת 90, והוא יישמר למקום כלשהו בזיכרון. עכשיו דרך אגב, הוא יישמר בפייתון כנראה, בתור 90.0, זאת אומרת בתור מספר ממשי. למה? בוא להגיד את זה ככה, פעולות חישוביות,

105
00:50:34,000 --> 00:51:04,000
בפייתון, והדברים שצריך להתחשב בהם, עם שברים פוטנציאליים וזה, אני כבר אשאיר את זה לפעם אחרת, תדיבור על זה. אבל ברור לכם שזה משתנה מסוג שונה, לא מספר שלם. סתם, תקראו לזה קוריוז של פייתון. אז אנחנו אחר כך יכולים להדפיס את זה על המסך. The average is 90.0. לאוקיי? אז ראיתם פה.

106
00:51:04,000 --> 00:51:34,000
עוד דוגמא. עכשיו, יש את הקטע הלא נוח הזה שוואלה, אי אפשר לתת לכל משתנה אפשרי, כל שם שבא לנו, זה פשוט לא ילך. אז איזה מזהה, איזה איידנטיפייר, איזה שם משתנה ניתן למשתנה שלנו? אז בעולם התכנות, יש כללים. זה לא יותר מדי כללים,

107
00:51:34,000 --> 00:52:04,000
ואם הזמן, זה גם ירגיש לכם מאוד אינטואיטיבי. אז תראו, בהרבה שפות תכנות, כמה שזה לא נעים לנו, אנחנו נצטרך להשתמש באותיות או בתווים לטיניים, מה שנקרא. כלומר, בתווים שאתם רגילים להשתמש בהם בשביל מילים באנגלית. אז פשוט תווים רגילים באנגלית, אולי ספרות ואולי קווים תחתונים. אבל לא

108
00:52:04,000 --> 00:52:34,000
הרבה יותר תווים אחרים. לא תווים ככה קצת מוזרים כמו סימני שאלה או סימן קריאה או כל מיני. אתם תראו, יש קצת מגבלות. חוץ מזה, שם של משתנה, בעיקרון אין יותר מדי מגבלות על השם, על האורך, כאילו כמה תווים אנחנו צריכים בשביל השם משתנה. כמובן שבמציאות, אנחנו נרצה שהשם לא יהיה ארוך מדי. אנחנו לא יכולים להתחיל שם משתנה בספרה, כי

109
00:52:34,000 --> 00:53:04,000
שפת תכנות מבינה מספרים בתור מספרים, אז אם אנחנו מתחילים לכתוב ספרה, אז השפת תכנות לא תבין מה אנחנו רוצים ממנה. היא תחשוב שאנחנו מתחילים לכתוב מספר, אבל אז אנחנו מיד אחר כך כותבים תווים שהם לא מספרים, וזה קצת לא מובן. וגם, וגם וגם וגם, זה חשוב, לשפות תכנות יש מילים שמורות, מילים שכשלעצמן יש משמעות, כמו סוג משתנה אין.

110
00:53:04,000 --> 00:53:34,000
פרינט או הפקודה פרינט, אז אנחנו לא יכולים להתחיל, כאילו אנחנו לא יכולים לכתוב שם משתנה שקוראים לו פרינט. זאת אומרת, מה אני לא יכול לעשות עכשיו בפייתון? אני לא יכול עכשיו לכתוב פרינט שווה חמש, זה לא ילך. אוקיי, אז וגם כאילו תחשבו על זה, כשאתם פותחים סביבת פיתוח, כשאתם אפילו פותחים,

111
00:53:34,000 --> 00:54:04,000
עורכי טקסט מתקדמים, כמו נוטפד פלוס פלוס, ואתם כותבים קוד, אתם רואים שהוא גם עיצבה לכם את כל הסיפור בצבעים שונים. למה הוא בכלל עושה את זה? זה כי הוא מזהה מה כל חלק, כאילו, מה כל חלק אומר. אז איזו דוגמה שהיא עיצבה את פרינט בצבע שונה, זה כי הוא יודע שזה פקודה, לא משתנה. בסדר. עכשיו יש לנו פה תרגילון קטן, ערנות, בדיקה.

112
00:54:04,000 --> 00:54:34,000
איזה מהשמות שמופיעים פה בעמודה השמאלית בטבלה, הם שמות משתנים חוקיים, ואיזה מהם לא. אז בואו ננסה לעבור על זה אחד אחד. אז פה יש לנו my, קו תחתון, variable. אין פה מספר שמתחיל מקודם, אין פה תווים מוזרים, יש פה רק תווים ככה באנגלית, קו תחתון, וזה, בלי רווחים, בלי כלום. בקיצור, חוקי. Second place, אבל עם שתיים.

113
00:54:34,000 --> 00:55:04,000
שמתחיל איתם עם שם משתנה, זה לא חוקי. לא ילך. עכשיו תראו, קו תחתון, private, var, עם v גדולה. אז אל תתבלבלו, קו תחתון בהתחלה של שם משתנה, ואחר כך סתם תווים באנגלית, חוקי. אוקיי, עכשיו יש לנו פה total, סימן דולר, sum. אוקיי, לא אמרתי לכם כלום על תווים מתקדמים.

114
00:55:04,000 --> 00:55:25,000
כאלה באמצע שמשתנה. אז מה אתם אומרים, חוקי או לא חוקי? זה לא חוקי, כי הסימן דולר, תאמינו לו, זה סימן שיש לו משמעויות שונות, בספות תכנות שונות. זה יכול להיות משהו קצת שמור, אז לא.

115
00:55:25,000 --> 00:55:26,000
יוזר ניים, עם קו באמצע, מקף, רגיל. אבל חכו שנייה, איך אנחנו נכתוב מינוס, בשפת תכנות? מה אם אנחנו רוצים פעולת חשבון? אז אנחנו כתבנו פה שם משתנה בשם יוזר ניים, או שבעצם כתבנו פה יוזר פחות ניים? לא תקין. אוקיי, מה לגבי פרייס? איך

116
00:55:55,000 --> 00:56:25,000
שאתם כבר יודעים לענות על זה? וואלה, תאמינו לו, תקין. אפשר, כי הרי מותר מספרים בשם משתנה, רק אל תתחילו אותו עם מספרים. ריזולט, אנדוסקור, 2024, וואלה תקין. ואליו, מה זאת לא מילה שמורה? לא בפייתון, היא לא, אפשר. ולבסוף, מה היה אנדוסקור אינט? אני חושב שאתם כבר יודעים לענות על זה.

117
00:56:25,000 --> 00:56:55,000
אין פה שום דבר חריג, תקין. עכשיו, לגבי השמות שאנחנו ניתן למשתנים באמת, תגידו לי, אתם רואים פה שורות של קוד, תתעלמו מזה לרגע שאולי בשלב כזה של הקורס אתם עוד לא יודעים לתכנת כמו שצריך, ואז אתם לא יודעים איך שורות קוד בנויות. נניח שאתם מנסים לקרוא את זה אפילו בתור סתם טקסט באנגלית, תגידו לי,

118
00:56:55,000 --> 00:57:25,000
UIOP, JKL, הדברים האלה אומרים לכם משהו? מה זה? אז תראו, כשאתם כותבים קוד בשפת תכנות, בבקשה, תכתבו אותו בצורה קריאה, עם שמות משתנים שאפשר להבין מהשם שלהם, מה המשמעות שלהם. אז הנה עכשיו אותו קוד, אבל עם שמות משתנים יותר מובנים, ובואו, אני אנסה

119
00:57:25,000 --> 00:57:55,000
להסביר לכם את מה שאנחנו רואים פה. יש לנו כאן משתנה בשם Numerator, עם הערך 5. יש לנו פה משתנה בשם Denominator, עם הערך 3. לאלו מקרים שאולי לא מכירים את המונחים, ה-Numerator זה מונה, בשבר, וה-Denominator זה המחנה, בשבר. אז יש לנו עכשיו מונה ומחנה. אוקיי, אני כבר ישר מבין.

120
00:57:55,000 --> 00:58:25,000
שאנחנו הולכים לעבוד פה על שבר כלשהו. יש לנו פה Numerator Factorial, ו-Factorial זה עצרת במתמטיקה, ויש לנו פה עכשיו לולאה שאומרת עבור ערך i בטווח שמ-1 ועד מונה פלוס 1, שדרך אגב, מאוחר יותר אתם תדעו, אבל בטווח כזה, 1 עד משהו, זה עוצר.

121
00:58:25,000 --> 00:58:55,000
1 לפני, כלומר, מה שיקרה במציאות, שתהיה כאן לולאה, שהיא תעבור לערכים של i בין 1, 2, 3 וכן הלאה, עד וכולל Numerator בדיוק. ואז כשהוא ינסה לעשות פלוס 1 עוד פעם, הוא יגיע ל-Numerator פלוס 1, הוא יעצור פה, ולמעשה ימשיך הלאה. הוא לא יעשה עוד פעם את מה שבפנים. אם מה שאמרתי עכשיו לא מובן, זה בסדר, לאט לאט, אנחנו רק התחלנו את הקורס.

122
00:58:55,000 --> 00:59:25,000
אני פשוט סתם מפיל עליכם עובדה. בקיצור, יש לנו כאן לולאה שרצה בדיוק מונה פעמים, ומה היא עושה בפנים? היא לוקחת את המשתנה הזה, מונה עצרת, ומכפילה אותו ב-i. זאת אומרת, כל פעם מונה עצרת שווה למה שהוא שווה, ואז כל פעם בלולאה זה מוכפל ב-i. יש לנו i שווה.

123
00:59:25,000 --> 00:59:55,000
שמתחיל מ-1 ומגיע עד למונה. אה, אז בעצם זה הגדרה של עצרת. כי מה? מה זה בעצם עצרת? אם אני כותב x עצרת, זה בעצם 1 כפול 2 כפול 3 כפול כפול x. זה עצרת במתמטיקה. זה בעצם המכפלה של המספר עם כל הספרות שבאות לפני.

124
00:59:55,000 --> 01:00:25,000
ופה, למעשה, יש לנו גם לולאה שעושה אותו דבר בשביל המכנה, הדינומינטור. אוקיי, ובסוף יש לנו פה ריזולט שווה מונה עצרת סלש סלש מכנה עצרת. זאת אומרת, חלקי, יש מצב שזה חלקי, כי אני יודע שיש בשפות תכנות שלפעמים צריך לכתוב.

125
01:00:25,000 --> 01:00:55,000
פעמיים סלש בשביל להגיע לחלקי. בקיצור, לי זה מרגיש כאילו מונה עצרת חלקי מכנה עצרת. מה שבטוח, לא כל כך הייתי מבין את זה מהר מהחרבוש הזה. אז בבקשה, תנו שמות עם משמעות למשתנים. כי אז מישהו אחר יכול לקרוא את זה ולהבין, אה, זה מה שזה עושה. ועוד משהו, מה לגבי מספרים? מה לגבי ערכים?

126
01:00:55,000 --> 01:01:25,000
בקוד שלכם, שאתם כותבים אותם שוב ושוב ושוב בצורה מספרית הטהורה שלהם. אז סתם דוגמה, יש לנו פה קוד, אם סטטוס שווה 5, אז מרקט סנט 2. מה זה אומר? אני לא יודע, אתם יודעים? מה זה 5? מה זה 2? מה זה אומר? אוקיי, בואו ננסה קצת לשנות את זה.

127
01:01:25,000 --> 01:01:55,000
בואו ניקח את המספרים האלה שלא אומרים לי כלום, את הבמירכאות מספרי קסם האלו, ונגדיר אותם עם שם. כלומר, נגדיר קבועים, מסג' סנט 5, נגדיר קבוע גם נאם דווייסס 2. עכשיו מן הסתם שבמציאות בשפת תכנות, במקום להגדיר אותם כקבועים, אנחנו פשוט נשתמש במשתנים,

128
01:01:55,000 --> 01:02:25,000
או מה שזה לא יהיה, בקיצור, אנחנו לא סתם נעבוד עם סתם מספרים, אלא אנחנו, אם יש לנו מספרים שיש להן משמעויות מאוד מסוימות, אז אולי אנחנו נעבוד עם קבועים שיש להם את אותו מספר כערך. או במילים אחרות, במקום הקוד הזה שלא אומר לי הרבה, יש עכשיו קוד שהוא קצת יותר מדבר אליי בצורה של שפה. אם סטטוס

129
01:02:25,000 --> 01:02:55,000
הוא המסג' כאילו סנט, מה שזה לא יהיה בהודעה, אז מרקט סנט, לא יודע, מספר הדווייסס. זה כאילו, לא שעכשיו הקוד הזה הרבה יותר מובן מזה, כי זה לא שאנחנו יודעים מה הרקע לסיפור, אבל בתוך ההקשר, זה עדיין יותר מובן, כשאנחנו מדברים פה בקטע של מה המשמעות של הערך, מאשר סתם הערך המספרים.

130
01:02:55,000 --> 01:03:25,000
אז כאילו, תראו מספרים שסתם אנחנו שמים בקוד שלנו לא תמיד אומרים משהו, אז זה מה שקוראים מספרי קסם, כאלה ערכים מספרים, ערכים כאלה, שזה לא ברור מי מה מו, ושהם מופיעים הרבה פעמים, ואנחנו יכולים פשוט להחליף אותם באיזשהו שם טקסטואלי, אז ניתן להם שם משמעותי, ואז נגיד שהשם המשמעותי הזה יהיה יצגת או

131
01:03:25,000 --> 01:03:55,000
ערך. עכשיו תשמעו, זה לא אומר שכל מספר שאנחנו נכתוב בקוד שלנו, אנחנו נייצג אותו בעזרת שם טקסטואלי, כן? לא כל פעם שבא לנו לכתוב 0, אנחנו קודם כל נכתוב בהתחלה של הקוד 0 שווה 0, ואז פשוט בכל הקוד שלנו במקום לכתוב 0, אנחנו נכתוב 0. חוץ מבמקרים הקטנים פה ושם, בקוד איפה שרלוונטי, מתי שכן צריך, ואז אנחנו נגדיר מספרים בעזרת שמות, אבל

132
01:03:55,000 --> 01:04:25,000
לא שמעתם את זה ממני. אז לדוגמה, נניח שמישהו כותב קוד בעבודה שלו, לא יודע, איזושהי תוכנת ניהול שרתים, יש לה אלפי שורות קוד, מה שזה לא יהיה, ובמקרה, יש לו את המספר 5, שהוא היה צריך להשתמש בו בהרבה מקומות בקוד, ואומרים לו, וואלה, הגיע הזמן לשנות את המספר הזה ל-6, כי אני לא יודע מה, יש סטטוס חדש, שתפס מקום לפני,

133
01:04:25,000 --> 01:04:55,000
שווה 5, ואז הסטטוס ש-5 ייצג הוא עכשיו מיוצג לידי 6. אם בקוד שהיה כתוב, הסטטוס הזה לא היה מיוצג בעזרת שם קבוע, שמוגדר פעם אחת בהתחלה של הקוד, אז תחשבו כמה שינויים בקוד היה צריך לעשות. הרבה יותר, פשוט, בהתחלה של הקוד לכתוב נניח, לא יודע, סטטוס פאקט לוסט, שווה 5. ואז,

134
01:04:55,000 --> 01:05:25,000
אנחנו, בזה, משתמשים, הרבה פעמים בקוד, טה-טה-טה, טה-טה-טה, איפה שזה לא יהיה, ואז אומרים לנו, וואלה, תשמרו הסטטוס הזה, צריך לתפוס ערך 6 עכשיו. אז פשוט בהתחלה של הקוד, נשנה את זה ל-6, וגמרנו. וואל, כדאי להכיר, כדאי מאוד מאוד להכיר, זה הופך את הקוד לקריא יותר, ואם צריך לעשות שינוי, שמאחרך אותנו לשנות את הערך

135
01:05:25,000 --> 01:05:55,000
המספרי הזה שמופיע הרבה פעמים, הרבה יותר פשוט לעשות את זה ככה. אז, אוקיי, אבל דיברנו עכשיו על מספרים, מספרים, מספרים, אבל יש עוד סוגים של משתנים. יש תווים, קרקטרס, אז, מה זאת אומרת קרקטרס? כאילו, תסתכלו, אני פותח את notepad, אני כותב טקסט. אז מה? זה קרקטר, זה קרקטר, גם זה קרקטר.

136
01:05:55,000 --> 01:06:25,000
תו, כל אחד מהאותיות האלה, זה בעצם מיוצג בתו. אז, מה זה באמת תו? אז שתדעו, שהקרקטרס האלה, התווים האלו, כל אחד מהם, הוא תופס בדיוק בית, היה לנו 8 ביטים, 1 בזיכרון. אז, זוכרים מה שדיברנו על ייצוג בזיכרון? כן? יש לנו 8 ספרות אפשריות.

137
01:06:25,000 --> 01:06:55,000
כל אחת מהן ספרה בינארית. סופרים את כל האפשרויות ביחד שלנו, ויש לנו ערכים בין 0 ל-255. והנה, כמו שאמרנו, דוגמה לתו, יכול להיות האות a קטנה, ואנחנו מבינים את הייצוג בזיכרון. בזיכרון יהיה לנו ערך בין 0 ל-255. ולמעשה, אם אנחנו כבר מדברים על ייצוג בזיכרון, יש...

138
01:06:55,000 --> 01:07:25,000
כן, יש הרבה דרכים לייצג תווים בזיכרון בעולם, כן? אבל יש דרך אחת שהיא יותר פופולרית מכולם ביחד, וזה התקן שקוראים לו אסקי. וזה תקן שאני בטוח שאתם מכירים. הוא מייצג את האותיות שלנו ואת התווים שלנו במספר בין 0 ל-255, אותיות ומספרים שמיוצגות ככה, הן בכלל מיוצגות בצורה עוקבת. אז לדוגמה, אם ניקח את התו,

139
01:07:25,000 --> 01:07:55,000
a קטנה, שהערך שלו זה 97 פשוט, כאילו, מבחינת איך הוא מיוצג בזיכרון בתור מספר, כן? אז האות b קטנה, היא פשוט תהיה מיוצגת בזיכרון על ידי הערך 98, שזה בדיוק אחד אחרי a. והנה פה, אנחנו רואים כאן את החצי הראשון של תווי האסקי הבסיסיים. אז אתם רואים כאן כל מיני תווים.

140
01:07:55,000 --> 01:08:25,000
מיוחדים עם שמות קצת לא ברורים, אז תראו, תווי אסקי, זה גם מכיל תווים מיוחדים שיש להם משמעויות מסוימות. אבל לפני זה, קודם כל בואו נחפש אותיות. אהה, תסתכלו על זה כאן. a, b, c, d, e, f, g וכן הלאה. אתם רואים את זה? תווים שהן האותיות הקטנות באנגלית. אז אתם רואים אותן מוצגים בצורה עוקבת. ואז אתה רואה פה סוגרה עם סולסלות.

141
01:08:25,000 --> 01:08:55,000
בכלל טילדה. אתם רואים פה תווים אחרים על מקלדת. פה אתם רואים בכלל את האותיות הגדולות באנגלית שמוצגות באסקי עוד לפני האותיות הקטנות. ואתם רואים פה עוד כל מיני תווים פלוס, מינוס, פסיק. בקיצור, עכשיו אתם יודעים, אם לא ידעתם מה עכשיו, שכל תו שאתם בעצם כותבים במקלדת, כותבים ככה בקובץ טקסט.

142
01:08:55,000 --> 01:09:25,000
אז בעצם כל תו כזה שמור בזיכרון של המחשב, עם ערך מתאים, ואתם יכולים לדעת אותו לפי מבט בטבלת אסקי. עכשיו שתדעו, תווים שיש בטבלת אסקי הם לא רק טקסט שאתם כותבים, זה גם דברים שאולי נראים לכם פחות ברורים אליהם. לדוגמה, תסתכלו 32. מה זה פה?

143
01:09:25,000 --> 01:09:55,000
זה רק? לא. הערך אסקי הזה, 32, הוא פשוט מייצג רווח. לחץ עכשיו על רווח במקלדת, עוד פעם, רווח. אז זה שני תווים שהערך אסקי של כל אחד מהם הוא 32. אז בעצם, איפשהו בזיכרון, יש לנו, לדוגמה, אם אני מסתכל על b, רווח רווח, b קטנה.

144
01:09:55,000 --> 01:10:25,000
אז למעשה יש לי פה רצף של זיכרון, איפשהו על המחשב שלי, כרגע ממש, ברגע שאני מקליט את הוידאו הזה. יש לי 98 בזיכרון, ומיד אחריו 32, ומיד אחריו 32. ואגב, אם אני עכשיו עושה Enter, זה שאני עשיתי מעבר שיעורה, גם זה תוו שיש לו ערך אסקי.

145
01:10:25,000 --> 01:10:55,000
והערך אסקי שלו זה 10. אז אלף ליין פיד, זה בעצם ערך אסקי של שורה הבאה בתור בטקסט. אה, ודרך אגב, זה משהו שאני יכול גם לייצג בפייתון. אז נניח שאני באמת פותח פייתון, ואני יכול נניח לכתוב פרינט בסוגריים, ואז בתוך מירכאות, אני רוצה לכתוב פה סתם דוגמה, רגע, אני...

146
01:10:55,000 --> 01:11:25,000
רוצה לכתוב a, b, c, backslash n, a, b, c. מה קרה פה? אז כתבתי את ה-a, b, c הזה, ואתם יודעים איפה הם נמצאים בטבלת האסקי, פה, אז אתם יודעים מערכי אסקי, מה בזיכרון, מה קבוע שכתבתי לזיכרון פה, וכשאני כתבתי כאן backslash n, אני בעצם אמרתי לפייתון, בבקשה תוסיף כאן את הערך אסקי,

147
01:11:25,000 --> 01:11:55,000
10, את ליין פיד, את מעבר שורה, ואז עוד פעם כתבתי a, b, c, ואז פקודה פרינט, שהיא פשוט מדפיסה את הטקסט, אז מה שקרה כאן, הוא באמת הדפיס את הטקסט בדיוק לפי ערכי אסקי של מה שאמרתי לו, הוא הדפיס a, b, c, מעבר שורה, a, b, c, ושם הוא סיים, אז בואו

148
01:11:55,000 --> 01:12:25,000
טיפה נדבר על הערכים של טבי אסקי בצורה יותר ישירה, אז כן, כמו שאתם ראיתם בטבלת אסקי, לכל אחד מהטבים האלה, יש ערך מספרי ספציפי, מאוד ספציפי, ובשפת התכנות שלנו, פייתון, וגם בשפות תכנות אחרות, אנחנו יכולים להתעסק עם הערך המספרי, שמייצג את הטב הזה, בצורה ישירה. בפייתון יש לנו פקוד

149
01:12:25,000 --> 01:12:55,000
בשם rd, בסדר? אני מניח שזה אולי קיצור של אורדר, כאילו הסדר של הטב הזה, אולי, אז הנה תראו שתי פקודות פשוטות. המשתנה c שווה לטב, איך אנחנו מבינים שזה טב? לפי גרש, וגם גרש פה, a גדולה. אז הגדרנו משתנה c שהערך שלו זה הטב a גדולה.

150
01:12:55,000 --> 01:13:25,000
ואז אנחנו עושים פרינט, הערך המספרי של, פסיק, המשתנה הזה, c, הוא, פסיק, הord של c. אגב, עוד לא ליבדנו אתכם תכנות כמו שצריך, ואתם כבר רואים טיפה איך הפקודה פרינט יודעת להרכיב משפט ביחד עם ערך של משתנים, וחלקים.

151
01:13:25,000 --> 01:13:55,000
נפרדים של טקסט, אז כזה התחלנו פה טקסט, עם מרכאות, סיימנו אותו, עשינו פסיק, הבאנו משתנה, עשינו פסיק, הבאנו עוד טקסט, טקסט במרכאות, כן? ועשינו עוד פעם פסיק, והבאנו לפה, פונקציה, על גבי משתנה. מה זה פונקציה? יותר מאוחר בקורס, לאט לאט, אני פשוט, סתם, כאילו, אתם עכשיו ממש בהתחלה

152
01:13:55,000 --> 01:14:25,000
של הקורס, אתם תתעסקו עם דברים, לפני שאתם תלמדו אותם בצורה מסודרת, כי לפעמים זה שאלה של צ'קינג אנד דיאג, מה יבוא קודם? מה להראות לכם קודם? אז וואלה, דוגמאות פרקטיות קודם, זה אחלה בשביל אינטואיציה לאחר כך. בקיצור, אז כלומר הערך המספרי של התו A, שאתם רואים, אנחנו נכנסנו פה בפרינט ישירות, את המשתנה הזה, שהערך שלו זה פשוט התו.

153
01:14:25,000 --> 01:14:55,000
ואז הבאנו פה את ערך המספרים. ועכשיו בואו נעשה את זה הפוך, ההפוך לגמרי. נניח שאנחנו נשים במשתנה את המספר 66, שזה דרך אגב מיד אחרי 65. ועכשיו אנחנו אומרים, הערך התווי של המספר הזה, הוא ה-CHR של המשתנה שהוא מספר, כלומר, הקרקטר שהוא הערך המספרי.

154
01:14:55,000 --> 01:15:25,000
והמטפסה הזאת באמת נותנת לנו, the character value of 66 is בגדולה. אז אני מניח שאם אתם תסתכלו על כל זה, תסתכלו קצת על טבלת האסקי, אתם תקבלו לפחות אינטואיציה. וכמובן, כמו שהראיתי לכם מקודם, לגבי תווים מיוחדים, שאנחנו רוצים להדפיס אותם בפייתון, אבל אנחנו צריכים לכתוב אותם בצורה מיוחדת, אז יש לנו באמת את backslash על המקלדת, שזה לא...

155
01:15:25,000 --> 01:15:55,000
אני אראה לכם, נניח אני כותב פה שלוש חלקי ארבע, זה סלאש רגיל, אבל יש לי כפתור אחרת על המקלדת שאני קורא לו backslash, זה זה. אז backslash n, זה בעצם מייצג את התו של מעבר שורה. יש גם backslash t, אם אני רוצה לכתוב tab, מה זאת אומרת tab? בלה בלה בלה, tab בלה בלה בלה, כן? או

156
01:15:55,000 --> 01:16:25,000
backslash backslash, אם אני רוצה לכתוב, כאילו, את התו backslash בטקסט. למה אני צריך לכתוב פעמיים backslash? כי ה-backslash הראשון גורם לפייתון לחשוב שאני בא לכתוב איזשהו תו מיוחד. אז לפעמים צריך להקדים את התו backslash בבקסלש, כדי להגיד לפייתון, אני רוצה להדפיס backslash. נשמע מסובך? בורחים אבינו לעולם התכנות. יש הרבה מקרי קיצון.

157
01:16:25,000 --> 01:16:55,000
כאלה, אבל לאט לאט. מה לגבי גרש? איך אנחנו נדפיס גרש? יש הרבה דרכים, האמת, לעשות את זה, כן? אנחנו יכולים להדפיס גרש בתוך מכרוזת, שמכרוזת זה לא תו אחד, זה כבר רצף של תווים, ואז פייתון ידע להתמודד עם זה, או אנחנו יכולים לעשות איזושהי תסקוטינג backslash, אבל עזבו, בואו נדבר על דברים כאלה פעם אחרת. כן, כן, אנחנו יכולים לעשות הדפסות.

158
01:16:55,000 --> 01:17:25,000
לדוגמא פה, יש לנו מסטאר וורז פרק 3, שאובי וואן צץ על המסך ואומר, הלו דר. אז הנה, אתם רואים פה, אובי וואן צץ, נקודתיים, backslash n, backslash t, הלו דר. אז גם עשינו מעבר שורה, וגם הוספנו תא בלעד מסך, וזה עובד. ווא, סוף סוף הגענו לתרגילים, אבל זה בסדר, בתרגול הראשון התרגילים יהיו די פשוטים.

159
01:17:25,000 --> 01:17:55,000
בואו נתחיל, בואו נכתוב קוד שמגדיר משתנה ch, איזושהי אות קטנה לבחירתנו. זאת אומרת, אנחנו פשוט נכתוב ch שווה איזשהו קרקטר, זה מה שאנחנו נעשה. ואנחנו רוצים שהקוד שלנו ידפיס את הגרסת אות גדולה, של אותה אות קטנה. אז זה דוגמא, אם כתבנו ch שווה a קטנה, ואנחנו נרצה לעשות פרינט,

160
01:17:55,000 --> 01:18:25,000
שיביא לנו את a גדולה, אבל זה לפי האות הקטנה שבחרנו. אז תראו, איך אנחנו יכולים לעשות את זה בצורה די פשוטה? אנחנו צריכים להיעזר בעובדה שקודם כל, אותיות, אנחנו יודעים שאותיות הן עוקבות אחת אחרי השנייה, גם בגרסה גדולה, גם בגרסה קטנה, אז זה משהו שעושה את זה טריוויאלי יותר. אבל אם למשהו אחר,

161
01:18:25,000 --> 01:18:55,000
אנחנו יודעים באיזה ערך אסקי מתחילות האותיות הקטנות, ואנחנו יודעים באיזה ערך אסקי מתחילות האותיות הגדולות, אז אם אנחנו ניעזר בהפרש שבין איך האסקי של האותיות הקטנות ואיך האסקי של האותיות הגדולות, אז משם והלאה, הדלתא, נקרא לזה, ההפרש,

162
01:18:55,000 --> 01:19:25,000
שבין האות שאנחנו קיבלנו לבין כאילו התחלה של הספיר האותיות, כאילו זה לא ישתנה. או מה שאני מנסה להגיד, מה שאני מנסה להגיד, זה שנניח אנחנו מגדירים אות, סתם דוגמה, די קטנה, אז אנחנו רק נחשב את ההפרש הקטן בין הערך המספרי של האות הקטנה שקיבלנו,

163
01:19:25,000 --> 01:19:55,000
ובין הערך המספרי של האות A קטנה, אנחנו פשוט נקבל את ההזזה של האות הקטנה הזאת מתחילת הספירה של אותיות. אז תסתכלו, נניח, הנה איך האסקי של A קטנה, נניח שקיבלנו את האות D קטנה, אנחנו נרצה מזה להדפיס את D גדולה, אז קודם כל, אנחנו נרצה להגיד שאות A קטנה,

164
01:19:55,000 --> 01:20:25,000
אנחנו רוצים לדעת, אנחנו רוצים להרכיב בעצם את הערך האסקי של D גדולה, איך נעשה את זה? קודם כל, אנחנו רק רוצים לדעת מה ההפרש בין הערך האסקי של אות שקיבלנו, ובין הערך האסקי של A קטנה, של תחילת הספירה, אנחנו עושים באמת את המאה הזה, פחות 97, נקבל 3, למה? כי 0, 1, 2, 3, או 0, 1, 2, 3.

165
01:20:25,000 --> 01:20:55,000
3, נכון? אז אנחנו בעצם מחשבים את ההפרש הזה רק, ואנחנו נבנה בעזרת הערך האסקי של זה, נוסיף לו את ההפרש הזה, אז בעצם הערך האסקי של זה, עוד 1, עוד 2, עוד 3, או, וזה מביא אותנו לאות שחיפשנו. אז זה הפתרון של השאלה הראשונה, אנחנו פשוט בונים את האות שלנו.

166
01:20:55,000 --> 01:21:25,000
קודם כל, קיבלנו את התו שאנחנו רוצים להפוך אותו, אז רגע, נחשב את ההפרש שמייצג את האות שקיבלנו, עם ההפרש הזה, נוסיף אותו ביחד עם הערך האסקי, ממש את המספר שמייצג את A גדולה, נוסיף אותו עם ההפרש הזה, ואז נקבל מזה את התו שזה מייצג.

167
01:21:25,000 --> 01:21:55,000
בבקשה, קיבלנו בדיוק את מה שחיפשנו, הגרסת O גדולה של מה שקיבלנו, היא גרסת O גדולה שחישבנו, אז אולי זה נראה טיפה מסובך, אני רק אחזור את זה שוב, נניח שקיבלנו איזשהו תו, לא יודע, נניח G קטנה, קיבלנו את זה, אז אנחנו בסך הכל ניקח את זה,

168
01:21:55,000 --> 01:22:25,000
נעשה את האות שקיבלנו, פחות A קטנה, והתוצאה שלנו תהיה רק ההפרש בין זה לזה, וההפרש הזה נותן לנו בעצם כמה קדימה מ-A קטנה, או כמה קדימה מ-A גדולה, נצטרך ללכת כדי להגיע לאות, ואנחנו נבנה את הקרקטר מ-0. אנחנו נגיד, האות גדולה שלך, היא, הערך האסקי,

169
01:22:25,000 --> 01:22:55,000
של זה, ועוד ההפרש שחישבנו לך מקודם, פה זה היה G פחות A, וזהו, ונגיע לערך האסקי שרצינו, אז אם לא הבנתם, תנסו לקרוא את זה שוב טיפה, או שתנסו רק לחזור קצת, אבל תבינו, זה בעצם מה שעשינו, פשוט חישבנו את ההפרש שהיינו צריכים בשבילו, מה שנקרא ההסת, ההופסט, וחישבנו את האות הגדולה, בעזרת בסיס, ועוד הסת,

170
01:22:55,000 --> 01:23:25,000
וזהו. עכשיו בפייתון יש נוחות מסוימת, כי פייתון יש לו גם כמה פונקציונליות נוספות מובנות כאלה, מעין פקודות, פונקציות כאלה, שבסופו תכנות אחרות אין לנו אותן בצורה בילט אין, ואחת מהן היא פקודות מינימום ומקסימום, שהן פשוט מחזירות לנו את המינימום בין שני הערכים, או את המקסימום בין שני הערכים.

171
01:23:25,000 --> 01:23:55,000
זאת אומרת, אם בתור פקודה אנחנו נריץ מינימום שבין 4 ל-3, התוצאה של זה תהיה 3, או נריץ מקסימום שבין 4 ל-1, אנחנו נקבל את 4. זה יכול להיות נחמד, זה יכול להיות שימושי. אז לדוגמה, שואלים אותנו, בואו נכתוב קוד שמגדיר שלושה משתנים ABC, ומדפיס את המקסימום מבין השלושה משתנים.

172
01:23:55,000 --> 01:24:25,000
עכשיו, מגבלה קטנה, פקודת המקסימום אפשר לקרוא לה רק עם שני פרמטרים, כלומר, רק שני מספרים, אז אנחנו לא נוכל לכתוב מקס A פסיק B פסיק C, כאילו זה לא ילך. אז אתם מסתכלים על זה, אומרים לכם, אפשר רק שניים, אתם אומרים לעצמכם, אוקיי, אז אולי פשוט נעשה כזה את המקסימום של

173
01:24:25,000 --> 01:24:55,000
בין A ו-B, ואת כל זה נעשה מקסימום. נעשה את המקסימום של המקסימום בין A ו-B לבין C. ואנחנו יכולים לעשות את זה, כן? אנחנו יכולים לקרוא לפקודה על תוצאה של פקודה. לגמרי אפשר לעשות את זה. אז הנה, הגדרנו שלושה משתנים שונים, הכי מספרים.

174
01:24:55,000 --> 01:25:25,000
ונגדיר עכשיו את המקסימום שביניהם, שזה באמת כמו שאמרנו, המקסימום שבין המקסימום שבין A ו-B, ובין C. וזה די מסביר את עצמו. מה אוקיי? ועכשיו, תרגיל אחרון, בואו טיפה נתחכם, קצת. עכשיו, אנחנו רוצים גם אותו דבר, כמו שאתם רואים, השאלה עצמה לא השתנתה, אבל הפעם אסור לנו להשתמש בפונקציית מקסימום.

175
01:25:25,000 --> 01:25:55,000
ומצד שני אומרים לנו, בואו תניחו שמותר הפעם להשתמש בפונקציית מינימום עם שלושה פרמטרים. היה לנו לחסוך בקריאה של פקודות. רגע, מה עוזר לנו מינימום? אנחנו רוצים לחשב מקסימום. אז ככה, אנחנו יודעים מה זה לעשות מקסימום של מספרים חיוביים, אבל מה אם אנחנו עושים פה מינימום?

176
01:25:55,000 --> 01:26:25,000
של מספרים שליליים. אוקיי, בסדר, אבל יש לנו פה מספרים חיוביים נניח, לא? אז מה יקרה אם אנחנו נעשה באמת מינימום על המינוס של המספרים? אז תחשבו על זה, המינימום שאנחנו נמצא, יהיה המספר שיהיה הכי קטן, אבל שעשינו מינוס על המספרים, אז מינוס,

177
01:26:25,000 --> 01:26:55,000
על המספר הכי גדול, יהיה בעצם המספר הכי קטן. אז ניקח את המינימום הזה, נעשה לו מינוס, ולמעשה, אנחנו נגיע בדיוק למה שרצינו, את המקסימום שבין כולם. כי תחשבו, מינוס A זה מינוס 4, מינוס B זה מינוס 1.1, מינוס C זה מינוס 9, אז זה בפירוש המספר הכי קטן, נכון? מינוס 9. אז אנחנו בוחרים אותו, זה המינימום,

178
01:26:55,000 --> 01:27:25,000
ועושים לו מינוס, אז המספר המקסימלי זה מינוס, מינוס 9, ובמתמטיקה, מינוס מינוס זה פלוס. איזה כיף זה, בתכנות אפשר ממש להשתגע. ואגב, שתדעו, מה אם אתם רוצים, סתם דוגמה, לכתוב קוד שנשמע לכם פשוט, יש לכם איזושהי מכרוזת, רצף של טקסט,

179
01:27:25,000 --> 01:27:55,000
ואתם רוצים לבדוק אם רצף קטן יותר של טקסט, נמצא בו. אז בפייתון, זה טריוויאלי. אתם כותבים אם, סתם דוגמה, אתם רוצים למצוא במחוזת A, B, C, D, אם B, C מופיע שם איפשהו. אז בפייתון אתם פשוט כותבים, באמת, זה מרגיש לי יותר כמו אנגלית פשוטה, מאשר קוד של תכנות. אז אתם כותבים אם, B, C קטן, נמצא איפה

180
01:27:55,000 --> 01:28:25,000
שהוא ב-A, B, C, D קטן, אז תדפיס מופיע, אחרת תדפיס לא מופיע. יופי. אז בשפת התכנות C, שאתם לא תלמדו עכשיו, אלא אולי בעתיד, אבל שהיא הייתה פעם שפת התכנות שנלמדה במבוא למדעי המחשב, היינו צריכים לכתוב תוכנה קצת יותר מסובכת, שהיא טיפה פחות קריאה לעין אנושית. היינו צריכים להגדיר

181
01:28:25,000 --> 01:28:55,000
ממש את המשתנים האלה מטיפוס מחוזות, היינו צריכים להכריז על משתני לולאות, ועל, לא יודע, משתנה של האם מופיע, לא מופיע, והיינו צריכים לעשות לולאות שעוברות תו, תו, עד שכל מחוזת הייתה מסתיימת, והיינו צריכים לבדוק אם התו הנוכחי שאנחנו מסתכלים עליו, לא מתאים לתו שאנחנו בודקים. בקיצור,

182
01:28:55,000 --> 01:29:25,000
אני לא יודע אם זה לטוב או לרע, אבל שפת התכנות הראשונה שלכם בחוג למדעי המחשב, החל מחורף 2024, תדרוש קצת פחות התעסקות בדברים הפשוטים ביותר. האם זה טוב? האם זה רע? מי יודע? אבל זאת המציאות שלנו. אז גבירותיי ורבותיי, תודה רבה שבאתם והקשבתם להקלטה של התרגול הראשון, אני מקווה שזה עזר לך.

183
01:29:25,000 --> 01:29:27,000
נתראה בהמשך?

