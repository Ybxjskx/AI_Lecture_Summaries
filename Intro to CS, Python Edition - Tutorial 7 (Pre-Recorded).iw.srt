1
00:00:00,000 --> 00:00:30,000
היי, ברוכים הבאים לתרגול השביעי של הקורס מבוא למדעי המחשב. הנושאים של התרגול היום יהיו רשימות דו-ממדיות וגם רשימות סדורות, או tuples כפי שנכיר באנגלית, אז בואו נתחיל. מה זה בכלל רשימה דו-ממדית? אני אגיד לכם בצורה הכי פשוטה, תחשבו על רשימה שהאיברים שלה הם בעצמם רשימות, אז לדוגמה, אנחנו נתחשב

2
00:00:30,000 --> 00:00:58,800
נגדיר את המשתנה A בפייתון להיות רשימה והאיברים של הרשימה הזאת יהיו הרשימה עם האיברים 1, 2 כאינטג'רים והרשימה עם האיברים 3 ו-4 כאינטג'רים. אז איך זה נראה? איך ניגש לזה? קודם כל איך שזה נראה, אני חושב שזה נראה בדיוק כמו מה שזה יכול להיות, מטריצה דו-ממדית.

3
00:00:58,800 --> 00:01:28,400
הרשימה הראשונה של 1, 2 תחשבו עליה בתור השורה הראשונה של המטריצה והרשימה השנייה של 3, 4 תחשבו עליה בתור השורה השנייה. זאת אומרת שאם אני עכשיו בא לפתוח נוטפד, לא פלוס פלוס, אני יכול להגיד 1, 2, 3, 4. אתם רואים, זה בסך הכל מטריצה עם שתי שורות.

4
00:01:28,400 --> 00:01:34,680
אני חושב שזאת צורה מאוד אינטואיטיבית לחשוב על זה, אז בואו נחשוב על זה ככה, למה לא?

5
00:01:34,680 --> 00:01:41,440
עכשיו איך ניגש לתאים שבתוך משתנה שהוא רשימה עם יותר מממד אחד?

6
00:01:41,440 --> 00:01:58,180
קודם כל הנה צורת הגישה שאנחנו מכירים, אנחנו כותבים את המשתנה, ואז אנחנו כותבים אופרטור סוגריים רובעות, כלומר גישה דרך אינדקס, אז נגיד a באינדקס 0.

7
00:01:58,180 --> 00:02:14,860
מה זה ייתן לנו? אז שימו לב, לרשימה a יש בדיוק שני איברים, והאיבר שלה, הראשון שלה, שהוא באינדקס 0, הולך להיות הרשימה 1-2.

8
00:02:14,860 --> 00:02:38,260
אז עשינו גישה אחת לרשימה דו-ממדית, וזה החזיר לנו במרכאות שורה, אבל אני אומר לכם, תראו, בסופו של דבר, גם רשימות עם לא יודע, אין ממדים, אתם עושים גישה אחת כזאת, אתם פשוט ניגשים לאיבר הראשון של הרשימה.

9
00:02:38,260 --> 00:03:08,180
עכשיו, זה פשוט תלוי איך הרשימה מוגדרת, כמה רשימות בתוך רשימות בתוך רשימות יש לה, אבל בסופו של דבר, זה תמיד יעבוד לפי איך שזה אמור לעבוד. a באינדקס 0 ייתן לכם את האיבר באינדקס הראשון. פשוט, בהקשר של מטריצה דו-ממדית, זה בעצם לקבל את השורה הראשונה. בסדר? אז אם כבר דיברנו על מטריצה דו-ממדית, נניח ש...

10
00:03:08,180 --> 00:03:38,180
שאנחנו רוצים במטריצה במרכז של A, נניח שאנחנו רוצים במטריצה A את האיבר שנמצא שורה 2 עמודה ראשונה, איך ניגש בפייתון? אז די הגיוני, מה נעשה?נלך ל A באינדקס 1 כלומר A האיבר השני שלך שזה הרשימה 3 4 ואז מיד אחרי זה שוב נכתוב את אופרציה

11
00:03:38,180 --> 00:04:08,180
סוגריים מרובעות, ופה אנחנו בעצם עושים גישה על גבי גישה, או יותר נכון, אני לוקח את העכבר בימין ל�שמאל, זאת אומרת גישה על גבי גישה, אז אני ניגש בהתחלה לאיבר באינדקס 1 של a, אז זה תת הרשימה הזאת, ואז אני אומר גישה בעצמך לאינדקס 0 שלך, אז בעצם אני ניגש לאינטג'ר הזה, וזה גם מה שאני אדפיס, את ה-intg'ר שלו.

12
00:04:08,180 --> 00:04:38,100
אינטואיטיבי, לא? אנחנו פשוט כותבים את שני אינדקסים, אינדקס שורה, אינדקס עמודה. אז אם אנחנו כבר מבינים את הרעיון הזה, מה יקרה כשננסה עם ה-a הנתון הזה, להדפיס a באינדקס 0, אינדקס 2? אז a אינדקס 0, אנחנו כבר יודעים מזה, זה הרשימה 1-2, אבל אם פה נעשה גישה אינדקס 2, נקבל שגיאה.

13
00:04:38,100 --> 00:05:07,500
למה? אינדקס out of bounds. זאת אומרת, זה לא קיים, אז ברור שזה לא יעבוד. אני יכול עכשיו לפתוח לכם טרמינל פייתון, ואתם תראו שמה שלא יעבוד, לא יעבוד. הנה, נגדיר לעצמנו את a בפשטות ובמהירות, ועכשיו נעשה פרינט של a באינדקס 0, אינדקס 2. הופה.

14
00:05:07,500 --> 00:05:37,500
list index, out of range. זה. לא קיים. מגניב. איך אנחנו יכולים ליצור כזאת מטריצה בקוד? סתם דוגמא. נכתוב קוד שיוצר ומתחיל רשימה דו מימדית, או אז מטריצה, של אפסים, מתוך לשתיים משתיים. זאת אומרת אנחנו רוצים רשימה של שתי שורות שתי אמודות, והכל אפסים. אז אותו ערך.

15
00:05:37,500 --> 00:06:05,740
וראינו בתרגולים קודמים שאנחנו יכולים לשרשר ביטויים כמו רשימות או מחוזות בעזרת אופרטור כפל. אז תראו קטע, אנחנו נבנה רשימה עם אי בר 0, זה הסוגריה מרובעות כאן, ושרשר את זה ב-2. זה ייתן לנו רשימה שהערך שלה זה 0 פסיק 0. אחלה.

16
00:06:05,740 --> 00:06:29,660
את כל זה נעטוף בסוגריים של רשימה, ואז נשרשר את זה פעמיים. וזה בעצם הדרך שבה אנחנו בונים רשימה דו-ממדית של 0,0,0,0. זאת אומרת רשימה שיש לה שני איברים, וכל אחד מאותם שני איברים זה בעצמם רשימה שהאיברים שלהם זה 0 פסיק 0.

17
00:06:30,660 --> 00:06:36,500
אז שימו לב לאיך שהסוגריים המרובעים כתובות כאן.

18
00:06:36,500 --> 00:06:49,540
הסוגריים המרובעים הכי קטנות כאן מסביב לאפס הן מה שהופכות את האפס הזה לא להיות לאינטג'ר, אלא לרשימה שיש לה עבר אחד שהוא אינטג'ר.

19
00:06:49,540 --> 00:06:59,560
את זה אנחנו משרשרים פעמיים, ונקבל בעצם רשימה עם שני איברים, ואז את כל זה בדיוק כמו ששים אפס קטן,

20
00:06:59,560 --> 00:07:29,460
נקיף את כל זה בסוגריים מרובעים, וזה ייתן לנו רשימה שהאיבר היחיד שלה זה רשימה של 0-0, כל זה שאושר פעמיים ייתן אותה תוצאה סופית. וזה חשוב מאוד, סדר הדברים שאמרתי כרגע, זה מסביר לנו איך זה עובד גם בפייתון. אוקיי, על פניו זה פתרון שעובד, היי? אז בואו נחקור את זה קצת.

21
00:07:29,460 --> 00:07:59,460
בואו נסתכל איך זה מוגדר בזיכרון. אם היינו שים לדברים פה אופרטור ID ל-איזה מסקנות היינו מגיעים? היינו מגיעים לזה - היינו מגיעים לתובנה ש-A, כמשתנה, מצביע לאובייקט עם ID כך וכך ואובייקט הזה זה באמת אובייקט הרשימה הגדולה, רשימה גדולה. שני עברים, כל אחד מאותם שני עברים זה רשימה בעצמם. אבל מה?

22
00:07:59,460 --> 00:08:14,920
תסתכלו, אותן תתי רשימות מצביעים לאותו אובייקט רשימה. כלומר, שני האיברים השונים כאן ברשימה, הם מצביעים לאותה רשימה בדיוק.

23
00:08:14,920 --> 00:08:29,580
וטוב בסדר זה שכל 0 מצביע לאותו אובייקט 0 זה כבר ראינו שאינטגר זה אימיוטבול וגם שאינטגרים בתחום קטן בין מינוס 5 למטה 56 פייתון יגיד.

24
00:08:29,580 --> 00:08:58,940
אותו אובייקט יחסוך בזיכרון אבל עדיין אתם רואים את זה שני חצים שמביאים לאותו אובייקט כאן וזה רשימות כן? לא משהו שהוא אימיוטבול אלא רשימות מיוטביליות לחלוטין. זה עלול להיות בעייתי בשבילנו. למה? למה זה שאופרטור כפל הוא לא שכפל לנו את האובייקט רשימות אלא שכפל רק כתובת למה זה יהיה בעיה?

25
00:08:59,940 --> 00:09:13,840
תסתכלו, נניח שאנחנו רצינו לקחת את הרשימה הזאת ואנחנו רצינו ללכת לעיוור הראשון ברשימה A, אינדקס 0.

26
00:09:14,340 --> 00:09:21,700
או, אם אתם רוצים לחשוב על זה, במטריצה הדו-מימדית הזאת של אפסים, אנחנו רוצים לשנות את העיוור שהוא שמאלה למעלה.

27
00:09:22,280 --> 00:09:51,540
אם אני פותח לכם בנוטפל באמת, אז תסתכלו, 0, 0, 0, 0, נניח שאני רציתי לעשות את השינוי הזה, בסדר? לא שינוי גדול. מה הבעיה? בגלל שפייתון ראה את הרשימה הזאת בתור אותה רשימה כמו זאת, אז זה שאני אנסה לעשות את השינוי הזה, בעצם רשימה אחת, אובייקט רשימה אחת, שיופיע לי פעמיים.

28
00:09:51,900 --> 00:10:21,240
זה מה שאני אראה. אז כמו שאתם רואים, האחד הזה מוחלף לי בשתי תתי הרשימות האלה. ווואלה, זה לא מה שרצינו. למעשה, אנחנו נוכל להיעזר באופרטור איז כדי להגיד את אותו דבר כמו מה שראינו בשקופית הקודמת. אז אם נגיד כאן, עבור הרשימה A, איך שגדרנו אותה, A באינדקס 0, איז A באינדקס 1, התשובה היא כן, זה ייתן True.

29
00:10:21,240 --> 00:10:34,740
ומה יקרה אם נעשה כזה דבר? נגיד ש-a ב-index 0, זאת אומרת, הרשימה הזאת, נגיד שעכשיו ata תהיה שווה ל-1.

30
00:10:34,740 --> 00:10:47,060
אז בעצם אנחנו לוקחים רשימה ומחליפים אותה ב-integer, 1. אז הרשימה a הולכת להשתנות ואז a ב-index 0 כמובן שהוא לא יהיה a ב-index 1.

31
00:10:47,060 --> 00:10:49,620
אז אתם רואים כאן את ההבדלים, נכון?

32
00:10:49,620 --> 00:11:18,480
או אפילו אם אתם לא מאמינים, למדתי קצת טריק מהרצאות בדילי, ואוספתי אופציה להריץ קוד פייתון בצורה אינטראקטיבית, את ה-a ג'ופיטר קטנים. אז איפה הקוד הרלוונטי? הנה הוא. אתם רואים כאן? יש לנו את ההגדרה של a, ואז את שאלת ה-is, ואז עושים שינוי כאן. אז בואו נריץ את הסל הזה ותראו מה נקבל.

33
00:11:18,480 --> 00:11:46,540
קודם כל, ההגדרה של a בצורה מקורית, השאלה a ב-index 0 is a ב-index 1, התשובה היא true, ואז שינינו את a לפי אינדקס 0, כלומר לקחנו את זה והחלפנו את זה ב-1. אז מן הסתם ש-integer הוא שונה מרשימה, ונקבל false. אז לפחות עד כאן זה עבד לנו.

34
00:11:46,540 --> 00:12:16,540
אז שימו לב להבדל הזה. ועכשיו עולה שאלה מתבקשת: אוקיי, אם אופרטור כפל לא יהיה הפתרון בשבילנו כדי לבנות רשימה רב-מימדית, כך שהרשימות יהיו שונות, גם אם ערכים יוזהים, מה נעשה? יש אלטרנטיבות. קחו אלטרנטיבה. List Comprehension, אתם זוכרים את הטריק, את הקלי החביב הזה? שנותן לנו לבנות רשימות מ 0 בצורך החמה?

35
00:12:16,540 --> 00:12:46,540
אז הנה דוגמא, נגדיר קודם כל בפנים זה דומה למה שראיתם מקודם, נגדיר רשימה איבר יחיד 0, נשרשר את זה פעמיים, כלומר רשימה של 0 פסיק 0 אבל עכשיו תראו מה אנחנו עושים, כזה דבר for מה שזה לא יהיה בריינג' שבין 0 ל-1 כולל, או במילים אחרות אנחנו ניקרא איתנו פה רשימה של 0 ונקרא להרתקש של 1 ונקרא להתקש של 9, ונגמר את הדבר הזה ונשקר את זה במילים האחרות ונמחיא אנחנו לשחק שאתה  לא יודע מה זה באמת צריך להצליח לא לנו להתקשר אליו זה לא יכול להיות שאתה צר

36
00:12:46,540 --> 00:13:10,520
כל זה, זאת אומרת ניקח את הקונספט הזה של רשימה של 0-0 פעמיים, בנפרד וניצור מזה רשימה. נקרא לרשימה הגדולה הזאת A. אז גם זה אפילו כתבתי לכם כאן בקצרה, בכובד סניפט אפילו בצורה קצת יותר כזאת יות,ר מובנת.

37
00:13:10,520 --> 00:13:39,980
נגיד את הרשימה 0 פסיק 0, for מה שזה לא יהיה בריינג' שבין 0 ל-1 כולל. ומזה אנחנו נבנה רשימה נקרא לה A ואז נשאל האם שורה הראשונה היא אותו אובייקט בדיוק בזיכרון כמו שורה השנייה. אז נריץ את זה. והנה הרשימה A כמו שרצינו אותה, והפעם הרשימה הזאת שונה בזיכרון מהרשימה הזאת.

38
00:13:39,980 --> 00:14:09,660
אז נקבל פולס לשאלת האז. אז הנה כבר משהו שעבד לנו. איזה גיף. עכשיו בואו נסתכל על פעולות ברשימות. עכשיו רשימות שהן רב מימדיות, סתם עוד מה. אם יש לנו ליסט כזה, תראו, ליסט שהאיבר הראשון שלו, תחשוב על זה ככה, שורה ראשונה, שיש לה רק איבר אחד. זה כאילו שבניתי לכם רשימה.

39
00:14:09,660 --> 00:14:39,640
שנראית ככה. אבל אתם מבינים, זה כאילו שניהם רשימות. גם זה רשימה וגם זה רשימה. זה התוכן של ליסט כרגע, בדוגמה שאתם רואים פה. ועכשיו אני אומר, ליסט במקום אפס, אני אעשה לו אפנד 2, ואז מה יקרה? זה אפנד ואני מביא את האיבר שאני רוצה.

40
00:14:39,640 --> 00:15:08,560
להוסיף אותו לרשימה, אז באמת ישנה לי את הרשימה להיות כזה דבר. כאן. ואז בעצם כל זה יהיה כל הרשימה ליסט הגדולה. כן? אז מה שהראיתי לכם פה בנוטפד, זה גם ייראה כאן. הנה אני יכול עכשיו להפריץ את הסל הזה, והנה השינוי. אנחנו יכולים דרך אגב.

41
00:15:08,560 --> 00:15:38,560
כמו שאתם ראיתם לקחנו רשימה, שימו לב, list באינדקס 0 זה הרשימה שהאיבר היחיד שלו הוא 1, ולזה אנחנו עשינו append עם אינטג'ר, כלומר כשאנחנו עושים append אנחנו בתוך הסוגריים עגולות שמים את האיבר שאנחנו רוצים להוסיף אותו לרשימה, מי מונע מאיתנו לגשת לרשימה ולעשות לה append?

42
00:15:38,560 --> 00:16:07,380
ולהוסיף רשימה. הייתם תסתכלו, הנה ליסט רשימה והאיברים שלה זה רשימות, אז אנחנו נוכל לעשות אפנד ולשים בפנים רשימה וזה יתווסף בתור איבר נוסף לכל הרשימה. ועכשיו יש לנו מטריצה שהיא שלוש שורות ושתי עמונדות, קטע כזה, וזה עובד?

43
00:16:07,380 --> 00:16:29,740
עכשיו אנחנו יכולים לעשות גם דברים כמו חיבורים, שירשורים, לא? אז תסתכלו לדוגמא ליסט 1 כאן וליסט 2 כאן. אתם רואים שהם שתיהן נראות בעצם כמו מטריצות דו-ממדיות. אז אם אנחנו נדפיס את השירשור ביניהם, איך זה יראה? אז בואו נראה.

44
00:16:29,740 --> 00:16:59,740
ליסט אחד זה פשוט רשימה שיש לה שני איברים, רשימה של 1-2 ורשימה של 3-4 וגם ליסט 2 יש לה בדיוק שני איברים, אז השרשור כאן הוא בעצם עובד בדיוק באותה צורה שאתם כבר הכרתם בפייתון. עכשיו יהיה לנו רשימה אחת עם ארבעה איברים, שתי הרשימות הראשונות ושתי הרשימות הבאות, אז אם אתם רוצים להסתכל על זה, זה שאני עכשיו אכתוב פה באמת את ה

45
00:16:59,740 --> 00:17:15,340
עיוורים הבאים בתור, כן, איך זה יראה? זה ראה פשוט כמו מטריצה של ארבע שירות, שתי עמודות, כי ככה הגדרנו את זה.

46
00:17:15,340 --> 00:17:29,540
זה היה לי סט אחד, זה לי שתיים, אבל אתם מבינים את הקטע, נכון? זה שאתם יכולים לקחת את הרשימה הזאת ולפרוס אותה כמטריצה דו-מימדית, זו חטאה שלכם! בסופו של דבר זה רשימה של ארבעה עיוורים.

47
00:17:29,540 --> 00:17:44,540
כאשר כל איבר בעצמו הוא פשוט רשימה. זה הקטע. עד כמה שזה יכול להישמע מבלבל, למעשה זה פשוט. אנחנו עובדים כאן לפי חוקיות מוגדרת.

48
00:17:44,540 --> 00:18:13,740
אוקיי, מה יקרה אם נעשה כזה דבר? נגדיר ליסט אחד שהיא רשימה, שני איברים, כל איבר הוא רשימה של איבר יחיד, אפס, ונגדיר שילשור שלוש פעמים של הדבר הזה. ואז אנחנו נרצה לשנות, שימו לב, אינדקס אפס, אפס. כלומר, באיבר הראשון, אינדקס הראשון.

49
00:18:13,740 --> 00:18:42,740
נרצה לשנות את האינטג'ר, ואז אנחנו נרצה להדפיס את זה. מה יקרה? מה נקבל? אז בואו נריץ את זה ונגלה. נגדיר באמת, ליסט אחד שווה לאפס, פסיק, אפס, אבל הם בעצמם בתוך רשימות, כמו שאתם רואים כאן. ועכשיו נגדיר ליסט שתיים שווה ליסט אחד שילשור שלוש פעמים.

50
00:18:43,680 --> 00:18:50,340
נעשה את השינוי המיוחד, נגדיר שבאינדקס 0,0 זה יהיה שווה 1 ולבסוף נדפיס את לי 2

51
00:18:53,660 --> 00:19:32,260
אני סקרן לדעת מה אתם חושבים שיקרה, נריץ ונגלה? אוקיי. אז ה-אם זה הפתיע אתכם, אני רוצה לקוות שלא- מה שקרה- זה לא היה טוב כבר- רציון 13 מעלות לתפילה והוא לא היה בריא הוא קמה לה בכלל את החברה He nets הזה לא להחזיק להם, את זה לדעתו. והחשוב להם זה בשביל להם לשתף אותך או משהי שטוע בין מה שאתם חושבים לבחירה שלנו, רק להחזיק את שאתה לדעתן הא

52
00:18:53,660 --> 00:19:23,660
מה אתם חושבים שיקרה, נריץ ונגלה, אוקיי, אז האם זה הפתיע אתכם, אני רוצה לקוות שלא, מה שקרה זה ששינינו, כמו שאתם רואים, ליסט 1, ככה הקדמת ליסט 1, אז בעצם זה שכתבנו כאן ליסט 2 ב-index 0,0 שווה 1, ...

53
00:19:23,660 --> 00:19:53,660
אז בעצם שינינו את האפס הזה כאן בפנים, בצד רשימה ראשונה, זה כאילו ששינינו את זה להיות אחד. למעשה אני רוצה שממש תראו את ההבדל. נניח שנוקח את ה-Le2 באינדקס 0x0 הזה, עושה לו cut, מביא אותו לפה ואז למקום ל-Le2 פשוט לכתוב 1. עושה את השינוי כאן במקור ואז לעשות אישור שלוש פעמים

54
00:19:53,660 --> 00:19:59,800
תגידו לי אם זה נראה לכם אותו דבר, תזתכרו, אותו דבר בדיוק.

55
00:20:00,260 --> 00:20:06,800
תשימו לב לקטע הזה של זיכרון ורשימות ושרשור עם אופרטור כפל.

56
00:20:07,340 --> 00:20:14,620
בסדר? תשימו לב להבדלים האלה. לא טריוויאלי, מגניב.

57
00:20:15,460 --> 00:20:23,360
עכשיו תגידו לי אתם מה זה לנגף של ליסט גם אם היא רב- ממדית?

58
00:20:23,360 --> 00:20:53,100
בואו נסתכל על זה. איך שדיברתי מתחילת התרגול ועד עכשיו זה צריך להיות ברור מאליו למה התשובה כאן תהיה 2. אתם רואים בעצמכם. הנה רשימה שיש לה שני איברים. האיבר הראשון הוא רשימה שיש לה איבר 1 והוא 1 והאיבר השני הוא רשימה שבפנים יש לה שני איברים, סליחה, 3 ו-4.

59
00:20:53,100 --> 00:21:08,060
אבל זה לא משנה, אנחנו לא שאלנו לנקס של ליסט באינדקס 0 או לנקס של ליסט באינדקס 1. שאלנו מה הלנקס של ליסט, כמה איברים יש בליסט, והתשובה היא 2.

60
00:21:10,740 --> 00:21:22,540
עכשיו, אם באמת אנחנו רוצים להתעניין בעמודות, האמת, נכתוב את המילה "עמודות" כאן יכול לבלבל אתכם,

61
00:21:22,740 --> 00:21:32,800
כי אתם מבינים שפקודת length היא פקודה מאוד תמימה, ויש לה מטרה מאוד ברורה, להגיד לכם מה אורך הרשימה שאתם מביאים לו.

62
00:21:33,140 --> 00:21:37,300
אז list באינדקס 0, תסתכלו על ה list הזה.

63
00:21:37,580 --> 00:22:07,540
list הזה באינדקס 0, זה פשוט רשימה עם איבר יחיד, אז ברור שלength של list אינדקס 0 נותן 1, ואז גם ברור שלlength של list באינדקס 1 ייתן 2. אתם מבינים למה, נכון? זה פשוט רשימה שאיברים שלה זה רשימות, ואתם יודעים לעשות את חישובי האורך הזה ברשימה כשלעצמם.

64
00:22:07,540 --> 00:22:36,260
אוקיי, אז בואו נסתכל על תרגיל קצר, שקצת מתרגל אותנו בעבודה עם רשימות רב-ממדיות. אומרים לנו, תכתבו פונקציה שמקבלת שני מספרים, n ו-m, והיא מחזירה לנו את לוח הכפל בגודל n אישורות על m עמודות. מותרנו להשתמש בכלים שהכרנו כמו range וגם list comprehension. אז בואו נסתכל על הצעת הפתרון.

65
00:22:37,220 --> 00:23:06,220
אנחנו נגדיר פונקציה מול בורד, היא תקבל שני פרמטרים, n ו-m. נתחיל. ניצור את רשימת לוח הכפל, נתחיל מכלום, ונבנה עליה. אז נגיד שלכל i בריינג' שבין 1, דווקא, לא 0, כי אנחנו נרצה לחשב פה לוח כפל, אז נעשה פה לולאה בתוך לולאה, ואנחנו נרצה לחשב ממש אינדקס לולאה כפול אינדקס לולאה.

66
00:23:06,220 --> 00:23:35,840
נתחיל אותו מ-1, כי אנחנו לא רוצים כפל שמתחיל מ-0. אז זה למה אנחנו כותבים פה ריינג'ים שהם בין 1 ל-n פלוס 1 או m פלוס 1, כן? כי אתם יודעים מה קורה. ריינג' תמיד עושה עד לקצה הריינג' פחות 1. במילים אחרות. לכל שורה בין השורה הראשונה לשורה ה-n, מה נעשה? נגדיר.

67
00:23:35,840 --> 00:24:05,740
רשימת שורה, נתחיל מ-0 ואז אנחנו נוסיף לתוך זה תוצאות הכפל. אז בעצם אנחנו בונים פה רשימות, אתם רואים מה קורה פה? בלולאה החיצונית אנחנו בונים רשימה כל הזמן, רשימה של שורה, שורת לוח כפל, ואת כל זה אנחנו נוסיף ללוח הכפל ככה אפנד, בעצם רשימה נוסיף, רשימה נוסיף, רשימה.

68
00:24:05,740 --> 00:24:35,500
של רשימות, כן? לא שינינו פה שום דבר ממה שלמדנו. אז ניצור רשימה, ועכשיו לולאה פנימית, for j in range 1 עד m, כלומר, לכל עמודה, בין העמודה הראשונה לעמודה ה-m, כן? מה נעשה? מה נוסיף לרשימת השורה? פשוט נעשה append עם i כפול j. זה לוח הכפל. מספר עמודה כפול מספר שורה.

69
00:24:35,500 --> 00:24:58,840
ככה היום אנחנו פשוט מחשבים לוח הכפל, זה תמיד היה ככה, הכי פשוט. אז עשינו את זה, סיימנו את הלולה הפנימית, נוסיף את הרשימה הזאת שעכשיו בנינו, רשימת השורה, לרשימת לוח הכפל, והנה אנחנו בונים ככה לוח כפל, מדריצת דומי מדאית. נכון? זה היה פשוט.

70
00:24:58,840 --> 00:25:28,840
יש דרך אגב דרכים אחרות לעשות את זה אבל רק שנייה לפני שנעשה את זה בואו נראה לכם באמת את הקוד שעכשיו ראינו, הנה הקוד שראינו עכשיו. רק בשביל טיפה להתלהב מהפייתון האינטראקטיבי כתבתי פה חלון קוד קטן שאומר מתוך קובץ הקוד שבו נמצא הגדרת הפונקציה הזאת: אני עושה אימפורט לשם הפונקציה. עכשיו אני...

71
00:25:28,840 --> 00:25:37,960
אני יכול להריץ לדוגמה, מול בורד עם לוח הכפל של 10 על 10, יאללה, בואו נריץ את זה.

72
00:25:41,260 --> 00:25:49,880
עכשיו תראו, רגע, הנה, בואו נראה את האוטפוט, הנה, אני קצת מגדיל, מביא את עצמי לפה.

73
00:25:50,580 --> 00:25:58,820
אוקיי, אז אתם רואים שיש לי כאן בעצם רשימה עם עשרה עיוורים, כל עיוור.

74
00:25:58,820 --> 00:26:28,580
זה רשימת שורה, ופה בעצם יש לי כאן ללוח הכפל של 10 על 10. זה עבד. זה לא אמור להפתיע אותנו, אבל זה עבד. אז, עכשיו בואו נסתכל על באמת פתרונות אחרים שכתובים בצורה קצרה יותר. לדוגמה, אנחנו יכולים לכתוב לולה אחת. נגיד, 4i באמת in range 1 עד n פלוס 1, כלומר.

75
00:26:28,760 --> 00:26:57,960
לכל שורה, מה אנחנו נעשה? אנחנו נעשה אפנד. אפנד למה? עכשיו תראו קטע, זה ממש מצחיק. אנחנו עושים אפנד לליסט של ריינג' כלשהו, זאת אומרת, אנחנו נבנה פה ליסט מתוך ריינג', בסדר? זאת אומרת, מה שאתם ראיתם כאן, כל זה, אנחנו נבנה פה.

76
00:26:58,740 --> 00:27:03,280
אז בואו ננסה להבין את הריינג' הפנימי הזה, ככה.

77
00:27:05,760 --> 00:27:35,580
הרי אתם זוכרים איך זה היה כתוב, נכון? i כפול j, כן? כל שורה i, היינו עושים i כפול j שעבר באמת בין 1 ל-m פלוס 1. איך נכתוב את זה פה? נגיד כזה דבר. נעשה ריינג' שמתחיל ב-i, הרי אתם זוכרים איך לוח הכפל נראה, נכון? בואו נראה. הופה. פותח פה יותר מדי.

78
00:27:35,580 --> 00:28:05,460
דברים. רק שנייה רוצה להראות לכם למה אני מתכוון. ראנסל. אוקיי, אז אתם זוכרים את לוח הכפל, נכון? תראו, כל שורה, מה, איך אנחנו בעצם נגדיר את הערכים של השורה? עבור i שווה 3, לדוגמה, יש לנו פה 3 כפול 1, 3 כפול 2, 3 כפול 3. כלומר, אנחנו עושים פה קפיצות, קפיצות של i.

79
00:28:05,460 --> 00:28:18,100
קפיצות של i כל פעם, זאת אומרת i, 2i, 3i, 4i, עבור i שווה 3, אתם מבינים? אז זה מה שעשינו כאן.

80
00:28:18,100 --> 00:28:29,880
נתחיל את הריין שלנו מ-i, כלומר מ-i כפול 1, מאינדקס השורה, שמתחיל ב-1, לא ב-0, מתחיל ב-1, כי זה לוח הכפל.

81
00:28:29,880 --> 00:28:40,720
מסיימים ב-i כפול m, זאת אומרת, i כפול מספר העמודות, פה כתוב פלוס 1, אבל אתם כבר מבינים איך ריינג' עובד, ועושים את זה בקפיצות של i.

82
00:28:40,720 --> 00:28:56,700
אז בעצם אנחנו עושים פה עבודה חכמה עם ריינג' כדי לבטא פה ריינג' שהוא פשוט כל הערכים שבשורה אחת של לוח הכפל, לפי n וm שקיבלנו כפרמטרים.

83
00:28:56,700 --> 00:29:26,580
ומכל זה, הריינג' הזה, אנחנו יוצרים רשימה, וכל זה אנחנו עושים אפנד לתוך הבורד. כל זה ונעשה ריטרן לבורד. יש לנו גם את הקוד הזה, שכתבתי אותו פה ב-Q1b, אז מה שאני הולך לעשות, אני הולך לעקובץ פייתון האינטראקטיבי שלי, ואני פשוט אעשה שינוי קטן פה, עכשיו מ-Q1b, נעשה אימפורט לפקודה הרלוונטית, כן? מול בורד, ואז נריץ את מול בורד 10 ל-10.

84
00:29:26,580 --> 00:29:56,580
וכמו שאתם רואים עדיין יש פה לוח כיפל שעובד הנה אני אפילו אשנה את זה איתך, למשהו קצת יותר הגיוני, שבע על שבע אני רוצה שזה ירוץ קצר יותר ירוץ הנה נכנס פה בערך אוקיי זה עובד, אוקיי, ספוילר קטן כי הוא חדסי יש שם מימוש עוד יותר קצר אבל גם הוא מימוש יעבוד, הנה בוא נריץ את זה גם. כן? לוח הכיפ שלך משנה, לא להתקשר איתי מחורף לבין זאת ממה שאתה רוצה... די!

85
00:29:56,580 --> 00:30:06,980
חמש ומה קוד העוד יותר קצר, קוד של list comprehension עכשיו בוא נראה אם אתם צריכים להבין את זה תראו מה יש לנו כאן.

86
00:30:08,220 --> 00:30:15,960
קודם כל, נסתכל דווקא מימין. אנחנו אומרים לכל i ind parentage 1 עד n פלוס 1.

87
00:30:15,960 --> 00:30:24,360
כלומר, יש לנו פה 4 שעובר על כל שורה. מה אנחנו נעשה בכל שורה, נסתכל שמאלה.

88
00:30:24,360 --> 00:30:54,100
אה, טוב זה כבר לא מתוחכם זה פשוט קופי של מה שראיתם פה בתור איבר ברשימה אז return list comprehension זאת אומרת ליצירה של ליסט גדול שהאיברים שלו בעצמו הם הליסטים האלה שהם שורות לוח הכפל לכל שורה בלוח הכפל. בקיצור, כמה זמן לקחנו להבין את זה?

89
00:30:54,860 --> 00:31:19,940
וכמה קרי זה נראה, אז אתם רואים איך איך יש קטע כזה שמצד אחד אתם רוצים לכתוב קוד שהוא קרי, אבל קוד שהוא קרי לוקח לכם יותר שורות מאשר קוד שהוא קצת פחות קרי אבל עושה אותה עבודה בדיוק. יש קטע כזה שלפעמים זה לא ברור מאליו מה אידיאלי לנו בתור מתכנתים.

90
00:31:19,940 --> 00:31:28,060
אז תראו, אני אגיד לכם כזה דבר, עוד לא דיברנו אפילו על סיבוכיות, זה הנושא של השבוע הבא.

91
00:31:28,060 --> 00:31:48,840
במציאות אתם תיתקלו במצבים כאלה, וזה פשוט תלוי בדרישות של איפה שאתם תהיו, בין אם זה תרגילי בית בקורס אקדמי, או בין אם זה בעבודה, שבה אתם צריכים לתכנת קוד. הדרישות בשבילכם יהיו שונות, קריאות, סיבוכיות, זמן ריצה, או כמה קל לשנות את זה.

92
00:31:49,560 --> 00:31:58,560
אלו דברים שמדי פעם התנגשו אחד בשני בעולם האמיתי, וזה משהו שכדאי שתכירו כבר מההתחלה, רק שתכירו את זה בתור קונספט.

93
00:32:00,200 --> 00:32:18,580
אוקיי. בואו נסתכל על תרגיל אחר שעובד על מטריצות רב-מימדיות. אז תן דוגמה: פונקציה שתקבלת רשימה אדו-מימדית ותעשה לה Transpose. מישהו כאן לומד את הקורס באלגברה לינארית? פעולת שכלוף.

94
00:32:18,580 --> 00:32:48,140
Transpose על מטריצה? בקיצור, במקרה שמישהו עוד לא יודע את זה בעל פה, כשאנחנו אומרים לעשות Transposing על מטריצה, אנחנו בסך הכל מנסים להגיד: תסתכלו על מטריצה שיש לה שורות, עמודות, אז אנחנו מחליפים את התפקידים של השורות ועמודות. אז עבור מטריצה כזאת שיש לה שתי שורות ושלוש עמודות, כל שורה תהיה עמודה.

95
00:32:48,140 --> 00:33:17,940
במטריצה המשוחלפת. או ההפך, כל עמודה תהיה שורה במטריצה המשוחלפת. אז, שימו לב שלעשות Transpose, זה לא בדיוק אותו דבר כמו סתם לסדר מחדש את הליסטים שבפנים. זה לא בדיוק אותו דבר, זה קצת שונה. אוקיי, בואו נכתוב קוד שעושה את זה.

96
00:33:17,940 --> 00:33:47,520
אז קחו דוגמא הצעת פתרון. בכל זאת אנחנו עדיין צריכים לעבוד על שורות ועמודות. אז הפתרון שהוא כביכול קרי עדיין יעבוד לנו בשתי לולאות. אז נקבל רשימה, ניצור רשימת תוצאה שהיא משוחלפת, מה נעשה? נעשה פה for i in range length של list אינדקס 0, כלומר נניח אין לרשימה.

97
00:33:47,520 --> 00:34:16,960
רשימה 1, 2, 3, ואז רשימה 4, 5, 6, זאת אומרת אנחנו נעשה length עמודות. למה? שימו לב, מספר העמודות הולך להיות מספר השורות החדש שלנו, הרי אנחנו בונים איברים חדשים, זאת אומרת בונים רשימות חדשות, שהן בעצמם יהיו האיברים החדשים של הרשימה הדומימדית החדשה. אז יש סיבה למה אנחנו עושים את הריינג' שהוא בדיוק הדבר הזה. אוקיי, בואו נבנה את זה.

98
00:34:16,960 --> 00:34:46,860
אז נבנה רשימה זמנית חדשה שהולכת להיות שורה במטריצה המשוחלפת, ועכשיו אנחנו נגיד for j in range של אורך הרשימה המקורי, שזה פשוט מספר השורות ברשימה המקורית, הולך להיות מספר העמודות ברשימה המשוחלפת, עד כאן הגיוני. לכל שורה, נעשה...

99
00:34:46,860 --> 00:35:16,860
לולה פנימית שעוברת על העמודות. ראינו את זה כבר. מה נעשה? עפנד לשורה החדשה שלנו את ליסט אינדקס G אינדקס I. כלומר, זוכרים שאמרנו ששכלוף מחליף את התפקידים בין שורות ועמודות? למה שנעבוד קשה מנטלית? נגיד גישה למטריצה דו-ממדית.

100
00:35:17,620 --> 00:35:31,560
בסדר הפוך של האיתרציות שלנו, כן? זאת אומרת, J שעובר על הלנקף של ליסט, אתם רואים את זה, לנקף של ליסט ככה, זה הופך להיות מספר שורות.

101
00:35:33,060 --> 00:35:46,800
אז ככה אנחנו נבנה את זה, ליסט אינדקס J, אינדקס I. וכל זה יבנה לנו את השורה החדשה, וכל זה אנחנו נעשה אפנד לטרנספוסט ליסט שלנו, ונעבור על השורה הבאה.

102
00:35:46,800 --> 00:36:16,420
בתור. אתם רוצים אולי דוגמה איך זה עובד, בתכלס? איך לבנות את זה? אז סתם דוגמה, נסתכל על דוגמה הזאת. נניח שאנחנו עכשיו על I שווה 0 ו-J שווה 0. זאת אומרת, I שווה 0, J שווה 0. האמת זה חלק הקל, כן? כי האיבר הראשון עדיין הולך להיות האיבר הראשון. בסדר. עכשיו אני רוצה להסתכל על J שווה 1.

103
00:36:16,940 --> 00:36:46,400
מה קורה ב-J שווה 1? תסתכלו, זה יסתכל על לינקס של ליסט, J שווה 1. בסדר גמור. אז מה אני עושה? ליסט באינדקס J, כלומר, הלולה הפנימית, עברה לשורה הבאה בתור, הלולה החיצונית, אנחנו עדיין באינדקס I שווה 0, אתם רואים? בעצם אנחנו עושים...

104
00:36:46,400 --> 00:37:16,400
פה מעבר עמודה, עמודה, עמודה. רואים? לכל שורה אנחנו עוברים על עמודה. זאת אומרת, בונים שורה חדשה, עוברים על עמודה. סיימנו לבנות את השורה הראשונה. i עכשיו עובר מ-0 להיות 1. i שווה 1 ועוד פעם j עובר על 0 ו1.אתם מבינים? אז אנחנו עכשיו ב... זאת אומרת, אנחנו...

105
00:37:16,400 --> 00:37:45,700
עכשיו בונים את השורה הבאה בתור במטריצה, אבל האינדקסים שלנו הם עדיין J שווה 0, J שווה 1, ו i שווה 1 קבוע עבור השובה שלנו הזאת. זה מה שהייתה לנו בעצם לבנות 2 ואז 5. אז אני מקווה שהבנתם עכשיו ממה שדיברתי, אם לא אתם מוזמנים לנסות להריץ את זה, יש לכם את הקוד כבר כאן.

106
00:37:45,700 --> 00:38:15,600
אני יכול לנסות להריץ לכם את זה, אבל אני רוצה להאמין שאתם כבר הבנתם איך זה עובד. הנה אני יכול, אה אני צריך להביא לו רשימה. בוא נראה, שמתי דיפולט ואליו ליסט, נכון? טרנספוז מיסינג, כן, לא הבאתי לו, אוף, לא הבאתי לו ליסט דיפולטיבי, טוב, לא בגדיל. אני יכול לבנות לו, בסדר.

107
00:38:16,060 --> 00:38:27,400
נבנה את הרשימה שאנחנו רואים כאן. הנה, 1, 2, 3, הפסיק 4, 5, 6. אוקיי, יאללה, אני שולח לו את הרשימה, שגר.

108
00:38:29,800 --> 00:38:46,000
טוב, קיבלנו דעה. קוד שעובד סך הכול, הופה. בקיצור, אני מקווה שהבנתם. אנחנו בונים שורות חדשות ועושים את האיטרציה שלנו שורה בכל עמודה.

109
00:38:46,000 --> 00:39:16,000
המקורית של המטריצה עוברים ככה איטרציה לשורות ככה אנחנו בעצם בונים את השחלוף. מקווה שהבנתם ואם לא הבנתם אז אל תדאגו: הקוד של ה-list comprehension יכול להיות אפילו יותר מבלבל בי שלכם או שאולי לא בואו נסתכל, הנה אנחנו פותרים את זה בשורה אחת על ידי list comprehension. מה נגיד? בין אתן רשימה לכל עמודה בריינג' של עמודות של המטריצה

110
00:39:16,000 --> 00:39:40,680
כן? הרי, נכון? אתם זוכרים? ליסט באינדקס 0 זה פשוט הרשימה הראשונה ברשימה המקורית. זה מספר העמודות. אז לכל עמודה, נבנה רשימה חדשה, שבנויה ממה? תסתכלו.

111
00:39:40,680 --> 00:39:41,580
לכל שורה ברשימה המקורית, אנחנו נוסיף כאיבר.

112
00:39:41,580 --> 00:40:11,120
שורה ברשימה המקורית, אנחנו נוסיף כאיבר, שורה באינדקס עמודה. אתם צריכים לעלות על זה? אז תסתכלו. נניח שאנחנו עכשיו מסתכלים על העמודה אינדקס 0, עמודה הזאת, עמודה באינדקס 0. זה עלולה חיצונית, עמודה באינדקס 0. כלום שווה 0 כרגע.

113
00:40:12,120 --> 00:40:41,020
אז נעבור בלולה פנימית על השורות לרשימה הראשונה והרשימה השנייה. אתם רואים מה זה? פור שהוא פשוט עובר על פני הליסט המקורי. מזכיר לכם, ליסט המקורי זה שני איברים. הרשימה הראשונה והרשימה השנייה. אז עבור הרשימה הראשונה, נעשה לה גישת זיכרון בקולום הנוכחית.

114
00:40:41,020 --> 00:40:49,940
כל זה איבר איטרציה באה בתור איבר הבא בתור זה יהיה השורה באינדקס.

115
00:40:49,940 --> 00:40:55,300
פשוט כל... זה כזה.

116
00:40:55,300 --> 00:41:03,560
זה קשה להבין את זה אני יודע לא סליחה לא כל מה בא בתור אני אני עכשיו מתחיל לבלבל אתכם בטעות סליחה.

117
00:41:03,560 --> 00:41:07,340
אני מנסה להגיד רו באותו קולום.

118
00:41:07,340 --> 00:41:18,520
אבל for rows, זאת אומרת row בקולום שהוא 0 וה-row הבא בתור בקולום שהוא 0.

119
00:41:18,520 --> 00:41:37,320
אוקיי אני אעצור את הרצף של ההסברים כאן. אם הצלחתם להבין את זה אני ממש שמח. אם עוד לא זה בסדר גמור הקוד. הקוד זמין לכם ואני ממליץ לכם בחום. תנסו להבין את זה.

120
00:41:37,320 --> 00:42:07,100
תנסו להריץ את זה ואם זה עדיין קשה לכם אתם מוזמנים אפילו לעשות דיבאגינג לעשות וואטש ליסט אבל זה עובד כן. גם הקוד הזה של שורה אחת בליסט קומפיינשן הוא יעבוד. אז מגניב. דיברנו עד עכשיו על רשימות דו מימדיות רשימה שהאיברים שלה זה רשימות אבל אתם יודעים משהו אפשר להתחכם אפשר לעשות.

121
00:42:07,100 --> 00:42:37,100
רשימה שהאיברים שלה זה רשימות שהאיברים שלהם זה רשימות, רשימה של מדית אם תרצו לקרוא לזה קובייה, לא יודע. אז תראו לדוגמא ככה המחשה ויזואלית ובואו נראה איך אנחנו כותבים את זה, האמת, כזה מסובך תסתכלו הנה ליסט, לליסט יש, עכשיו זה קשה כן? אני

122
00:42:37,100 --> 00:43:07,100
מקב מהסוגריים המרובעות, החיצוניות, 2 פותחות, 1 סוגרת, או הנה 2 סוגרות. אתה רואה את הפסיק הזה? זה הפסיק שמפריד בין 2 העברים שיש ל-List. ל-List יש 2 איברים. רשימה דו-ממדית של 1, 2 ו-3, 4 ורשימה דו-ממדית של 5, 6 ו-7, 8. מה שאתה רואים פה בהמחשה ובכירות של ה-List זה שזוני ? אז לעיקר את ה-List הפסיק שאתה יכול להסתכל במישהו או שאתה חייב לעשות כל שיתי צריך לחשוב על מה שאתה יודע ... להיות חדים אצטרקטוח, להתפתח ... ביצוע ... באופ

123
00:43:07,100 --> 00:43:37,100
ויזואלית. יכול קצת קשה לעקוב, כשמסתכלים על זה בצורה של קוד, אבל זה מה שזה. אז בואו נסתכל על דוגמאות פלטים, מה נקבל? בואו נראה list %ndx1, זאת אומרת לא זה, אלא זה. תת הרשימה הזאת, ה-5678, היא אינדקס 0, אז הרשימה שהיא

124
00:43:37,100 --> 00:44:07,100
חמש, שש. אינדקס 1, 6. פה אני אקבל 6, דרך אגב. בואו נראה מה בא בטור. ליסט 2 הולך להיות שווה לליסט המקורי באינדקס 0, זאת אומרת, ה-1234-זה משורשר פעמיים. אה, אז הולך להיות שווה פעמיים. תראה, זה איך זה שותפים. יודעים, אנחנו רוצים שאם הם מציאים זה לגביע, אז הם מתיינים איך זה צריך להיות, תראו מה זה

125
00:44:07,100 --> 00:44:37,100
להיות לי קוביית Alt- Madex של 1234,1234, ושמה מבקשים ממני לעשות גישה לאינטקס 0,0, זה פשוט יהיה 1,2 לא? זה התחושה שלי, בוא ננסה להמשיך הלאה, ליסט, אינטקס ראשון מינוס 1, זאת אומרת, העבר האחרון, שזה היה 5, 6, 7, 8,

126
00:44:37,100 --> 00:45:07,100
אינדקס 0,0 זה 100,5. עכשיו פה, זה ליסט מהתחלה לא כולל העבר האחרון, נכון?. אינדקס 0,0 זאת אומרת... אחד? בואו נראה אם צדקנו. ועוד שאלה אחת אחרונה על הדרך.  One for the road מה שנקרא. פרסמה מ"התראה", מכתל ה"אוצר" הזה את צדקת לביתך.  צויח להמשיך בית אתמול.  צופה לעירואקציה. עדן זאת תרצה להגיש מונטלי משפט מיומף לקראת אתמול על כך ולחשום אתמול לגמרי. זאת אומרת להחליף אתמול בעודן איש ראשון, אבל בעודן מיית

127
00:45:07,500 --> 00:45:37,500
פה, מה קורה אם לקחנו את התרחיש שהיה לנוי שמה של השירשור של ה-1, 2, 3, 4, ואז לסנות את האיבר הראשון ל-1, ואז מה יש בלי-2? אתם רוצים שנגלה? אז יאללה, זמן לגלות סוף סוף. קודם כל, באינדקס 1, 0,1, זוכרים? אינדקס 1, אז חצי השני. 0.

128
00:45:37,580 --> 00:45:40,020
הרשימה 56 ואינדקס 1, 6.

129
00:45:41,860 --> 00:45:54,460
אוקיי, ועכשיו היה לנו את הליסט המקורי, נעשה שירשור של שניים של ה-1234, אז leverage1234 משורשר עם 1234,

130
00:45:54,460 --> 00:46:03,800
ואז עושים פשוט גישה לתוך זה, גישה אינדקס 0, אז לחצי הראשון, עוד אינדקס 0 לרשימה הראשונה, 12.

131
00:46:05,440 --> 00:46:17,200
ועכשיו היה לנו את הליסט המקורי, גישה לאיבר האחרון, גישה אינדקס 0, 0, איבר האחרון, רשימה ראשונה, איבר ראשון, 5.

132
00:46:18,900 --> 00:46:35,200
ושוב, גם פה היה לנו את ה-12, כי תראו מה יש לנו, ליסט, אבל סלייס שמעיף את ה-5678, ואז גישה לראשון, ראשון, אז פשוט 1, 2, ולבסוף, אוקיי.

133
00:46:35,460 --> 00:47:04,920
הנה שינוי מעניין, בואו ננסה להבין אותו. אמרנו, ליסט 2 שווה ל-חצי הראשון, שזה ה-1234, שני איברים של רשימה עם שני איברים, משורשרת פעמיים, ואז אנחנו עושים גישה לתוך הדבר הזה, אינדקס 0, ואז עוד אינדקס 0, כלומר, אנחנו נוחתים על הרשימה 12, אתם רואים, כמו שכתוב פה.

134
00:47:04,920 --> 00:47:34,020
1, 2 הזה, ומשנים שם ל-1. אז בגלל שאופרטור כפל עובד על אותו אובייקט בזיכרון, פשוט מצביעים, יוצר עוד מצביעים אליו, אז אנחנו נקבל ששני החלקים האלה ששירשרנו, כאן, אנחנו משנים להם את הרשימה, במקום שהיא תהיה 1, 2, הופכים את זה לאינטג'ר, עם ערך 1. קצת תסביך לנסות לעקוב אחרי כל זה.

135
00:47:34,020 --> 00:47:50,020
יש לנו כאן גם את זה בצורה של קוד פייתון, עם אפילו דיפולט ואליו כזה, שזו בדיוק הרשימה שראינו במצגת, אתם רואים פה, כל סוגריים יש להם צבעים שונים, שזה מאוד עוזר להבנה.

136
00:47:50,020 --> 00:48:03,540
אז אם אתם תרצו להריץ את זה, שום דבר לא מונע מכם, יכול להריץ את זה, את הפונקציה שמגדירה את זה, והנה. לקחנו את הרשימה הנקורית.

137
00:48:03,540 --> 00:48:32,540
עשינו לה את כל השינויים, וקיבלנו את הערכים האלה, כפי שראיתם במצגת. מגניב. אוקיי. עבדנו הרבה על רשימות. עכשיו בואו נסתכל על רשימות במרכאות, אבל הפעם שאתם לא יכולים לשנות את הסדר של דברים שם, או מה בדיוק קורה פה.

138
00:48:32,540 --> 00:48:45,540
אנחנו יודעים שרשימה זה אוסף של נתונים, לא בהכרח מאותו טיפוס, שונים. אז טאפל זה משהו שקצת פחות מיוטאבל בוא נגיד את זה ככה.

139
00:48:45,540 --> 00:49:01,540
אין אי הסדורה, אם זה אומר לכם משהו בחדווה. הקטע הזה של, כזה קבוצה או רשימה שהסדר של דברים שם כן משנה, והוא כן קבוע. אז בפייתון, פשוט תחשבו על זה בתור רשימה כזאת שאתם לא יכולים לשנות אותה.

140
00:49:01,540 --> 00:49:30,540
בואו נסתכל. אם יש לנו כזה טאפל, שאיך אנחנו מגדירים אותו? במקום סוגריים מרובעות, במקום רשימה של סוגריים מרובעות, זה רשימה של סוגריים עגולות. אוקיי, עכשיו אנחנו נגיד טאפל בינקס 0 תשתנה להיות 3. אז מה שהיה קורה אם היינו מנסים להריץ את הקוד הזה, היינו מקבלים שגיאת פייתון, שאובייקט מסוג טאפל לא תומך בהסמה של ערך חדש בפנים.

141
00:49:30,540 --> 00:50:00,540
חדש בפנים, טאפל הוא אמיוטאבל. מה זאת אומרת אמיוטאבל? אם אנחנו נרצה טאפל שונה, זה יחייב להיות אובייקט שונה. אז בואו נסתכל איזה תכונות יש לטאפל?  נגדיר מהי טאפל, כמו שאמרנו מקודם, נניח האיבר הראשון שלו יהיה אינטג'ר 1, האיבר השני יהיה סטרינג הלאו, האיבר השלישי יהיה פלואוט 1.6, ואז נגיד את הלילה של טאפל בתקופה הראשונה. עכשיו נראה איך עושה זמן להפגיש באטכוארי היטק. איפה ראית את זה? אם צריכים למצ

142
00:50:00,540 --> 00:50:04,580
נגיד, your tuple שווה my tuple.

143
00:50:04,580 --> 00:50:14,380
אה, your tuple? No, comrade, our tuple. אתם זוכרים את הקטע הזה בזיכרון, כן?

144
00:50:14,380 --> 00:50:42,820
האופרטור שווה הוא בסך הכל מנחין, מכווין אותנו לאותו אובייקט בזיכרון. כשאנחנו לוקחים ככה טאפל אחר ואומרים לו אתה שווה לטאפל כזה, האופרטור שווה הזה אומר אתם עכשיו שניכם מצביעים לאותו דבר בזיכרון. אז אל תשכחו את הקטע הזה. מה אופרטור שווה אומר בין שני משתנים.

145
00:50:42,820 --> 00:51:11,660
אוקיי, מה עוד יש בטאפלס? יש לנו גישה באופרטור סוגריה מרובעות, זה עדיין עובד, כמו שראינו את זה במחוזות להגיד האמת. אפשר לגשת לאיבר באינדקס מסוים, לפחות כדי לקרוא אותו, יש. מה אי אפשר לעשות? אתם לא יכולים לקחת לדוגמה את הטאפל 1-2?

146
00:51:11,660 --> 00:51:28,340
ולחבר אותו עם טאפל של איוואר יחיד שלוש, זה לא יעבוד, או יותר נכון, סליחה זה לא מדויק, אתם כן יכולים אבל זה קריטי שאתם תכתבו את זה בצורה נכונה, כי למה?

147
00:51:28,340 --> 00:51:41,260
כשאני כותב בסוגריים שלוש, וזהו, אז זה יכול, יש מצב שזה יהיה קצת בלבול, אולי פייתון חושב על זה בתור ביטוי,

148
00:51:41,260 --> 00:52:11,020
של אינטג'ר יחיד, או משהו, זה לא בדיוק טאפל, אבל אם אתם תכתבו סוגריים שלוש, פסיק, כלום, ואז סוגריים, פייתון יזהה שזה טאפל, ואז אופרטור פלוס כן מצליח לעשות כאן שירשור של שני טאפל's כדי לפנות טאפל חדש, שהוא בעצם התוצאה של חיבורות דברים האלה.

149
00:52:11,020 --> 00:52:41,020
אז יש כאן הבדל סינטקטי שנראה מוזר, נראה דפוק, אבל אני אומר לכם, יש לו סיבה, כי כשאתם כתבתם פה את הפלוס, סליחה, לא את הפלוס, את הפסיק, כשכתבתם פסיק, זה הסינטקס שכשפייתון רואה בתוך סוגריים עגולות, הוא מבין, אה, זה טאפל, זה נהיה סדורה, זה רשימה מסודרת שהיא iimmutable, שיש...

150
00:52:41,020 --> 00:53:11,020
משמעות לדברים פה. אבל כשרק כתבתם סוגריים עגולות בלי פסיקים בפנים ורק אינטג'ר, זה לא זה. אה... אני יכול האמת לתת לכם הדגמה למה שאני מתכוון. הנה פה אני אפילו אפתח פייתון בטרמינל ואפילו לא בוויאס קוד,סתם כי זה קוד ממש קצר,אני יכול לכתוב לכם, תראו, a שווה סוגריים שלוש. מה זה a? אינט.

151
00:53:11,020 --> 00:53:22,060
a שווה, סוגריים שלוש, פסיק, סגור סוגריים. מה זה a? I rest my case...

152
00:53:25,080 --> 00:53:41,000
אופרטור פלוס שווה. אופרטור פלוס שווה גם יעבוד. תראו כאן. נגדיר מייט פה ונעשה לו פלוס שווה, אחד פסיק, כלום. אז פה אני גם רוצה להראות לכם משהו. אני רוצה...

153
00:53:41,000 --> 00:54:11,000
להראות לכם ממש מה קורה באופרטור פלוס שווה, מה הוא עושה לטאפל שלנו, מה הוא עושה לאובייקט האימיוטבול שלנו שאינו בר שינוי, בוא תראו. אז נגדיר באמת מיי טאפל שווה ל 1 סטרינג הלו ו1.6, אין לו, 1 פסיק הסטרינג הלו, 1 פסיק הפלוט 1.6, עד כאן קול. ואני ארצה לעשות פרינט למיי טאפל ואני ארצה גם לעשות.

154
00:54:11,000 --> 00:54:41,000
פרינט ל-id של my turbines, אני ארצה לראות את כל זה ביחד רגע מה זה מזה? ועכשיו נעשה פלוס שווה minv mytubbies, פלוס שווה, אם הטפל אחד פסיק כלום ושוב, אני ארצה לראות מה זה mytubbies ומה.id שלו מגניב? בואו נעריס את הסל הזה,ונגלה

155
00:54:41,000 --> 00:55:01,000
הנה מה הייתה פלם קורי, עם ה-ID המקורי שלו כאובייקט, הנה אחרי אופרטו פלוס שווה, הוספנו לו את האיבר הנוסף אחד בסוף, ו-ID שונה. אז רבותיי, אובייקט שהוא Immutable, אופרטו פלוס שווה פשוט יצר אובייקט חדש.

156
00:55:01,000 --> 00:55:31,000
אז בואו לקחת כל מה שראינו עכשיו שלמדנו, גם על טאבלס, גם על רשימות וסטרינגים, ולנסה לשים את זה לעצמנו בטבלה כזאת. ננסה להבין מה ראינו על זה. אז ככה, קודם כל, האם הערכים שבתוך המבנה הזה, אם תרצו, שנקרא לו, האם הערכים צריכים להיות מאותו סוג? אנחנו יודעים.

157
00:55:31,000 --> 00:56:01,000
בליסט וגם בטאפל לא חייב להיות. כל איבר יכול להיות האמת משהו אחר. למה זה עובד? כי פייתון זה הכל עובד במצביעים למקומות בזיכרון, זה לא ישר בלוקים רציפים בזיכרון, וזהו. אתם ראיתם, פייתון מאוד גמיש בדברים האלה. אז אנחנו יודעים שבליסט ובטאפל התשובה היא לא. אבל סטרינג מצד שני, תמיד ראינו שסטרינג זה אוסף של קרקטרס, אז במחרוזת אנחנו באמת...

158
00:56:01,000 --> 00:56:31,000
רוצים שכל ערך נפרד בתוך מחוז, זה פשוט יהיה תו כרקטר. זאת אומרת, בקטע כזה שאם אני עכשיו פותח לכם, שוב, פייתון רק רוצה להדגיש לכם את ההבדל. על איך אני אומר, a שווה hello, אז מה הטייפ של a באינדקס 0. טוב, פייתון כותב סטרינג, זה כאילו תת סטרינג, אתם מבינים? אז, פייתון ספציפית עובד בסטרינגים.

159
00:56:31,000 --> 00:57:01,000
תבים בני פרד. אבל כשהסתכלו על שפות תכנות אחרות, לדוגמא וכולי, אתם תבינו שכל תו בניפרד הוא כאילו תו מנהיג בתור משתנה, ו screenshot יהיה רצף של תו מנהיג. אבל פה ספציפית, פייתון, איך שפייתון עובד הוא קורא גם לקרprotקט יחיד בתור מילה מיוחדת..אבל, זה הבדל קטן ש...רק כדי ש..תכירו, בסדר. לא משנה - בקיצור - מילה  מבין כל התוים מאותו טיפוס?

160
00:57:01,040 --> 00:57:21,460
אבל ליסט וטאפל חופשי. Next, מה ראינו? ראינו שאי אפשר לשנות סטרינג, אפשר להגדיר סטרינג חדש, וטאפל, כמו שאתם ראיתם עכשיו ב-VS-code, אפילו כשעשיתי myTapple פלוס שווה, זה עדיין יצר לי טאפל עם אובייקט חדש.

161
00:57:22,460 --> 00:57:30,940
אז, סטרינג, אתם לא יכולים לכתוב לתוך סטרינג קיים, ואתם גם לא יכולים לכתוב לתוך טאפל קיים, אתם יכולים רק לשנות את האובייקט.

162
00:57:30,940 --> 00:57:58,880
אבל בליסט אתם כן יכולים לעשות אפנד, ואני חושב לא לאבד את ה-ID, אז שוב, פתח פייתון, A שווה 1, 2, 3, ID של A, A.append 4, ID של A, בדיוק, שמענו על אותו ID, אובייקט ID, אז זה מסביר לכם את ה-V שראיתם פה ב-Write To, זה היה אפנד.

163
00:57:58,880 --> 00:58:28,880
גם בדלית האמת זה אותה קונספט, זה פשוט שינוי, בסדר, אז הנה אני כבר אליך החזרה לשורה של מיוטייבל, כן? ליסט הוא כן מיוטייבל, אתם כן יכולים לעשות שינויים במה שיש בליסט, אובייקט הליסט הוא עדיין אותו אובייקט, זה רק שבטארפלס ובסטרינגס זה כן קריטי סדר העברים והתוך כאילו והאובייקטים שמצביעים אליו, זה כן משנה. אז כשאתם רואים.

164
00:58:28,880 --> 00:58:58,880
אופרטור פלו שווה זה שאנחנו כן יכולים לעשות אופרטור פלו שווה עם סטרינגים סתם דוגמא לא יודע אה פלו שווה וורלד ואז אני רוצה להגיד להדפיס אה מה קרה? זה פשוט סטרינג אחר. זה אובייקט אחר. בסדר אופרטור פלו שווה הוא לא אורס מיוטבליות הוא לא חוצה עולמות הוא פשוט יוצר אובייקט חדש.

165
00:58:59,240 --> 00:59:15,100
דרך אגב, מה קורה כשיש לכם טאפל ואתם רוצים לעשות עליו שינויים? מה לעשות? אתם חייבים לקחת את התוכן של טאפל הזה ולשנות בו דברים? מה לעשות? די פשוט, תהפכו אותו לליסט.

166
00:59:15,200 --> 00:59:28,660
אז סתם דוגמה, אם עכשיו היה לי a שווה טאפל של 1, 2, 3, האם אופרטור ליסט על טאפל יעבוד? בום.

167
00:59:28,660 --> 00:59:58,440
אופרטור ליסט עובד? סתם דוגמה, עכשיו נעשה b באינדקס 1 שווה 10, הנה b, עכשיו b שווה, בוא נראה, יש אופרטור טאפל? b, ראיתם את זה? אופרטורי המראה, יש את זה בפייתון, אתם כן יכולים לקחת.

168
00:59:58,440 --> 01:00:27,740
טאפל, ליצור ממנו אובייקט חדש של ליסט, לעשות את השינוי שבא לכם ואז להשתמש באופרטור טאפל כדי ליצור אובייקט חדש של טאפל. אני די בטוח שה-ids ישתנו על הדרך, אני האמת זה די ברור שהם השתנו אבל היי. לא סוף העולם כן אפשר לקחת טאפל, להפוך אותו לליסט, לעשות על הליסט הזה דברים ואז להפוך את זה לטאפל בחזרה, זה כן עובד.

169
01:00:27,740 --> 01:00:57,740
יאללה בואו נתרגל עוד כמה דברים עכשיו שאנחנו מכירים את הדברים האלה. הנה שאלה פשוטה קחו ה ה מה זה ה? ה זה טאפל עם שני איברים. האיבר הראשון שלה זה רשימה והאיבר השני שלה זה רשימה. ועכשיו אומרים לנו ה באינדקס 1 זאת אומרת הרשימה 3-4 היא אינדקס 1, 4=0 האם זה יעבוד?

170
01:00:58,260 --> 01:01:16,020
הרי למדנו עכשיו שטאפלס הם אימיוטאבל, אתם לא יכולים לשנות אותם, אז מה יקרה כשננסה לשנות משהו בטאפל, אבל המשהו הזה הוא נמצא בתוך לשימה שבתוך הטאפל. האם זה יעבוד? מה לדעתכם? אני אגיד לכם!

171
01:01:18,140 --> 01:01:26,480
וכשאני אומר "אני אגיד לכם", אני מתכוון, בואו נגלה את זה בדרך הקשה, נכתוב את הקוד, יאללה.

172
01:01:26,480 --> 01:01:56,440
a שווה, הטאפל הזה, יכולנו אגב לעשות את זה באינטראקטיב מוד בווי.אס קוד, האמת, יאללה בואו נעשה את זה שם בווי.אס קוד, רק שתראו שבאמת אין הבדל, פייתון זה פייתון, לא משנה איפה זה. אם בהרצאות או אצל מתרגלים אחרים אתם רואים אותם מריצים קוד פייתון במה שנקרא אינטראקטיב מוד בווי.אס קוד, שזה פשוט להריץ בטעים נפרדים, פונקציונליות של ג'ופיטר, רק שתדעו.

173
01:01:56,440 --> 01:02:26,420
מי שאגב רואה את זה ורוצה לדעת איך זה עובד, אז פונקציונליות של ג'ופיטר, שזה עבודה עשירה עם קבצי פייתון, תאמינו לי, זה לא ממש משנה, פייתון זה פייתון, בסדר? בקיצור, בואו נריץ את זה. מה רצינו להגיד עכשיו? רצינו לבדוק a שווה, טאפל, שיש לו שני איברים שהם רשימות, 1-2, 3-4.

174
01:02:26,420 --> 01:02:56,180
מגנים, עכשיו בואו ננסה לעשות ניסוי, נשנה, איבר כלשהו. האם זה יעבוד לנו? יש רק דרך אחת לגלות. רגע, שנייה ואז פרינטאי, אוקיי? יופי. היי, מה אתם יודעים? רשימה אימיוטאבל.

175
01:02:56,180 --> 01:03:26,180
לא הטאפל אבל רשימה שהיא בתוך טאפל היא כן מיוטביל, ראיתם את זה בא? כמובן שפוסט ספציפית ה-ID הוא לא באמת אותו ID כי זה מספר אחר בסדר אבל עדיין עדיין did you see that one coming? אתם כן יכולים לשנות רשימה שהיא כן מיוטבילית? בתוך טאפל. אז.

176
01:03:26,260 --> 01:03:29,000
אם זה בלבלתוך מקודם, ראיתם את זה עכשיו.

177
01:03:31,000 --> 01:03:32,000
אוקיי.

178
01:03:33,500 --> 01:03:36,800
איזה שימוש ממש ממש פופולרי יש לטאפל?

179
01:03:37,400 --> 01:03:55,760
אז אני לא יודע אם ראיתם את זה, אבל אולי קצת יותר מומחה כשתתעסקו בפייתון, אתם תראו שבהרבה מקרים... לפעמים אתם מחזירים או מקבלים חזרה מפונקציה יותר מערך חזרה אחד. ואפשר לעשות את זה בעזרת טאפל. תראו לדוגמה. נגדיר פונקציה.

180
01:03:55,760 --> 01:04:18,340
שתחזיר 2 פסיק 3. מה זה אומר 2 פסיק 3 בתור ערך חזרה? זה הולך להיות טאפל עם שני איברים, 2-3. כלומר, זה זוג סדור של איברים, ערך חזרה. ואת זה אנחנו נקבל בחזרה מהפונקציה הזאת. ממש מסוג טאפל.

181
01:04:21,200 --> 01:04:50,580
עכשיו שאלה למחשבה, למה לדעתכם זה שימושי שלקבל יותר מהירך חזרה 1 באווט 1? למה זה שימושי שאנחנו מקבלים את זה בטאפל? מה זה עוזר לנו? למה זה טוב? תראו, טאפל אנחנו יודעים שהסדר הוא קבוע, אנחנו יודעים שהוא אי-מיוטאבל, זאת אומרת אובייקט שהוא טאפל איך שהוא, כך הוא יהיה.

182
01:04:50,580 --> 01:05:20,460
ואם אתם רוצים כבר לשנות משהו, אז זה חייב להיות טאפל אחר. אז אפשר להגיד שזה אולי טהור, שזה אולי יותר, לא יודע, יותר קבוע בזיכרון, אפשר לתת כל מיני תירוצים. אני רק משאיר את זה לכם. תנסו לדמיין למה זה יכול להיות שימושי, שזה יהיה בטאפל ולא בדווקא ליסט. בסדר. אגב, אם כבר דיברנו הרבה על טאפל עכשיו ועל רשימות סדורות.

183
01:05:20,460 --> 01:05:50,360
ועל גם דרך לקבל יותר מהר חזרה חד מפונקציה, יש אפילו עקרונות בפייתון שאני לא יודע כמה אתם חייבים לזכור אותם בעל פה בכך, אבל אני רק רוצה להראות לכם שתכירו. הקטע של פקינג ואנפקינג, זה כאילו הדרך לדחוס או לפרוק משתנים לתוך או מתוך משהו אחד, אבל בואו פשוט נראה להם.

184
01:05:50,360 --> 01:06:20,360
אה.. מראה לכם דוגמא ממש ממש קצרה, שוב, אתם לא חייבים לזכור את כל זה ממש חזק בעל פה, אני סתם רק רוצה להראות לכם, אפשר לראות אהמ.. כאן נניח שאנחנו מגדירים פונקציה שמקבלת סתם דוגמא כפרמטרים A ו-B וכל מה שהיא עושה זה להחזיר טפל שהוא A פסיק B, אז פה אתם רואים כאן פירוק ל bytecode מה שנקרא, זה כאילו מראה לכם

185
01:06:20,360 --> 01:06:50,360
פקודות שפייתון מריץ על המחשב כדי בעצם לעשות את העבודה שלו, זה כאילו הפקודות שמתחת לפייתון מה שנקרא, אז בתכלס אתם לא רואים פה שום דבר, אתם רואים פה טען פרמטר באינדקס 0, A, טען פרמטר load fast כאילו תהיינה מהירה של פרמטר באינדקס 1, B, תבנה טאפל,

186
01:06:50,360 --> 01:06:55,820
אוקיי, וזהו, תחזיר. זה לא היה מסובך.

187
01:06:56,860 --> 01:07:04,340
ועכשיו תראו מה קורה. כשאנחנו אומרים כזה דבר, נגדיר פונקציה G, שמה היא עושה?

188
01:07:04,340 --> 01:07:20,280
הפונקציה הזאת, היא תעשה a פסיק b, a פסיק b שווה מה שהפונקציה f תחזיר. אז קטע כזה, עכשיו אנחנו רוצים בעצם לקבל ל-a את הערך שהפונקציה g זאת.

189
01:07:20,280 --> 01:07:49,480
של העבר הראשון, ולקבל ל-b את הערך של העבר השני מהטאפל. כאילו, זה בעצם כל הפואנטה פה. פייתון עושה פה פקינג ואנפקינג, כדי בסך הכל לתת לפונקציונליות הזאת לעבוד. אז פה נניח, אנחנו מריצים את הפונקציה g, אז דבר ראשון שהוא עושה, הוא טוען את הקוד של הפונקציה f, הוא קורא לה, הוא סיים לקרוא לה, אז הוא עושה עכשיו אנפק.

190
01:07:49,480 --> 01:08:19,480
לטאפל שהוא קיבל, ועכשיו הוא שומר לתוך המשתנה A את הערך באינדקס 0 מהטאפל, שומר למשתנה בערך B, שומר לפי את הערך השני מהטאפל, טוען כלום כי אין פה עוד יותר מה לעשות ועושה ריטרן, זה כאילו הגדרה של G. בקיצור, בלה בלה בלה בלה בלה...

191
01:08:19,480 --> 01:08:26,940
כל זה בתכלס, כדי שנוכל לעשות כזה דבר, בסדר, אוקיי.

192
01:08:26,940 --> 01:08:38,280
היה פה הרבה דיבור על פקינג ואנפקינג וה... הפקודות שרצות מתחיל פייתון, אבל אתם יודעים משהו? בואו אני פשוט אעשה לכם את החיים הפשוטים.

193
01:08:38,900 --> 01:08:49,000
שנייה, אני רוצה לעשות לכם את החיים פשוטים, הנה. נפתח פייתון מ0, ותראו דבר פשוט מאוד. a פסיק b שווה ל.

194
01:08:49,000 --> 01:09:18,720
1 פסיק 2, ראית? עשיתי שני משתנים a וb שווים להיות משהו מתוך הטאפל 1-2, אז a זה 1, b זה 2. אוקיי? עד כאן הכל ברור? c פסיק d שווה מתוך רשימה 3-4. אוקיי? הנה c, הנה זה d. בסדר? נניח שלא הבנתם כלום.

195
01:09:18,720 --> 01:09:30,900
ממה שרפרפתי עליו פה מהר מאוד בפקינג ואן פקינג תבינו שזה סינטקס שהוא אפשרי ושהוא עובד בפייתון, כן פייתון יודע.

196
01:09:32,500 --> 01:09:48,460
לקחת ביטוי שהוא טאפל או רשימה הוא כן יודע להבין מתוכם ערכים נפרדים ולתת אותם למשתנים נפרדים באופרטור שווה כשיש לכם פסיק. וגם בפייתון וגם.

197
01:09:48,460 --> 01:10:18,360
זה גם יודע לעשות את זה בפונקציות. בסדר? זהו. אני לא רוצה לסבך לכם יותר את החיים בקלטה הזאת מה שאתם ראיתם כאן עבד בדיוק ככה. זה היה עובד פה כמו שזה היה עובד אם הייתי כותב פה את זה ב-VS-code. בסדר? כל זה יעבוד לחלוטין. נעשה פרינט A, B אותו דבר. C פסיק D שווה 3.

198
01:10:18,660 --> 01:10:29,940
ארבע, פרינט של C פסיק D, ותסמכו עליי שזה עובד ככה, כמו שזה היה עובד אם הייתי מגדיר פונקציה שעושה את זה, כן?

199
01:10:30,500 --> 01:10:47,860
אז, לא יודע, אני יכול אפילו להגדיר פה, דפיין, אה... לא יודע, דאבל ואל, שתקבל את שני פרמטרים, לא יודע, X פסיק Y, נקודתיים, אני ממש רוצה להראות לכם שתבינו, זה לא, אין פה שום דבר.

200
01:10:47,860 --> 01:11:17,440
ספוריטן, X פסיק Y, תסתכלו, תראו כמה זה פשוט, אוקיי? עכשיו אני יכול להגיד, אי שווה 10, לא יודע, F שווה 20, עכשיו אני אגדיר, לא יודע, O פסיק P שווה ל...

201
01:11:17,920 --> 01:11:47,400
דאבל ואל, של, F פסיק F. הנה. אולי זה עכשיו יראה לכם, על מה דיברתי. אוקיי? בבקשה. הגדירתי פה, בסלע הקטן הזה של הקוד, קודם כל, פונקציה קטנה, שנקבלת שני אינטג'רים כפרמטרים, והיא תחזיר, טאפל, של הערכים שלהם. פה אתם רואים, שאני בונה A-B, בעזרת טאפל, בונה C-D.

202
01:11:47,400 --> 01:12:06,760
בעזרת רשימה, ולבסוף אני בונה O ו-P, הנה אתם יודעים מה שהוא, הנה אני העיף לכם את זה, שאתם תראו את זה בלי משתנים מיותרים, ואני בונה פה עכשיו O ו-P בעזרת פונקציה שמחזירה טאפל, הכל יעבוד פה.

203
01:12:06,760 --> 01:12:36,760
פאנסל, בבקשה. אז פונקציונליות חביבה בפייתון, הוא כן יודע לערוז לכם ולפרוס לכם טאפלס ורשימות, לאינטגרים בנפרד וכולי. אתם יכולים גם לבדוק את זה עבור עצמכם, זה עובד בבוליאנים, בפלואוטס. אז יאללה, בואו נתרגיל את זה קצת. שאלה חמישית, אנחנו רוצים לקבוע האם...

204
01:12:36,760 --> 01:12:58,940
בעינתן הפונקציות שיש לנו כאן, האם מה שקורה פה אפשרי או לא אפשרי? אז בואו נסתכל. נניח יש לנו פה פונקציה שמחזירה טפל 2, 3, אז נגיד a שווה, מה שהפונקציה תחזיר. רגע, זה אפשרי?

205
01:12:58,940 --> 01:13:04,720
פונקציה היא תחזיר פה טפל 2, פסיק 3, ואנחנו מביאים לה רק משתנה 1.

206
01:13:04,720 --> 01:13:15,220
אז בוא נגיד את זה ככה, אם זה אפשרי, אז ל-a ייכנס פשוט העבר הראשון, ה-2 מתוך הפונקציה הזאת.

207
01:13:15,220 --> 01:13:22,720
עכשיו, כמובן שפה כתוב a פסיק b שווה few, אז זה יעבוד כי אתם ראיתם את זה עכשיו, אתם ראיתם את זה עכשיו ב לייב.

208
01:13:22,720 --> 01:13:34,220
הטייפ של a הולך להיות אינטגר, ואם נתפיס את a נקבל 2, זאת אומרת, ה-a פסיק b שנמצא פה ראינו עכשיו שזה עובד, a לבד.

209
01:13:34,220 --> 01:14:04,020
אולי, בהחלט יש משהו לתחוף ב-a מתוך זה. עכשיו פה בפונקציה אחרת, נקרא לה do, זה שונה. פה יש לנו רק ריטרן וואלי שהוא אינטגר. אז פה יש לנו a שווה do, אז פשוט a הולך להיות 4 וזהו, כן, אינטגר. אבל פה אנחנו רואים משהו אחר, a פסיק b שווה מה ש-do תחזיר, אבל do מחזירה אינטגר, אז מה יקרה? גם a וגם b?

210
01:14:04,020 --> 01:14:19,220
יהיו אופטר אינטג'ר, כן, לא, אני לא יודע, תגידו לי אתם. אז על פי המצגת, כל האפשרויות יעבדו, חוץ מהאחרונה, זו שבה אנחנו מנסים לארוז אינטג'ר,

211
01:14:19,220 --> 01:14:32,780
וכאילו, להחזיר אותו כאן באופרטור שווה, כאילו שזה טאפל. זה לא יעבוד. אז, יש לנו כאן, את הקוד של q5,

212
01:14:33,780 --> 01:15:03,560
ואפילו הרזתי את הדוגמא האחרונה הזאת כאן סביב פונקציה do בטריי אקספט רק כדי לא להגיע לשגיאה. ובואו ננסה את זה, יאללה. איפה q5 שלי? איפה הסל של q5? הנה אתה. אם אני יכול להריץ את q5, שימו לב, אגב, אני עשיתי פה from q5, אימפורט רק את הפונקציה q5, לא עשיתי אימפורט לפונקציה do.

213
01:15:03,560 --> 01:15:33,340
ו-foo. בואו נראה אם פייתון יתמודד עם זה. אני סקרן לדעת. אה, הוא כן ידע להתמודד עם זה, איזה כיף. אז בואו נראה מה הוא כותב לי. קודם כל, שני הדברים שעשינו עם -foo עובדים. a שווה -foo, הנה הטייפ של a והוואליו. אה, וואו, תראו את זה. האמת זה די משמעותי.

214
01:15:34,340 --> 01:16:02,840
חכו שנייה. או, זה מעניין. מה היה לנו פה? אין פה a לבד. אהה, a לבד הולך להיות, אז אני טעאתי אתכם, אם מקודם אמרתי שזה אינטג'ר לבד, אמרתי אני לא בטוח מה הוא יקבל, הוא יקבל את שתיים? לא, הוא הולך להיות טאפל. שזה הגיוני בתכלס, משתנה שווה טאפל.

215
01:16:02,840 --> 01:16:14,740
הנה, a שווה foo, הנה הטייפ והוואלי שלו, טאפל. ועד כשעשינו a פסיק b שווה foo, אז a קיבל בנפרד את ה-integer 2.

216
01:16:14,740 --> 01:16:30,720
ואז כשאחר כך a שווה do, זה היה פונקציה שהחזירה רק 4, כן? זה היה פונקציה שהחזירה 4, אז a שווה do היה בסדר, אבל כשאמרנו a פסיק b שווה do, זה לא עובד.

217
01:16:30,720 --> 01:16:50,880
כי הבאנו פה פרינט שאני כתבתי בתור שגיאה. כי אי אפשר לעשות את זה. והנה אני גם רוצה להראות לכם את זה אולי בצורה ככה, אני נעיף את זה. אני רוצה להראות לכם את זה בצורה נגישה גם, תראו גם פייתון. עכשיו אני אומר.

218
01:16:53,760 --> 01:16:56,780
יש הבדל בין לעשות a פסיק b שווה 4.

219
01:16:57,420 --> 01:17:10,820
הלו I think there is no big difference�תי זה ממש הפה היה ממש היום הרגיש את זה התקח לקראת את זה מצדקה ורטע הקשור בתוך צורה רגועה.

220
01:17:10,820 --> 01:17:23,780
ראשון אגמה רטרן 4 הם שומעים את זה עכשיו אני אומר אי פסיק בי שווה do סוגריים הנה זה ממש הפק אין פק תראו את זה אי אפשר לעשות אין פק לאובייקטי אותך.

221
01:17:23,780 --> 01:17:32,160
אי אפשר לעשות אין פק לאובייקט אינטג'ר שאין לו איתרציות בפנים אין שום דבר שאפשר לעבור על פניהם זאת אומרת.

222
01:17:32,160 --> 01:17:44,860
הסינטקס הזה של המשתנה פסיק עוד משתנה זה דורש משהו פקת משהו שיש לו כמה כמה דברים כמה אינדקסים.

223
01:17:44,860 --> 01:17:53,060
רק פה אם נעשה דפיין כמו שראיתם ואז פה ואז נעשה כאן רטרן 5 פסיק 6 עכשיו עם הפונקציה הזאת.

224
01:17:53,880 --> 01:18:05,860
a שווה 4 אז פתאום זה כן יעבוד נעשה a פסיק b שווה 4 אז פה הוא יעשה אן פק הוא ייתן ל a את 5 וייתן ל b את 6.

225
01:18:05,860 --> 01:18:15,240
אוקיי אני חושב שראינו פה דברים יאללה תרגיל אחרון לתרגול הזה תרגיל 6.

226
01:18:15,240 --> 01:18:25,100
לא יודע אם הספקתם לראות את זה בקורס אלגברה לינארית יש מצב שגם חלק מכם לא יראו את זה אני לא יודע בכל מקרה תכירו את זה כבר עכשיו.

227
01:18:25,100 --> 01:18:35,020
אומרים לנו תכתוב פונקציה שמקבלת רשימה נגיד חד ממדית היה לנו רשימה של x.

228
01:18:35,020 --> 01:18:42,320
ומעלה הכוונה היא מעלה אלגברית חזקה. d.

229
01:18:42,320 --> 01:18:53,520
ואנחנו צריכים לבנות את מטריצת ונדרמונד של זה מה זה מטריצת ונדרמונד אתם שואלים אז נגיד לכם.

230
01:18:53,520 --> 01:19:12,300
עבור רשימה של x עם כלשהם מx1 עד xn תחשבו על זה פשוט מספרים. ועבור מספר שלם חיובי d שוב אני מדבר איתכם על חזקה. כן? אז מטריצת ונדרמונד תהיה מוגדרת ככה.

231
01:19:13,020 --> 01:19:42,220
עמודה ראשונה, החדות. עמודה שנייה, זה פשוט הxים. עמודה הבאה בתור היא כבר x1 בריבוע x2 בריבוע x3 בריבוע וכן הלאה עד xn בריבוע. עמודה האחרונה זה כל הxים בין 1 עד n בחזקת d. או במילים אחרות, כל שורה במטריצת ונדרמונד זה בעצם.

232
01:19:42,220 --> 01:20:11,620
שורת כל החזקות מ-0 כולל עד d כולל של אותו x i כלשהו. אגב, זה למה העמודה הראשונה כולה מ-1. כי תזכורת, כל מספר בחזקת 0 הוא 1. בעצם, מה שיש לנו כאן, זה פשוט את כל החזקות בין 0 עד d של כל הxים האלה, מהרשימה.

233
01:20:11,620 --> 01:20:21,740
וזה יוצא מטריצה דו-ממדית שהיא d פלוס אחד עמודות ואין שורות.

234
01:20:21,740 --> 01:20:39,100
אז עכשיו אם אנחנו רוצים לבנות את המטריצה הזאת, זה לא כזה קשה האמת. האמת זה זה אפילו די פשוט, כן? אנחנו בונים מטריצה חדשה ואנחנו אומרים מה? כל שורה במטריצה תהיה בנויה בדיוק ממה שראיתם.

235
01:20:39,100 --> 01:20:54,560
לכל, תראו מה קרה, אנחנו קראנו לרשימה שלנו דאטה. זה אגב ינחה אתכם עוד מעט לגשניירא לכם מה משמעות של מטריצה כזאת מוזרה, מה היא עוזרת לנו, אני כבר אראה לכם, אבל עוד שנייה.

236
01:20:54,560 --> 01:21:24,460
אנחנו ניקח את הרשימה הזאת של הx'ים, נקרא לה דאטה, נבנה מטריצה מ-0, נגדיר ככה, 4 פוינט אין דאטה, כלומר, לכל נקודת מידע, נבנה שורה למטריצה שתהיה בנויה באופן הבא, או ליסט קומפיינשן. לכל d, בריינג' שבין 0 עד d ממש, degree, אז אתם מבינים? לכל d.

237
01:21:24,860 --> 01:21:54,440
לכל מספר בין 0 עד ל-d כולל, ל-degree, פשוט ניקח נקודת הדאטה, נעלה אותה בחזקה ל-d הנוכחי, כן? זה לא מסובך, כן? x1 בחזקת 0, x1 בחזקת 1, x1 בחזקת 2, אתם רואים? פוינט חזקת ה-d הזה, שנע בין 0 למעלה. כל זה נעשה אפנד לרשימה.

238
01:21:54,440 --> 01:22:24,440
של כל הסיפור הזה, אתם רואים? list comprehension. ואז לדוגמא אם אנחנו רצינו להריץ את זה, אז יכולנו לבנות לדוגמא רשימה של שלושה xים, אחד שתיים שלוש, נניח שהמעלה תהיה שלוש, ונבנה מטריצה שזה, אנחנו באמת נקבל מטריצה, נוכל גם להדפיס אותה, אני רוצה להראות לכם את זה, של השש, הנה הקוד, בסדר, אז נביא את זה לכאן,

239
01:22:24,440 --> 01:22:54,440
יש לי אפילו ערכים הדיפולטיביים שאתם ראיתם שמה ועכשיו כל מה שאני צריך לעשות זה פשוט וונדרבונד מייטריקס נריץ אותה, את הפונקציה. אוקיי אז ככה זה נראה. אחד בחזקת לא משנה מה היא תנחם אחד ואז כשיש לנו שתיים אז עכשיו יש חזקות ששתיים: שתיים חזקת 0, שתיים חזקת 1, שתיים חזקת 2, שתיים חזקת 3.

240
01:22:54,440 --> 01:23:10,860
3 ב-0, 3 ב-1, 3 ב... בקיצור אתם רואים. ופה אתם גם רואים צורה אחרת שמדפיסה את התוצאה של זה לבד. עכשיו, טריוויה.

241
01:23:11,820 --> 01:23:24,280
ומה מטריצת ונדרמון שימושית? למה עוזר לנו לקחת נקודות כלשהן ולחשב במטריצה את כל החזקות של הנקודות האלה?

242
01:23:25,120 --> 01:23:38,760
אז הנה קצת הצצה לעתיד שלכם בתואר, לפחות של רובכם. אחד מהדברים שאנחנו יכולים להיעזר במטריצת ונדרמון בשבילו, תחשבו את זה ככה.

243
01:23:38,760 --> 01:24:08,580
אתם יודעים איך שבאלגברה מלמדים אתכם שמטריצות זה פשוט צורה אחרת לפתור מספר של משוואות? זאת אומרת יש לכם וקטורים, אתם רוצים לפתור למצוא את הוקטור, אתם רוצים למצוא מקדמים לווקטור הזה, נכון? אומרים לכם אז הנה המטריצה שהיא מייצגת את כל המשוואות הליניאריות הייתם רוצים שהן יהיו בלתי תלויות וכולי, בקיצור, לפתור משוואות, למצוא נעלמים.

244
01:24:08,580 --> 01:24:32,720
כן? לחשב וקטור פתרון. אז מה הקטע? אתם יכולים לחשוב על זה שתחשובו שכל האיקסים האלה, כל האיקסים האלה, הם בעצמם יכולים להיות וקטורים שמייצגים נקודות כלשהו, באיזשהו מרחב n ממדי, או כמה ממדים כלשהם.

245
01:24:32,720 --> 01:25:02,640
אז הקטע הוא שבעזרת מטריצת ונדרמונד, אתם בעצם יכולים לבנות מערכת משוואות שהפתרון שלה, זה תקשיבו טוב, הפתרון של אותה מערכת משוואות, שאתם בונים בעזרת מטריצת ונדרמונד של נקודות במרחב, הפתרון של מערכת המשוואות יהיה המקדמים של פולינום, שיעבור בצורה...

246
01:25:02,640 --> 01:25:32,440
הכי מיטבית דרך כל הנקודות שאתם מביאים. מה שאנחנו נקרא לזה אינטרפולציה פולינומיאלית. זאת אומרת, תאמינו לי שאיפשהו על הדרך, אנחנו בעצם מחשבים, אתם יכולים גם להגיד נגזרת, להשוות אותה לאפס, בכיף. לא אומר לכם שנגזרת שווה לאפס איפשהו על הדרך. אני אומר לכם, בעזרת מטריצת ונדרמונד, אנחנו נוכל לחשב את המקדמים של הפולינום.

247
01:25:32,440 --> 01:25:45,860
ה-d-ממדי או כמה ממדים שזה לא יהיה בדרך לשם, שהוא הכי, הכי, קרוב ללהיות זה שעובר הכי קרוב לכל הנקודות בסך הכל.

248
01:25:45,860 --> 01:25:55,900
אתם יכולים להגיד ריבוע מרחקים, בלה בלה בלה, זה אולי קצת כבד עליכם כי אתם סמסטר ראשון, אבל סתם שתקבלו מוטיבציה.

249
01:25:55,900 --> 01:26:25,500
מטריצת וונדרמונד זה כלי שגם אם אתם לא תראו אותו עכשיו, גם אם אתם לא תיתקלו בו בקורס אלגברה הראשון שלכם, מתישהו במהלך התואר, אתם אולי תיתקלו בזה, ואם כן, אז שתדעו. אפשר לפתור מערכת משוואות ביחד עם כל החרטמון הזאת, וזה דווקא שימושי. אגב. היי, הגעתם לסוף התרגול, כל הכבוד לכם.

250
01:26:25,500 --> 01:26:29,240
הנושא של התרגול הבא יהיה סיבוכיות.

251
01:26:30,460 --> 01:26:39,480
אבל אתם יודעים משהו? תראה... יש עוד שלוש קופיות אחרונות שהייתי רוצה להראות לכם, בגלל שאתם הגעתם עד לפה ולא ברחתם.

252
01:26:41,360 --> 01:26:49,420
אז זה לא בך חומר שהוא חובה להשוואה אבל בא לי להראות לכם אותו בכל מקרה. טריוויה אם תרצו.

253
01:26:49,900 --> 01:26:53,520
אתם זוכרים שבאחד מהתרגולים הקודמים אמרנו לכם:

254
01:26:53,520 --> 01:26:58,980
בואו ננסה להדפיס את כל המספרים שמתחלקים בשבע בין 1 עד ל-100

255
01:26:59,620 --> 01:27:14,140
ואמרנו אין בעיות, נבנה ריינג' חכם, ריינג' שמתחיל כבר בשבע, נגמר ב-100 כולל וקופץ שבע כל פעם.

256
01:27:15,280 --> 01:27:22,880
אוקיי. מה לגבי? תכתבו לי לולה שתדפיס את כל המספרים שמופיעה...

257
01:27:23,100 --> 01:27:53,000
כל המספרים שיש בהם את הספרה שבע. עכשיו, אתם יכולים להתחכם ולכתוב לי ריינג' דומה, אבל אז גם להדפיס לי את כל המספרים שהם 70 ומשהו, באיזשהו תנאי. אתם יכולים להתחכם. אבל אני אומר לכם, לפייתון יש פונקציונליות מעין סוג כזה של דבר שיש לו איטרציות, קצת כמו לולה, לא בדיוק, שיכול...

258
01:27:53,000 --> 01:27:58,000
אבל נותנת לנו את זה בצורה שהיא לא כל כך בזבזנית מבחינת זיכרון.

259
01:27:59,080 --> 01:28:08,100
אז תכירו קונספט שקוראים לו גנרטור, או יותר נכון פונקציית גנרטור.

260
01:28:08,100 --> 01:28:15,880
מה הפונקציה הזאת עושה? אני אתן לכם דוגמא. הנה מה שיש.

261
01:28:15,880 --> 01:28:22,900
נגיד שאני רוצה באמת לענות על השאלה שאמרתי לכם כאן. תכתבו לי לולאה.

262
01:28:22,900 --> 01:28:30,700
תכתבו לי משהו שיביא לי אחד אחרי השני את כל המספרים שיש בין את הספרה 7 איפשהו.

263
01:28:30,700 --> 01:28:52,500
אז אני יכול להגדיר גנרטור שעובד ככה, נגדיר, טוב בינתיים זה פשוט נראה כמו פונקציה, נגדיר פונקציה sq-numbers שיש לה התחלה ויש לה סוף, ובתוך הפונקציה אני אומר כזה דבר, לכל i ברנג' שבין ההתחלה לסוף, עכשיו ברור לכם שזה.

264
01:28:52,500 --> 01:29:22,460
לכם שהייתי צריך לכתוב פה end פלוס 1 אבל מילא אנחנו בשקופית בונוס אז דילו וזה. עכשיו אני יכול להתחכם ולהגיד איף הקרקטר 7 מופיע בגרסת הסטרינג של i הנוכחי זאת אומרת בצורה מתחכמת אני בעצם אמרתי אם הספרה 7 מופיע במספר פשוט בצורה של תווים כי אני אצלן, הנה מה שאני כותב פה במקום ריטה.

265
01:29:22,460 --> 01:29:52,460
"יילד" את אותו "איי". אז מה הכוונה? יילד פה זה לא, אם אולי אתם מכירים את המילה הזאת, לא הכוונה "אני מוותר", "איי יילד, איי יילד, פליז אנד זה פייט", אלא יילד בתור תוצר או משהו שאני מניב. כלומר, פונקציית ה... אגב המילה יילד הופכת את זה לגנרטור ולא לפונקציה, אז הגנרטור הזה,

266
01:29:52,460 --> 01:30:22,440
מניב i שעונה על התנאי הזה כל פעם שאני נעזר בגנרטור הזה. איך? תסתכלו לדוגמה, תראו את זה. לכל n שנמצא בתוך הגנרטור sq numbers הזה שמתחיל ב-1 ונגמר ב-100. והפה אני עושה פרינט של n. אז מה שקורה פה?

267
01:30:22,440 --> 01:30:32,140
זה באמת גוף כזה? כי אתם רואים שהוא מופיע פה ב-4, זה גוף שאפשר לעבור עליו באיטרציה.

268
01:30:32,140 --> 01:30:45,340
עכשיו, זה לא שכל זה נשמר רציף בזיכרון, זה לא שעכשיו שהגדרתי ב-define את הסיפור הזה, יש לי את כל המספרים שעונים לדרישה בזיכרון, לא.

269
01:30:45,340 --> 01:30:51,740
פייתון יהיה חשב והוא יעבור לאיבר הבא בתור שעונה על הדרישה.

270
01:30:51,740 --> 01:31:12,160
והוא ייתן אותו, הוא ייתן לי אותו בכל איטרציה. בעצם, ושוב, זה קונספטים שאולי טיפה מתקדמים, אבל אפשר להגיד שכל איבר שנמצא בגנרטור הזה, שהגנרטור הזה יביא לי, זה איבר שהוא פשוט יגיע אליו באיטרציה הבאה על פני הגנרטור.

271
01:31:12,160 --> 01:31:42,160
אז עכשיו כל הדיבור המוזר הזה ועכשיו שקופית אחרונה שתסביר את זה קצת בקצרה. אז כמו שאמרנו זה לא נשמר הכל בבת אחת בזיכרון זה פשוט עובר עליו בצורה איטרטיבית, אחד אחרי השני אחרי השלישי, קצת כמו הקונספט של ריינג', אמרנו לכם שריינג' זה לא מה שכל הערכים בבת אחת נמצאים בזיכרון, אבל פייתון יודע לעבור על פני הריינג' באיטרציות. אחד אחרי השני אחרי הש..

272
01:31:42,160 --> 01:32:12,160
שלישי והוא יעבור על פני כולם אם תבקשו ממנו וככה זה בגנרטור כשאתם עוברים עליו באטרציה אחד אחרי השני אז הוא שולף את האיבר הבא בתור שעונה לדרישה אתם יכולים לחשוב על גנרטור בתור ריינג' מתוחכם עוד יותר מריינג' רגיל אפילו, פה אתם רואים נעזרנו בריינג' ועדיין הוספתו פנאי, אז אתם יכולים קצת לחשוב על זה

273
01:32:12,160 --> 01:32:21,220
גנרטור זה קצת כזה What if ריינג', but way more hyper-specific, משהו כזה.

274
01:32:22,360 --> 01:32:41,700
אז, דרך אגב, כשאתם ניגשתם לגנרטור ושלפתם איבר מהגנרטור, זה יכול להיות באיטרציית 4, או זה יכול להיות בעזרת משהו אחר, המצב של הגנרטור נשמר. זאת אומרת, אם שלפתם מהגנרטור מספר,

275
01:32:41,700 --> 01:33:11,660
באיזושהי צורה, אז הפעם הבאה שאתם תיגשו לגנרטור, הוא יביא לכם את הערך הבא בתור. אז, זה אומר שכאילו, מה? מה אנחנו יכולים לעשות עכשיו עם גנרטור? אם אנחנו רוצים שוב להתחיל אותו מההתחלה, אנחנו נצטרך לקרוא לו מחדש שוב, באמת קצת כמו בריינג', האמת, רק להריץ אותו מחדש, יאפס אותו, ואז נוכל, נעשה עליו איטרציות מההתחלה.

276
01:33:11,660 --> 01:33:41,660
והלאה. אוקיי, אז אני מדבר על איתרציות, אני מדבר על כמו ריינג', אני מדבר כמו פה, כמו שם. אז אדון מתרגל, בבקשה, תגיד לנו איך אנחנו נגשים לאיתרציות האלה של, הגנרטור, איך אנחנו מקבלים מהגנרטור, את הערכים שהוא יכול לג'נרט. אם, אתם רוצים להגיד את זה ככה. איך? אז אני שואל אתכם, חוץ לאופרטור,

277
01:33:41,660 --> 01:34:11,660
אם איזה עוד אופרטור יכול לתת לנו איטרציה פני זה, יש אופרטור בשם נקסט, אז תסתכלו שנייה, נגדיר, תראו משהו, נגיד שנמברס שווה גנרטור sq_numbers מ-1 עד 100, נכון? תראו קטע כזה, זה נראה קצת כמו פונקציה, אבל היא מחזירה ב יילד, לא בריטר, ונגיד גנרטור הזה תביא אותו לנמברס, עכשיו נמברס זה פחות או אטרף, אז בואו נקרא לה, נכון

278
01:34:11,660 --> 01:34:41,660
זו קופי של הגנרטור, מה שנקרא התחלנו את הגנרטור, הגנרטור מוכן לתת לנו דברים, עכשיו כשאני אומר פרינט נקסט של נאמברס הוא יעשה לי יילד לאי כלשהו, וכשאני אעשה עוד פעם פרינט נקסט נאמברס הוא יביא לי את האי הבא בתור, ועכשיו אני רוצה באמת להראות לכם מהקוד אקסטרה, אז בואו תראו שנייה, נסגור את זה, הנה הגנרטור, יש לנו סקי של גינרטור, שאני

279
01:34:41,660 --> 01:35:11,660
יש לנו פה הגדרה, אה, על הדרך, ניתן פה דפולט ואליו, n שווה 101, יאללה, בואו נבדוק את זה, נבדוק את האינטראקטיב שלנו, הנה גנרטור סטאף, אה, סבבה, אז כמו שראינו את הקוד פה, אני רוצה להראות לכם את זה בדיוק, נגיד, נאמברס שווה sq, נאמברס, נלך עם הערכים הדפולטיביים, אני לא אשלוח פרמטרים, ועכשיו אני רוצה, בדיוק כמו שראיתם, פרינט את,

280
01:35:11,660 --> 01:35:41,660
next של numbers. ונעשה זה שוב, נעשה זה שוב, שלוש פעמים אני רוצה להדפיס את ה-next של הגנרטור הזאת, מזכיר לכם, הוא בסך הכל מביא לי מספרים i בתוך הריינג' הזה שמתחיל ב-100 עד 100. שיש בין 7. בואו נריץ את זה ונראה מה הוא יראה לנו, run, אוקיי, אז ה-next הראשון הוא יודע שזה 1, וה-next של ה-number שṇa מאוקרות 2 וה-next של ה-number של 2 וננסה לזה כדי להציל את זה המיועדון. ונסתובב בזה בטוח שנמצא ולהתמשיך להחזיק את זה כדי להקשר את זה רק בעזרת ההזדמה

281
01:35:41,660 --> 01:36:11,660
בעצם זה האיטרציה הראשונה שזה מראה לנו את זה, ואז אתם רואים, הטור הבא פשוט מראה לנו את האיטרציה הבאה בטור, והטור הבא יראה לנו את האיטרציה הבאה בטור. עכשיו יש דרך כמובן להריץ את הגנרטור הזה שוב, אני יכול פשוט להגיד number 2 שווה ל-sq numbers, כן? -כן.

282
01:36:11,660 --> 01:36:41,660
אז זה פשוט קופי אחר של הגנרטור, בסדר? זה קופי אחר. ועכשיו פה אני יכול להריץ גם. Next של ניימברס המקורי ושתיים. והמקורי ועוד שתיים. אני רוצה להראות לכם את זה, הנה. מגניב, נסגור את זה, נפתח את זה שוב. אוקייפ אז מה עשיתי? קודם כל, זה השלושה ראשונית

283
01:36:41,660 --> 01:37:11,660
שונים כאן, 7 17 27, עכשיו תראו קטע, תראו קטע, אמרתי נמבר 2 שווה גנרטור הזה, ועכשיו אני מדפיס את נמבר הרגיל, אני ממשיך ביתרצצ של הרגיל, של נמברס, אתם רואים? ואז אני עושה נמבר 2, אוקיי, הנה הראשון של נמבר 2, ואז אני שוב ממשיך עם נמבר המקורי, 17. אוקיי, אז בואו נעשה עכשיו ניסוי אחר, מה אם...

284
01:37:11,660 --> 01:37:41,260
מה אם אני אעשה כזה דבר? Numbers, עכשיו אני אעשה כזה 4i in range 10, print את print next של Numbers. נקודתיים כמובן.

285
01:37:42,100 --> 01:37:55,620
אוקיי, בואו נריץ את זה, מרנסל, כן, כל המספרים האלה של 70, בואו נריץ את זה עם 20, מה קורה אם אני הולך מוגזם?

286
01:37:57,220 --> 01:38:26,460
אני רוצה לשבור את הגנרטור, אוקיי שברנו את הגנרטור, מה קרה? Stop iteration, כלומר אני ניסיתי לעשות איטרציות יותר ממה שהיה לי לשים בגנרטור, אוקיי אז לבסוף אני לא אשבור אני אגיד פשוט 4i in range של נאמברס, מעניין?

287
01:38:26,460 --> 01:38:56,280
הריינג' של הגנרטור, הוא יודע לחשב את זה? Generator object cannot be interpreteded as an integer, הוא לא יודע לחשב את זה, אוקיי? לא ריינג' של נאמברס, סליחה, לנקט של נאמברס, האם זה הוא ידע לחשב לי? Object of type Generator has no length, בעיה, אין בעיות, אז...

288
01:38:57,160 --> 01:39:26,060
איך היינו יכולים לעשות את האיטרציות האלה? לדעתכם? יש לכם תיאוריה, איך יש לי פה גנרטור? ואני רוצה את האיטרציות האלה, אולי, אני יכול לכתוב משהו מאוד מאוד מוזר, while numbers, print next numbers, stop iteration.

289
01:39:26,860 --> 01:39:55,880
אוקיי, הוא לא הבין את נאמברס בתור משהו שנהיה פורס, אז אם כבר, אני יכול להגיד כזה דבר, אני יכול להגיד כזה דבר, אני יכול להגיד, וואייל, אתם יודעים משהו? אני לא אגיד. זה...

290
01:39:55,880 --> 01:40:23,180
אני משאיר לכם את זה בתור שאלה טריוויאל לעצמכם, בחלק הזה של התרגול שהוא אפילו לא חובה. נניח שיש לכם גנרטור, איך אתם יכולים לעשות עליו איטרציות, מבלי לדעת? אתם רוצים להדפיס את כל מה שהגנרטור יכול להביא, בלי לדעת כמה נשאר בגנרטור. איך אתם הייתם עושים את זה? שאלה טובה.

291
01:40:24,520 --> 01:40:53,820
אז נתראה שבוע הבא. רגע, אתם עדיין פה? אוקיי, בסדר, עבדתי עליכם. זה הרבה יותר פשוט. פור משהו אין הגנרטור, אז זה כן יעבוד. הרי אופרטור אין יכול פשוט לעשות לנו איטרציה על הגנרטור. זוכרים שאמרנו שאופרטור אין עושה איטרציות? זה יעבוד, אוקיי? רנסל, גנרטור סטאפ.

292
01:40:53,820 --> 01:41:06,280
אז משבע עד 97 כולל, עשינו איטרציה על גנרטור מהתחלה ועד הסוף, וזה עבד. עכשיו ברצינות חבר'ה, ביי ביי.

