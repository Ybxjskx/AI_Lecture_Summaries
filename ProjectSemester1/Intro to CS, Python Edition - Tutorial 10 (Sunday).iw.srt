1
00:00:00,000 --> 00:00:30,000
קורקטו בכלל... ..לא. טוב, בסדר, זהו. טוב, אז היי, אז אני מבין שלא יהיה לכם הרצאה היום, נכון? כן. ואז ביום רביעי מה יקרה? שלום... עקדם בעולם. בסדר. אוקיי, טוב, בכל מקרה, אז לגבי התרגול של היום, הנושאים של התרגול היום יהיו לכאורה מה שאתם רואים כתוב פה, אנחנו נעשה חזרה קצת מקיפה על רשימות מקושקת.

2
00:00:30,000 --> 00:01:00,000
מה זה מסיים שחוץ לכך וחוץ ברחוב כאן? שלום, איך אשמת איתכם? פחות או יותר!

3
00:01:00,000 --> 00:01:30,000
מחסנית זה סתם וריאציו ובסדר, מקווה שנספיק את כל התרגולות. אז יאללה, בואו באמת נתחיל מהקטע של רשימות מקושרות, אז כרגע אני לא מאחל משהו חדש, אבל בכל זאת אני אציג את זה כאילו שזה מוצא חדש. מה זה בכללי הרעיון הזה של רשימן קושרת? פשוט תחשבו על זה ככה, כבר כ�שלימדנו, התחלנו ללמד אתכם את פייתון, ואז כשדיברנו איתכם על אובייקטים, בעצם ניסינו להראות לכם את הקטע הזה של וואל אט שמעו, זה שיש לכם דברים שנמצאים ב�

4
00:01:30,000 --> 00:02:00,000
רציפה אחד אחרי השני כמו ברשימה, מערך, מה שזה לא יהיה זה לא אומר שנמצאים באותו מקום רציף בזיכרון, זה לא בכך אומר את זה. למעשה ברשימות מה אמרנו לכם כל איבר זה יותר כמו מצביע לאיזשהו אובייקט שנמצא איפשהו בזיכרון ואין שום הבטחה שהאובייקטים עצמם המידע הפיזי יהיה באמת רציף אחד אחרי השני בקטובט הפיזי, שאלה?

5
00:02:00,000 --> 00:02:30,000
בסדר, אוקיי. אבל לפחות אתם עוקבים עד כאן, לפחות רק היה רעיון של דברים שאנחנו אומרים כן זה ברשימה, כן זה במערך, זה לא אומר שבזיכרון הם פיזית נמצאים אחד ליד השני. זה חשוב שאתם תכירו את ההבדל הזה, שרק בגלל שיש לכם רשימה או מערך, לא אומר שדברים פיזית נמצאים צמוד אחד לשנים בזיכרון. לא בכל שפת תכנות. לדוגמא בפייתון זה לא ככה. אז זה טוב שלימנו אתכם את זה, מאז כשאנחנו מדברים כם על רשימות מקושרות.

6
00:02:30,000 --> 00:03:00,000
זה יהיה לכם יותר פשוט להבין את הרעיון הזה של מה זה בעצם הקטע של רשימה מקושרת. תחשבו כזה, אתם זוכרים שדיברנו איתכם על סטרוקט בתרגול קודם? סטרוקט, סטראקט, בסדר, סליחה, סליחה, אני... זה היה פורקט אבל סליחה, סטראקט,נו, הקטע כזה של כזה,  כזה... איזושהי תבנית שיש לה כמה שדות של משתנים, וכל זה אנחנו קוראים לזה כאילו במחרת אובייקט אחד. אתם זוכרים את הרעיון הזה? לא שמע?

7
00:03:00,380 --> 00:03:30,380
זהו, כשניסינו להגיד כאילו data class, כאילו צומת, כאילו ניסינו להגיד, רגעייתום יש הרבה דרכים איך לממש את זה וזה, לא משנה, אבל בסך הכל מה שאני רוצה להגיד לכם זה בערך הרעיון הזה, הרעיון הזה שיש לכם ככה איזשהו בלוק, איזשהו תבנית כזאת, שיש לה כמה שדות משלה, כמה נתונים שהיא יכולה להאכיל, ואז בדרך כלל, מה שכאילו מקובל לעשות, זה שהשדה האחרון בדרך כלל יהיה פשוט בעצמו מצב

8
00:03:30,380 --> 00:04:00,380
על כזה אובייקט, כזה צומת שנמצא במקום אחר. זה כאילו, זה לא אותו דבר כמו נניח חשימה רגילה או מערך, שמה, זה פשוט הן כולם מסדרים אחד אחרי השני, יש להן אינדקס, ואתם יודעים בדיוק איפה הן. זה לא עובד ככה. פה ספציפית הגישה היא תמיד מחייבת אותנו לעשות מעבר בין צומת אחד, לצומת שני, לצומת שלישי, לצומת רביעי. פשוט חייבים לגשת אל הנקסט של מישהו כדי לראות את הנקסט.

9
00:04:00,380 --> 00:04:30,380
ארבע בתור, לגשת לנקט שלו כדי לראות הארבע בתור, זה פשוט מצביעים לצומץ הבא, מצביע לצומץ הבא וכן הלאה וכן הלאה. אז כן, דרך אגב, עכשיו אני רק רוצה שתכירו איפה אתמיכד מינוח, כשאנחנו נגיד צומת, קוד קוד או nose, זה הכל אותו דבר בדיוק. מוכר יותר כשידברו איתכם בתואר לגבי גרפים, אתם בכלל תראו איך הדברים האלה מתקשרים, אבל עוד בפני כן, שתדעו עכשיו, כשאני אומר nose, צומץ, קוד קוד, אותו דבר בדיוק, שלא...

10
00:04:30,380 --> 00:04:53,860
מילים אותה משמעות. בדרך כלל המינימום שיש להם מצביע ל node שהוא פשוט הבא בתור, זה למה אנחנו נגיד מצביע הנקסט, לפעמים יכול להיות שאנחנו נבנה כזה מבנה של רשימות מקושטת שיש להם גם מצביע של previous, מה שנקרא רשימה מקושרת דו-כיוונית כזאת, אבל לא חובה, זה תלוי במבנה שלנו.

11
00:04:54,760 --> 00:05:24,760
זה מבחינת כאילו הקונספט הכללי ממש, יש שאלות לפחות לגבי הרעיון הזה? אוקי בואו נעבור לשלבית הבאה, ונראה דוגמה למימוש, זה רק דוגמה, יש לנו פה קוד, אנחנו נעזר בדאטה קלאס, אנחנו אפילו לא יודע, נעבד איזה משהו שקוראים לו טייפ וואו סתם בשביל שיהיה לנו מנוח, שאנחנו נוכל להגיד המילה נוד היא כשלעצמה משתנא, תתעלמו מזה זה סתם לשם המימוש, אתם לא

12
00:05:24,760 --> 00:05:54,760
ואני אזכור את זה בעל פה ואנחנו נגדיר לעצמנו באמת כאילו קלאס אבל זה תדחו אחר כך למונחי עצמים נגדיר אובייקט מסוג node ויהיו לו, לא יודע, rally, ארבע שדות, יהיו לו שדה ID שדה X שדה Y והם כולם אינטג'רים ויהיה לו שדה Next שהוא בעצמו Node. אז למה לא? מותר לי! אז פה אני יכול לקחת כזה אובייקט ולהתחיל להשתנה מהסוג הזה. אני אומר Node

13
00:05:54,760 --> 00:06:24,760
תראו, n קטנה, node שווה node בגדול, ואז אני פותח סוגריים. כאילו שאני קורא לפונקציה ושולח לה פרמטרים. אז מה שאני עושה פה בעצם, אני מהדחה, מהדחה כזה אובייקט, כזה קלאס מסוג node, עם הנתונים האלה. אני שולח לו, לא יודע, 1, 10, 20, אז כאילו: אני מהדחה עכשיו node, עםid 1, x שווה 10 ו-y שווה 20. הnext שלו, node, יש לו החברה מחדר של none. נניח שהדבר הזה פשוט

14
00:06:24,760 --> 00:06:54,760
צומת יחיד, אין לו מישהו שהוא עבר בתור ולא יודע, אני יכול אפילו להעתיק מצביע, אני יכול להגיד מייליסט שווה נוד כי בתכלס, אם באמת חושבים על זה, לפחות לפי איך שאנחנו מגדירים נוד ככה, אפשר להגיד שר שימה מקושרת זה פשוט הצומת הראשון שלה, כי הצומת הראשון זה שמצביע בארבעים בתור שלו לכל השאר האיברים, אז פשוט יהיה, זה מה שזה יהיה. אז,

15
00:06:54,760 --> 00:07:24,760
אתם אפילו ממש רואים דוגמא ממחישה לזה, תראו את הסינטקסט, אני יכול לכתוב node נקודה נקסט, זאת אומרת, אני עכשיו אומר, לך למשתנן node, שזה כאילו כל אובייקט קלאסי של זה דבר, תיגש לשדה נקסט שלו, זה, ותן ערך חדש, מה אני עושה? אני בהתחל לו את הנקסט בנודז הבאים בתור, ועכשיו תראו מה קורה פה, אני כותב פה node גדול בסוגריים, זאת אומרת, אני בהתחל node, כותב לא יודעת, 2, 10,

16
00:07:24,760 --> 00:07:54,760
10,30 מהספיק, נאוד ואז אני מתחיל את הנקסט של הנקסט, אז ככה אני ישר בונה פה עכשיו לנאוד הראשון, נקסט שלו, כבר אני משרשר לו שני נאוד, עכשיו צורת המימוש הזאת יכולה להיראות מאוד מבלבלת, למי שאולי לא יודע, שמע פעם על הרעיון של מצביעים בהקשר של שפות תכנות אחרות, אבל אני לא רוצה

17
00:07:54,760 --> 00:08:24,760
רוצה כרגע לבלבל אתכם, אז מי שזה מוכר לו, שימו את זה בצד, מי שזה לא מוכר לו, מעולה, אל תחשבו על זה. לפחות לבינתיים, תראו מה הרעיון, ברגע שאני עשיתי כזה דבר, הגדרתי כזה Node, ואז הלכתי לנוד נקסט שלו, ובניתי לו נוד, שגם לנקסט שלו, יש עוד נוד, ואז אני מדפיס את הרשימה המקושרת הזאת, שבעצם, כאילו, שווה ערך להגיד, תעשה פרינט, לנוד הראשון. אז מה שהוא עושה, הוא באמת מדפיס לי אותם, לפי איך שהגדרתי

18
00:08:24,760 --> 00:08:53,660
הוא כותב פה, אוקיי, הוא מראה לי ממש את הפירוט של הצמתים האלה, זה Node, ID שווה 1, X שווה 10, Y שווה 20, ואז Next, הוא ממש מראה את ה-Next, וה-Next בעצמו הוא Node עם ID 2, X 10, Y 30, ושם הוא עוד פעם פותח Next Node, והוא מראה את הנode השלישי ואחרון שהגדרנו פה, ID שווה 3, X שווה 50, Y שווה 60, ולבסוף הנxt שלו זה באמת ה-default none. עכשיו אני אעצור לרגע.

19
00:08:54,540 --> 00:09:24,540
הנותי פה הרבה דברים, האם יש איזשהן שאלות לגבי מה שראיתם עד עכשיו? משהו פה אולי לא בהכרח ברור לגבי איך שהגדרנו פה את הנוט, איך התחלנו, איך חושפנו, כאילו, כמעט בטוח שמשהו פה לא מובן. האם יש כאן שאלות למישהו? מישהו? אוקיי, נניח שלא יודע, אני לא הכי ישתכנעת אם שהבנתם, אבל בסדר. וכאן כאילו אתם יכולים לראות איך זה כאילו..

20
00:09:24,540 --> 00:09:53,300
נראה, נניח אנחנו חוקרים את הנוד הראשון ועשינו לו node next שווה כל הדבר הזה, זה כאילו איך שזה ייראה בצורה של המחשה, כשתוספנו לנקס שלו, אמר הנקס שלך הולך להיות נוד, שגם הנקס שלו יש לו גם נוד, ככה זה כאילו נראה מוחשית. אוקיי, שאלה? שאלה? אוקיי שנייה.

21
00:09:53,300 --> 00:10:23,300
ההגדרה הזאת של דאטה קלאסט, אנחנו פשוט פה, זו דוגמא למימוש של רשימה מקושרת. באמת שבפייתון יש לך אין סוף, יש לך המון דרכים לממש רשימה מקושרת, באותה מידה יכולנו לממש את זה בעזרת מילון, אתה יודע, יכולנו להגדיר מילון, כאילו, באמת שיש, כן מותר לך הרי ראינו את זה. זה למה כשהיה לנו בתרגול הקודם על סטרוקטים למעשה, יכולנו לקחת את...הגדרה הזאת של דאטה קלאסט, אנחנו פשוט פה - 
זה דוגמה למימוש של רשימה מקושרת? באמת שבפייתון, יש לך א

22
00:10:23,300 --> 00:10:53,300
סטרוקטים האלה, כבר לקחנו את הסטרוקטים האלה, היינו עושים שינוי קטן והיינו יכולים להגיד זה רשימה מקושרת, יכולנו, כי פונקציונלית זה היה עובד ככה. כל הרעיון, כל מה שאני מבקש שאתה תכיר ברשימה המקושרת, זהו, שים בצד לרגע את המימוש הזה, כשאני אומר רשימה מקושרת, תראה בראש את הדבר הזה, בלוק של שדות, של נתונים, זאת אומרת כל שדה זה פשוט משתנק שלעצמו, יש לך כזה,

23
00:10:53,300 --> 00:11:23,300
זה צומת נקודה, שדה שלו יש לו ערך והשדה האחרון זה פשוט מצביע לצומת שהוא הבא בתור. ואז במקום רשימה ומערך להגיד שיש לך אופרטור סוגריים מרובעים אינדקס, פה אתה רוצה לעבור על פני הרשימה, הדרך שלך היא באמת להתחיל מהראש שלה, לגשת לנקסט, לגשת לנקסט, לגשת לנקסט, עד שהגעת למי שרצית. ואיך אתה מגיע לסוף הרשימה, כשאתה עשית את זה כל כך הרבה פעמים עם נקסט

24
00:11:23,300 --> 00:11:53,300
עד שהגעת לנק שהוא נאן וזה, הקונספט הזה, הוא זהה לאורך כל שפות התכנות שבעולם 99% מהאלגוריתמים שמתעסקים ברשימות מקושרות. אם אתה מבין את זה, בסדר, ואז מכאן והלאה זה סתם, הנה דוגמאות למימוש. אוקיי, שאלות נוספות? שוב, רק דוגמה למימוש, שאנחנו פשוט נעבוד איתה כדי להראות לכם פעולות עם רשימה מקושרת, בסדר? אז...

25
00:11:53,300 --> 00:12:23,300
דרך אגב, כשאמרתי מילון, הנה באמת דוגמה לעשות את זה בעזרת מילון, שתבינו כמה שזה, זה לא משנה איך אנחנו מממשים. האמת, אני רוצה שתראו את זה למעשה, תסתכלו על זה שנייה, תראו מה אני כותב כאן. אני מגדיר פה כזה דבר. node 2 = מילון,מה המפתח הוד של המילון, מפתח ID value 2, מפתח X 10, מפתח Y 30, מפתח Next None, אז.

26
00:12:23,300 --> 00:12:53,300
אגב, תראו למה זה נוח שהגדרתי את Node 2 קודם. עכשיו אני מגדיר Node 1 ואני אומר Node 1 מפתח ID value 1, מפתח AX10, מפתח Y20, מפתח Next, אני פשוט כותב Node 2. כי עכשיו אתה לא יודע למה כי עכשיו בנוד 1 יכולתי לכתוב בנקס שלו את Node 2. זה הכי, הנה הנקס של Node 1 זה מצביע ל� Node 2. הכי טבעי שיש, הכי מתבקש. עכשיו

27
00:12:53,300 --> 00:13:00,120
אז אם אני אומר לי 2 שווה node 1, ואז אני אגש ל-node 1, ה-next שלו באמת הולך את node 2.

28
00:13:00,120 --> 00:13:09,200
אז אם זה אומר משהו גרועי ליקר דולפין, ואז כן מעסוף, למה לך? ז ...זה סתם, זה כי אתה רואה אבל למה?אתה רואה למה התחלנו את זה מעסוף, כדי שאני יכול,זה לא חייב.

29
00:13:09,200 --> 00:13:39,200
אבל עשיתי זה בשביל נוחות, כדי שאני יכול לכתוב את זה בשתי שורות קודם אשר שלוש. כי אם הייתי עושה את node 1 קודם ואז node 2, הייתי אחר כך צריך לכתוב node 1, סוגריים מרובעות, מרכאות next, אתם יודעים איך אנחנו נגשים למילון, עם סוגריים מרובעות ואז מרכאות, כאילו, השם של המפתח, הייתי צריך לכתוב node 2, אז פה בסך הכל עשיתי את זה בסדר הפוך כדי שיהיה לי node 2 שכבר קיים, זה הכל. בסדר, זה רק דוגמא, אני בסך הכל מנסה להראות לכם

30
00:13:39,200 --> 00:14:00,600
יש הרבה דרכים לממש רשימות מקושרות, אבל בבקשה תתחילו ותסיימו את החלק הזה של התרגול בשקופית הזאת. זאת השקופית שאומרת הכל, מכאן והלאה, רק מימושי פייתון. זו השקופית. שאלה? [צעקים מהמצלמות שלכם לממש את ה... את כל מה שנושאלות]

31
00:14:00,600 --> 00:14:27,900
בתרגול הזה אנחנו נתעסק בעיקר בדרך של הדאטה קלאס הזה, אבל זה נטו רק בגלל שהסינטקס שלו הוא סינטקס של, אתה יודע, לכתוב צומת נקודה שדה. זה סינטקס שאתה תראה בשפות תכנות אחרות, זה למה אנחנו נעזרים פה בדאטה קלאס. אבל הנה הדרך השנייה שנמראה לדוגמה, שלא תלכו לאיבוד, אפשר גם בעזרת מילון בפייתון, אפשר. [צעקים מהמצלמות שלכם לממש את ה... את כל מה שנושאלות]

32
00:14:28,020 --> 00:14:58,020
מה קורה כשאתה אתמק ישמע קצת איזה אלף דפרים? שאלה מעולה, מה שאתה אומר עכשיו זה שאלה מעולה וזה אחד הדברים שאנחנו נדבר עליו, אין בעיות אני רק מראה לכם כאן דוגמא ואז כאילו בצורת המילון אנחנו גם יכולנו להוסיף עוד עוד עיוורים ואתם רואים פה ממש, האמת תסתכלו על זה אני בונה פה עכשיו כזה node שלוש אני רוצה לבנות node שלישי לרשימה המקושיית הזאת, אני מגדיר אותו גם בצורה מילונית ואז תראו איך אני מוסיף (ילונימית: אלא לא להסתכל עליו).

33
00:14:58,020 --> 00:15:28,020
אותו לרשימה הקושרת בצורך מילון, אני אומר ליסטיים סוגריים מרובעות נקסט סוגריים מרובעות נקסט זאת אומרת ראש הרשימה הנקסט שלך הנקסט שלו הולך להיות נאות שלוש וזה עושה את מה שאתם חושבים שזה יעשה. הרשימה תראה מכזה דבר לכזה דבר שבו הנאום השלישי קושר לסוף וזהו וזה פשוט יעבוד

34
00:15:28,020 --> 00:15:58,020
זה יעבוד. שמע, תלוי מה אתה צריך מזה, יש סיבה למה מבני נתונים של רשימה מקושרת הוא קיים, לפעמים זה יעיל. לא רק, לא רק בסופות החוק, באופן כללי, בתור, בתור מבני נתונים, רשימה מקושרת זה בסיס לכל כך הרבה תתי מבנים אחרים, ש... אני חושב שזה אפילו מוקדם מדי להגיד לך אם זה יעיל או לא יעיל, וצריך פשוט לראות עוד דברים שקשורים בזה, אבל... מה שאני אומר לך  זה…

35
00:15:58,020 --> 00:16:28,020
איפה זה יודעות את זה? אם יש לך...לא תשמע, עכשיו...לא, רגע רגע, שנייה...קודם כל, אתה יודע ש... רק שאתה יודע, רשימה מקושרת, אגב, זה סוג ממבנה נתונים, שמאוד קל לעבור עליהם ברקורסיה. אני רק אומר לכם את זה בתור דוגמא, אבל חכו שנייה, חכו להמשך התרגול. אנחנו נראה דוגמאות, אנחנו נראה דוגמאות, אל תדאגו, אפשר לעבור עליהם גם בצורה איטרטיבית, בפולולאות פור ווייל וגם בפורסיה.

36
00:16:28,020 --> 00:16:58,020
מותר, אבל אנחנו נגיע לזה. בינתיים אני רק מקווה שפחות ראיתם איך אנחנו יכולים לקחת רשימה מקושרת בשני סוגים של מימושים להתחל אחד ולהוסיף לאיברים. לא מאוד מסובך, פשוט תלוי מימוש. אוקי? עכשיו, כמובן, אנחנו יכולים גם לשנות רשימה מקושרת מבחינתכם. אתם ראיתם שמימשנו אותה בעזרת שני, שתי דרכים - דאטה קלאס וגם מילון. אז עכשיו אני רוצה להגיד לכם - מבחינתנו רשימה מקושרת היא

37
00:16:58,020 --> 00:17:28,020
מאוד מיוטאבול, זאת אומרת, לכו לרשימה מקושרת, כל שדה שלה בר שינוי, זה יכול להיות שדה value כלשהו, וזה בהחלט יכול להיות שדה next כלשהו, מבחינתכם מאוד מיוטאבול, אין שום דבר שהוא יותר מדי קבוע, אז לדוגמה, אם באמת אני מראה לכם רשימה מקושרת,מהתבנית הזאת, כמו שאתם ראית מקודם, ID 1,ID 2,ID 3, אגב,א, זה סתם שדות אינטג'רים, אנחנו כתבנו

38
00:17:28,020 --> 00:17:58,020
אותה איי-די, זה לא, אין שדה איי-די שהוא built-in לרשימה מקושרת, ובבקשה, אל תתבלבלו. כתבנו את המספרים האלה רק לשם נוחות. לוקח: זה דוגמאה של דף אחרון?  שעור: לדוגמא מהמימוש דאטה קלאס, ואני יכול עכשיו להגיד לך, מעבר בספור תכנות אחרות שתראה כמו C, או לא יודע, אפילו Java, או C#, הרבה ספור תכנות אחרות, יהיו לך מבנים כאלה מתקדמים של קלאסים, אובייקטים מתקדמים, סטרקטים, מה זה לא יהיה. הגישה לשדה,

39
00:17:58,020 --> 00:18:27,720
תמיד יהיה בעזרת נקודה, ודרך אגב, לאובייקטים או קלאסיים מתקדמים מספיק, זה לא רק יהיה בשביל לגשת לשדה, אלא גם לגשת לפונקציה שקשורה לאותו סוג משתנה. סתם דוגמה, כשאתם כותבים רשימה כלשהיא, נקודה append, אתם ניגשים לפונקציה ששייכת לסוג המשתנה, list בפייתון, אבל זה מילא, זה רק אם אתם ממש רוצים להבין את המהות של הסינטקס, זה מילא.

40
00:18:27,720 --> 00:18:57,720
בקיצור, תראו מה שכתוב כאן, אתם רואים? הנה רשימה מקושרת כלשהי ואני אומר: ניגש לנוד, הכוונה היא מבחינתי לתחילת הרשימה, נוד נקודה x שווה 60, זה אני הולך לשנות להיות ל-60, נוד נקסט x שווה 60, אז אם הולך לנוד נקסט x, גם את זה אני מחליף ל-60, וזה באמת משהו שיקרה. זאת אומרת, עשיתי את זה, החלפתי את הצדות האלה באינטגר אחר שלא היה אפשרול 60.

41
00:18:57,720 --> 00:19:27,720
זה פשוט עובד. אה, כן. שוב, אנחנו עובדים כרגע לפי המימוש שראיתם לפני כמה שקופיות, תרגישו חופשי אם בא לכם לפתוח את קובץ התרגול במודל במקביל, אם אני במקרה עובר לשקופית שאתם לא רואים. תרגישו חופשי, אני עובד מאותו קובץ. בסדר. יש אפילו קטע אקסטרה, אני לא יודע אם זה הכי נוח שבעולם כן או לא, בדבר

42
00:19:27,720 --> 00:19:57,720
בדאטה קלאס הזה, שזה לא בהכרך נכון לרוב האלגוריתמים שאתם תראו בעולם, אבל בדאטה קלאס הספציפי הזה שאנחנו מימשנו, אנחנו יכולים להגיד node נקודה שדה שלא קיים לך שווה ערך כלשהו. זה מאוד מוזר, זה קצת חריגה, אבל ספציפית בדאטה קלאס הזה בפייתון, זה כאילו יישאר לו, יישמר לו, אבל כשאתה עשו פרינט, כשתרצו לידעת

43
00:19:57,720 --> 00:20:27,720
הדפיס את התוכן של ה Node הזה, השדה החדש שכרע יצרתם לא יהיה חלק מהדפסה. מה שכן, אם אתם מכירים שיש לו כזה שדה, ואתם תנסו להדפיס אותו ישירות, לדוגמה פה אני עושה print node נקודט t שבדיוק נתתי לו ערך חמש, אז זה יעבוד. מצד שני, זה שהלכתם לצומת ספציפי ונתתם לו שדה שלא הוגדר לו, זה לא משנה איך אתם יגידים שהוא משסיר

44
00:20:27,720 --> 00:20:57,720
שזה יהיה קיים בנקסט שלו, לדוגמת. היום רכיני לבוקס ולהתקמם, ולפוסק עליהם. קצת, האמת, כן. מה שאתם רואים כאן בריבוע הזה, במלבן הזה, זה כאילו קצת למתוח את הגבולות, קצת לתת חריגה ולהראות לכם מה פייתון מסכים לקבל ומה לא. ושוב, זה רק מהמימוש הספציפי הזה של דאטה קלאס. אז, בבקשה,  אל תיקחו את מה שאתם רואים כאן, לידע שלכם להמשך הדרך, זה לא משהו שיעבור.

45
00:20:57,720 --> 00:21:27,720
שיהיו לכם שאלות באלגוריתמים שקשורות בעצים או בגרפים, מש זה לא יהיה. אל תניחו שיהיה לכם מותר לעשות כזה דבר, זה סתם אקסטרה. שתדעו, משהו שפייתון ייתן לכם. ועכשיו בואו נחזור חזרה לעולם הרגיל, כמו שראינו שינוי שסדות בדאטה קלאס, אפשר לעשות שינוי של סדות גם אם מימשנו את הצמתים בצורה של מילון. זה לא אמור להיראות לכם מוזר או חדש. מה שאתם רואים זה שאתם רואים שאתם חשיבים להפרסם את עצמכם, שתביגעו בצמת יד של

46
00:21:27,720 --> 00:21:57,720
רואים פה, גישה למילון, תמיד באופרטור סוגריים מרובעות, ושם המפתח. אוקיי, עד כאן סבבה, עכשיו חיפוש. חיפוש ברשימה מקושרת ב "O של N", זה אולי הדבר הכי פשוט שאפשר לדמיין. למה ?פשוט מאוד. נניח שאנחנו רוצים לחפש ברשימה מקושרת, האם יש לה, לא יודע, צומת עם שדה כלשההו, בעל ערך מסוים...

47
00:21:57,720 --> 00:22:27,720
אחד מהדברים הכי פשוטים, למה, אני יכול לעשות כזה דבר, נכנס לפונקציה, קיבלתי רשימה מקושרת וקיבלתי מי שאני רוצה למצוא שם, אז מה אני עושה? אני עושה while רשימה מקושרת, זאת אומרת, while המצביע רשימה הנוכחי שלי כרגע הוא לא none, זאת אומרת, while אתה קיים, זה מה שזה אומר, אני אומר if, לא יודע, אני רוצה לחפש שדה id, אין בעיות, if המצביעליסט .id שווה

48
00:22:27,720 --> 00:22:57,720
הפרמטר הid שקיבלתי, מצאתי אותך, ואם לא, אז פשוט list שווה ל list נקודה next, זאת אומרת התבנית הזאת של while מצביע רשימה ואז מצביע רשימה שווה מצביע רשימה נקודה next זה הבסיס של הבסיס של הבסיס לכל תבניות מעבר על פני רשימה מקושרת בפונקציה, פשוט מצביע לרשימה המקושרת,

49
00:22:57,720 --> 00:23:23,820
לא מעניין לכם דרך אגב איפה הוא התחיל, אלא אם כן מעניין לכם ואז אתם פשוט תכתבו מקרי קיצון, ואתם רוצים לעבור, אין בעיות. תגידו אחרי שעשיתם עבודה על הצומת הנוכחי, תגידו מצביע, עכשיו אתה שווה להיות הנקסט של עצמך. זה קונספט שהוא זהה בכל ספורט התכנות. אין פה שום דבר שאמור להיות מוזר. כן שאלה.

50
00:23:23,820 --> 00:23:52,420
אה, אתה מדבר איתי עכשיו על רשימה מקושרת שהיא גם מעגל. בסדר. רשימה מקושרת שהיא גם מעגל, זה לא מבנה סטנדרטי, ואני לא יודע, אבל תאמין או לא, יש לנו אפילו שאלה יותר מאוחר בתרגול, שבה אנחנו בודקים האם רשימה מקושרת היא מעגל. יש לנו אפילו תרגיל כזה. שמור את השאלה הזאת, שמור את השאלה הזאת.

51
00:23:52,420 --> 00:24:22,420
לא. איך אתה מביא את זה הפרינט? ואילו זה לא. אה... תשמע, בתכלס, יכולת לכתוב פה מילה ריטרן כלשהי, האמת. דמינו שאפשר היה לכתוב פה ריטרן אחרי הפרינט, כן? כי אחרת מה, היינו ממילא ממשיכים לעבור עד סוף הליסט. תשמע, זה רק יותר כמו... אתה יודע, זה המלצת מימוש. מקסימום לא היינו עוד יוצאים פה מהעלולה, היינו מסיימים את הטראברסל ממילא. או שאתה חייב להגינאי,

52
00:24:22,420 --> 00:24:52,420
אתה יודע משהו? האמת, לא, אתה יודע למה? הפונקציה סרט שזאת, היא לא תעצור לך אחרי שהיא מצאה את הצומת הראשון עם איי-D שווה, אלא היא תכתוב לך פאונד לכל צומת שיש לו שוויון באיי-D. מי אמר לך? אני לא אמרתי פעם אחת, אמרתי שהפונקציה הזאת, תדפיס פאונד אם היא מצאה איי-D שווה.אם אתה צריך פאונד עליו? ? איתם. אם.. אתה צריך פאונד עליו? באופן פני עולם, בכלל להיות יותר ויותר טעים של המדע זאת

53
00:24:52,420 --> 00:24:57,620
פעם אחת ברור שאתה עוצר מיד אחרי שהתנאי שרצית יתקיים, בסדר?

54
00:24:57,620 --> 00:25:39,820
זה כבר להיתקע על קטנות, כן? זה יתקע על מה דרישת המשימה. אבל לפחות, מה שרציתי להדגיש לכם זה הרעיון הזה של וואי, על מצביע, ואז מצביע שהווה מצביע נקסט, זה כל מה שעניין אותי פה, בסדר? אוקיי, עכשיו, מה אם אתם רוצים לתחזק רשימה מקושרת, שהיא ארוכה, לא מאוד מאוד קצרה, לא יודע... מה אם אנחנו רוצים? מ- 3? מ- 4 זה לא מצביע בעצם, זה חוש סובבית בטוח, לך שהתבטחצת על רק רק רק תחז

55
00:24:57,620 --> 00:25:27,520
זה כבר להיתקע על קטנות, כן? זה להיתקע על מה דרישה את המשימה. מה שרציתי להדגיש לכם זה הרעיון הזה של וואי, מצביע ואז מצביע שווה מצביע נקסט. זה כל מה שעניין אותי פה, בסדר? אוקיי, עכשיו, מה אם אתם רוצים לתחזק רשימה מקושרת שהיא ארוכה, לא מאוד מאוד קצרה, לא יודע, מה אם אנחנו רוצים להוסיף לרשימה מקושרת מאוד מאוד מאוד ארוכה, עוד איזשהו צומת בסוף?

56
00:25:27,520 --> 00:25:57,420
אז לא, פשוט נכתוב, זה נחמד, זה רעיון, אבל אני רק אומר, הראיתי לכם את הסארץ' כדי להראות לכם את הרעיון הבסיסי מאוד לפונקציית אינסרט, שלמעשה הרעיון שלו מאוד פשוט, נעשה פה וואיל, מה? לתלוי, נניח ברשימה בפייתון, כשאתה עושה רשימה נקודה אפנד, זה עובד דומה.

57
00:25:57,420 --> 00:26:27,420
על מה אנחנו עושים? אנחנו אומרים פה while מצביע רשימה נקודה נקסט קיים, ליסט שווה ליסט נקודה נקסט ואז ה-while הזה נגמר ברגע שהגענו למצב שבו ליסט נקודה נקסט הוא cinco אחוז כלומר ברגע שהגענו לעבר האחרון ברשימה ושאין לו עבר הבא שהנקסט שלו שווה בן אפס ואז מה אנחנו עושים? ליסט נקסט אחרי שסייבנו להעביר את ליסט עד הסוף ליסט נקסט עכשיו שווה לצום את החדש שקיבלנו כפרמטר וככה אנחנו

58
00:26:27,420 --> 00:26:57,420
אנחנו פשוט מקשרים לסוף הרשימה את האיבר שבדיוק קיבלנו. שאלה? אה.. הפונקציית הזאת מקבלת מהליסט הזה, נכון? -פונקציית אינסרט כמו שאתם רואים בפרמטרים שלהן, מקבלת. -מקבלת. -רשימה מקושרת, וצומת שאנחנו רוצים לקשר לסוף הרשימה המקושרת. -כן. אז בסוף, אנחנו... -קוראים את המיונות מהזה לליסט. -כן. -והליסט הגלובל משתנה, או...

59
00:26:57,420 --> 00:27:07,200
זו שאלה טובה, זו שאלה טובה, אני חושב שפה ספציפית, אוקיי בוא נגיד את זה ככה, פה ספציפית אנחנו גם לא עושים ריטרם, אתה יודע משהו?

60
00:27:07,200 --> 00:27:37,200
אני חושב שהליסט הגלובלי לא משתנה, אני חושב שפה הליסט הגלובלי לא ישתנה, אבל זו עדיין שאלה טובה כי יש תרחישים שבהן, יש תרחישים שבהן משהו כן ישתנה, מה זאת אומרת עכשיו? יש לו פואנטה, האמת האינצרט שאתם רואים כאן , המאוד פשוט הזה של תעבור לי על המצביע ליסט עד שהנקסט הורה ואז בנקסט שם תשים את ה new node, אז באמת יהיה לזה מקרה מיוחד אבל זה בשקופית הבאה, קודם כל נניח שיש לנו רשת איכות, בסדר. אתה יכול לפי 10% ללכת באינסטטינטק,  עשהייך

61
00:27:37,200 --> 00:28:07,200
רשימה שיש לה כבר אוורים שהכל סבבה והכל נפלא שם אז מה יקרה? נפיל את הפונקציית אינסרט הזאת על רשימה שנראית ככה בסדר? מניח אני רוצה להפיל אינסרט עם נורד לא יודע ID4, X שווה 2, Y שווה 1 איך זה יעבוד? אז באמת איך זה יעבוד? זה יעבוד דווקא בצורה נכונה. אז נניח פה.אנ..

62
00:28:07,200 --> 00:28:37,200
אני מריץ את הפונקציית אינסרט, אני עושה while list.next קיים, אז קודם כל, lst, אני פשוט שולח לו את ראש הרשימה, אז מבחינתנו בהתחלה של הריצה, lst הופך, יסתכל על האיבר הראשון, next פשוט יסתכל על האיבר השני, ואנחנו נמשיך לעשות את המעבר הזה, עכשיו next מסתכל על איבר השלישי, ופתאום, עכשיו זה הופך להיות list, וה-next שלו רק, אז פה אני עושה פעולת הקישור, אני עושה links.

63
00:28:37,200 --> 00:29:07,200
אחרי שקידמנו את הקופי המקומי הזה של ליסט, קידמנו את הקופי המקומי של המצביע הזה. נגיד לו ניקס שלך עכשיו שווה להיות ניו נוד, אבל זה בסדר. זה אמנם קופי מקומי אבל בסופו של דבר העדכון שעשינו כאן זה משהו שהוא מיוטבילי, זאת אומרת אנחנו כן עדכנו את הנקסט המתאים ברשימה, זה שבאמת נמצא ברשימה המושטרת הזאת, להצביע להיות הניו נוד הזה שקיבלנו כפי מצביע. שאז אתה צוג אפשר להסכם את זה, להצביע את נפט הזה שצריך להוציא להוציא מהמישהו בנקודת המכירה

64
00:29:07,200 --> 00:29:37,200
פרמטר, אז זה כן יעבוד. שוב, תחשבו על זה קצת כמו איך שרשימות עובדות, רשימות הן מיוטביליות בגלל שרשימות הן סוג של אוסף של מצביעים, זה האיברים בפנים, שאם הם אינטג'רים או פלואות או בוליאנים, זה לא מיוטביל, אבל ליסטים זה משהו כן מיוטביל, כי אתם כן רוצים להיות מסוגלים לשנות את האיברים שבתוך רשימה. בקיצור, פעולת האינסט שאתם רואים כאן, תעבוד כפי שאתם מצפים שהיא תעבוד. האם יש שאלות קודם כל, רק על מה שדיב 1984שאנחנו מדברים (

65
00:29:37,200 --> 00:30:07,200
ראיתם פה, כן, כן, זה למה, זה למה יש את כל המחשה הוויזואילית הזאת כדי להראות לכם שזה באמת השתנה ושזה עובד כמו שציפיתם, ממש ככה, הקישור הזה באמת נוצר, עכשיו, יש כאן שאלות מתבקשות אחרות דווקא, קודם כל, מה אם אתם רוצים להוסיף לרשימה ריקה?

66
00:30:07,200 --> 00:30:37,200
מי זה ליסט-הייב? מי ראש הרשימה? זאת אומרת צריך ליצור רשימה. עכשיו מה אנחנו נעשה אינסרט, נשלח לה NONE, אז מי יהיה מצביע ראש הרשימה בסוף, נכון? מי? אז זה למה אנחנו צריכים מימוש שהוא קצת יותר רובסטי. אז מימוש למעשה שהוא יעבוד עכשיו, יעבוד על שני דברים, הוא יחשוב על שני דברים. קודם כל, עכשיו אנחנו נגדיר,

67
00:30:37,200 --> 00:31:07,200
פונקציית אינסרט, שאם פרמטר ליסט ששלחנו הוא נאן, זאת אומרת נניח שאנחנו שולחים ואתם יודעים משהו, אני אפילו אגיד לכם משהו אקסטרה. הייתי ממליץ לכם פה בפונקציית האינסרט לכתוב פה lst שווה נאן בתור דפולט פרמטר כזה. אם שום דבר תניחו שאתם בונים רשימה חדשה מהדבר הזה, זה סתם, זה אקסטרה, מהנה. אז נגדיר עכשיו פונקציית האינסרט שלנו זה מקבלת מצביע רשימה מקושרת וצומת חדש ונגיד, אם ליסט

68
00:31:07,200 --> 00:31:37,200
שקיבלנו הוא כלום, אז מה נעשה? נחזיר את הצונות החדש שקיבלנו, הוא הולך להיות עכשיו הרשימה. נשמע הגיוני? אוקיי. אם לא, תראו מה אנחנו נעשה. אנחנו נרצה לבנות את הפונקציית אינסרט הזאת, שהיא תקשיבו טוב, היא תחזיר את ראש הרשימה, אחרי שהוספנו את ה-New Node בסוף. אני אומר את זה שוב, הפונקציה הזאת תחזיר את ראש הרשימה, אחרי

69
00:31:37,200 --> 00:32:07,200
העברנו את זה עד הסוף, מה זה אומר? אנחנו צריכים משתני עזר, אני כותב פה משתני עזר קו, שזה קיצור ל-current, שווה ה-list שקיבלנו, ואז את current, אני עושה לו כל הזמן next, next, next, next, שימו לב, זה רק קופי של מצביע, כשאני אומר לכם קופי של מצביע, מבחינתכם, שינויים שאני אעשה בעזרת ה-current הזה, הם יישמרו לזיכרון,

70
00:32:07,200 --> 00:32:35,780
אני רק עושה פה קופי של מצביע. אז, אני עושה current שווה list ואז, while currentNext קיים, current שווה לכurrentNext. או ו', אז זה ממשיך, ממשיך, ממשיך, ממשיך, עד שסיימתי. והגעתי לסוף הרשימה המקושרת בעזרת current ואז, next הוא רק, אני אומר, current.next שווה ה-new node שקיבלתי כברמטר, ועכשיו, מה אני מחזיר? את ליסט המקורי. את המצביע ליסט מקורי. למה עשיתי את זה? humanitarian quicktext set up to handle JavaScript calledently

71
00:32:35,780 --> 00:33:05,780
כדי שאני אוכל להחזיר את אותה ראש רשימה ששלחו לי פשוט אחרי העבודה שעשיתי לקשר את ה-New Node לסוף. האם יש כאן שאלות? שאלה.אם לא הייתי עושה את זה, אז אני שואל אותך עכשיו שאלה פשוטה מאוד-מה הייתי מחזיר פה ב-return. זה כל מה שאני שואל אותך, מה הייתי מחזיר בreturn? הרי אני חייב...

72
00:33:05,780 --> 00:33:35,780
חייב לעשות ריטרן, שים לב למה, בגלל הבדיקה הזאת. קודם כל, אני בודק אם אני עושה פה אינסרט לרשימה שהיא לא קיימת. זאת אומרת, לא משנה מה, ברגע שעשיתי פה if משהו ריטרן, הפונקציה הזאת הפכה להיות פונקציה שמחזירה משהו. לכן, אני חייב להחזיר מישהו. אז אני שואל אותך, בלי קרנט, מה הייתי עושה? יאללה, בלי קרנט, מה הייתי עושה? כן, בלי קרנט, מה הייתי עושה? בלי מצביע עזר, מה הייתי עושה? מי הייתי מחזיר?

73
00:33:35,780 --> 00:34:05,780
בסוף, אחרי שהייתי מקשרת... צריך, עוד פעם, למה? כי אני מטפל פה במקרה שבו ראש הרשימה הוא רק, שאני עושה אינסרט לרשימה שהיא לא קיימת, ואז אני כותב פה איף בעיה ריטרן צומת חדש. זהו, הפכתי את הפונקציה לפונקציה שמחסירה בריטרן משהו. וזהו, בשקופית הקודמת, בזה, לא היה לי פה שום ריטרן, אבל זאת פונקציה שהיא לא רובסטית והיא לא יכולה להתמודד...

74
00:34:05,780 --> 00:34:35,780
עם רשימה ריקה? כן. אבל הוא... בוא נעזוב את זה ונרשם את ה... מסתגובה האלה. בסדר, זהו, אתם מבינים? אז מה עכשיו? אז לא צריך את הקריאה האומיתית. לא, אבל פה כן צריך, להפך. פה יש ירובסיות. אתם, רגע, מי שבכיתה, אתם עוקבים אחרי מה שאני מנסה להסביר? שימו לב. אני נעזר פה במצביע עזר כדי שאני אוכל בריטרן

75
00:34:35,780 --> 00:34:44,080
‫להחזיר מצביע לראש הרשימה. ‫זאת אומרת, פה אני מתקן שתי בעיות פוטנציאליות.

76
00:34:44,080 --> 00:34:45,560
‫אז זה זמן למעלה. ‫-כן.

77
00:34:45,560 --> 00:34:50,860
‫אתה לא משנה את הרשימה, ‫אתה מעביר את ההתחלה שלך, ‫ומעביר את המצביע.

78
00:34:50,860 --> 00:35:01,400
‫אז אתה מבין, האיסטרט הזה ‫עדיין יכול לעבוד, האיסטרט הזה עדיין יכול לעבוד, אבל הוא לא יעבוד הרשימה ריקה. זה מה שאני מנסה להגיד.

79
00:35:01,400 --> 00:35:05,700
‫התכתוב משנה את האף. ‫-לא. רגע.

80
00:35:05,700 --> 00:35:35,700
זה קופי מקומי של המצביע, זה קופי מקומי של המצביע, בסדר? אבל עוד פעם, אני מנסה להסביר את זה, בגרסה המתוקמת של הפונקציה, ברגע שכתבתי ריטרן בif כלשהו, גמרנו, זאת פונקציה שחייבת להחזיר משהו, היא חייבת להחזיר משהו בריטרן, ולכן, אין לי ברירה, אלא להתחשב בזה, ולוודא שאני עושה ריטרן במקרה הרגיל, של ראש

81
00:35:35,700 --> 00:35:42,700
‫הרשימה, ולא סוף הרשימה, ‫אחרת זה באמת לא יעבוד. כן?

82
00:35:42,860 --> 00:36:12,860
אני הבנתי את זה אבל למה עכשיו, זה לא משתמש במכורים זה שייך לראות? למה לא משתמש במה? את לא מבאת לי, למה זה לא מתאים? אני לא שומע. אתם מדברים שם בכיתה ואני לא שומע שאלות, בבקשה. התרגול עדיין ממשיך, תשאל. למה הקוד הראשון הזה לא משתמש במכורים? הקוד הראשון הזה הוא כאילו יעבוד על רשימה שהיא קיימת, כי פה אין שום ריטרן, אני רק עושה שינוי על, אתה יודע, על רשימה המקושרת, אני עושה שינוי. ממה הזה עבר את זה? נראה לי שאהיה מחואר למטען. אני לא בחדר, אבל

83
00:36:12,860 --> 00:36:42,860
לשכנע לחזור,חזיר רק ללא דברים, לא, שנייה, אני עושה פה, הליסט הזה הוא הולך להיות קופי מקומי, הוא קופי רעיומי,טבע:
-כן
-אם אתה תעשה, לצוות מקום תאפשר לעשה קפוא ללי ס של מיני,
-אבל יש לך בעיה אחרת, לא יש לך בעיה אחרת, כשאתה קראת לפונקציה הזאת מה אם אתה קראת לפונקציה הזאת, אתה יודע בלי לעשות משהו שווה אינסרט

84
00:36:42,860 --> 00:37:12,860
בקיצור, אם עדיין יש לכם ספקות לגבי הנושא הזה, אם יש לכם ספקות לגבי הנושא הזה, אני ממליץ לכם, קחו את הקוד שנמצא במודהל, תעשו עליו שינויים ותראו אם עובד או לא עובד. כרגע לשם התרגול, אני לא יכול להיתקע על זה יותר, בסדר? אז אם יש לכם עדיין ספקות, בבקשה, תבדקו את זה בעצמכם. רק תבינו, כרגע אנחנו עובדים בצורה רובסטית, שבה אנחנו כן במפורש, מחזירים את המצביע,

85
00:37:12,860 --> 00:37:42,860
כפי שאנחנו רוצים להחזיר אותו, ראש הרשימה. אוקיי, עכשיו. אם ראיתם מקודם את הרעיון של חיפוש ואת הרעיון של הוספה, אנחנו יכולים גם למחוק צומת mרשימה מקושרת. אז מה אנחנו היינו עושים? היינו עושים כזה דבר, נניח קיבלנו פונקציה, remove from list, והפונקציה קיבלה שני פרמטרים, ראש של רשימה מקושרת ושדה ID, כשאנחנו נרצה למחוק.

86
00:37:42,860 --> 00:38:12,860
כל צומת שיש לו ID כזה, אז הנה מה שאנחנו יכולים לנסות, אנחנו יכולים לנסות לממש את זה, להגיד, אוקיי, כדי למחוק צומת מרשימה מקושרת, דבר ראשון שאנחנו רוצים לעשות, לזכור, זה ש.. אנחנו בעצם רוצים לקשר את האיבר הקודם עם האיבר הבא של מי שאנחנו רוצים להעיף, זאת אומרת, תדמיינו A, B, C, אני רוצה להעיף את B, אז אני אצטרך לזכור את..

87
00:38:12,860 --> 00:38:42,860
k כדי להגיד a נקסט שווה c. זה מובן לכם? הרעיון של למחוק איבר מרשיון קושרת - צריך לזכור מי זה פרוויוס, כדי להגיד פרוויוס נקודה נקסט שווה קרנט שוהולך להעיף אותו נקודה נקסט. ואז זה בעצם - מה ש, ואז אני אגיד קרנט נקודה נקסט שווה None. ואז ככה בעצם לחלוטין, אני מעיף את האיבר הזה מהרשימה - פשוט מנתק אותו, אוקיי? אז אני שומר לעצמי, אני אומר כזה דבר - פרוויוס שווה ליסט. זאת אומרת, אני מתחיל

88
00:38:42,860 --> 00:39:12,860
את הרשימה בהתחלה אני אומר אוקיי אז previs זה גם ההתחלה ואז while list כל עוד שעדיין לא סיימתי לעבור לרשימה אני אומר if list נקודה איידי שווה האיידי למחיקה אין בעיות אז נגיד 
מה? נגיד שטמפ כלשהו שווה ה- list next זה שאני ארצה לחבר אליו ואז אתם צריכים אתם צריכים לעקוב אחרי מה שכתוב פה if previs

89
00:39:12,860 --> 00:39:35,360
Previous is list, אתם מבינים מה התנאי הזה בעצם שואל? אם יש לנו אותו אתגר במחקרון... כאילו, מה זאת אומרת? מה זה אומר אם Previous הוא גם ליסט הנוכחי, מה זה אומר בעצם? את מי אני מוחק?ature היחיד שלו. או היחיד, או פשוט הראשון, נכון?

90
00:39:35,360 --> 00:39:52,260
תסתכלו, Previous, אני התחלתי אותו בלהיות ליסט, מה אם האיבר שאני רוצה למחוק הוא האיבר הראשון? מה אני עושה? אז בואו, גם מי שבכיתה, אני רוצה שתנסו גם אתם לקרוא. תנסו!

91
00:39:52,260 --> 00:40:19,800
אוקיי, עוד פעם, Previous שווה Last, אני מתחיל את המעבר שלי על הרשימה, א Luck extremelyה Wish גם אתה מצביע רשימה נוכחית וגם Previous, אבל שניהם חייבים להתחיל בתחילת הרשימה, ואני אומר אם נפלתי על איבר ברשימה שאותו אני רוצה למחוק ונניח שזה בתחילת הרשימה, למה? תסתכלו, If Previous הוא גם מצביע לLast הרגיל, מה אני עושה?

92
00:40:19,800 --> 00:40:49,700
בדיוק, מה זאת אומרת? אני אומר מצביע רשימה, אתה הולך בעצם להיות ה-Tem, מי זה Tem? פשוט הבא בתור, כן, זאת אומרת אני אומר ראש הרשימה החדש הולך להיות האיבר השני, אם לא, זאת אומרת אם Previous הוא לא List, זאת אומרת אני לפחות נמצא באיבר השני והלאה, זה ה-Else הזה, אני אומר, אין בעיות, Previous נקודה Next שווה ה-Tem ששמרתם מקודם, שזה ה-List Next, זאת אומרת פה אני עושה את הקישור, את ה-A Next שווה ל-C.

93
00:40:51,060 --> 00:41:43,926
ואז, זהו. ועכשיו אם האיף הזה לא מתקיים, עכשיו לא משנה אם האיף הזה מתקיים או לא מתקיים, אני אומר אוקיי, טיפלתי בחלק הזה של הרשימה, ועכשיו אני אגיד previous שווה האיבר הנוכחי, והאיבר הנוכחי אתה שווה להיות הבא בתור. זאת אומרת פה, אני ממשיך את המעבר על פני שאר הרשימה, לחפש עוד מי אני ארצה למחוק בגלל שהid שלו שווה. עכשיו, לפני שאני ממשיך, האם מישהו כאן, שם לב לבדוק מקצועיו של איפה הוא קיים לו שעומד להבנות על האיף כדי להחפש את האיבר הזה, תזכור שלחשוב שגיל

94
00:40:51,060 --> 00:41:21,060
ואז לא, ועכשיו אם האיף הזה מתקיים או לא מתקיים, אני אומר אוקיי, טיפלתי בחלק הזה של הרשימה, ועכשיו אני אגיד, פריוויז שווה האיבר הנוכחי, האיבר הנוכחי אתה שווה להיות הבא בתור, זאת אומרת פה אני ממשיך את המעבר על פני שאר הרשימה, לחפש עוד מי אני ארצה למחוק בגלל שהאיי.די שלה שווה. עכשיו, לפני שאני ממשיך, האם מישהו כאן שם לב לבעיה

95
00:41:21,060 --> 00:41:51,060
איפה המימוש הזה נכשל, רמז תחשבו על מקרה קיצון .רשימה ריקה רשימה ריקה רשימה ריקה. או רשימה שיש לה רק עבר אחד מי זה נקסט, זה לא יעבוד לי זה לא יסתדר לי, זאת אומרת המימוש הזה לא יעזור וגם תחשבו על זה

96
00:41:51,060 --> 00:42:21,060
אם באמת הרשימה יש לה או אפס איברים או איבר אחד ואני אנסה להגיד פה ליסט שווה לנאן הזה, מה יישאר לי מיניסט אחרי זה? כאילו אי אפשר לעבוד עם זה. אז גם פה בשביל רובסטיות, הניסוי הדבר הראשון שאני מנסה לעשות, זה לעשות ריטרם קורא שהוא זאת אומרת פה, אני בצורה חד משמעית אומר הנה המצביע שאני מחזיר והוא

97
00:42:21,060 --> 00:42:51,060
איך להיות ראש הרשימה מחדש אחרי השינוי שעשיתי. יש פה אלמנט של חושפת רובסטיות שצריך לחשוב עליו, אז קדימה, עכשיו אני עושה את זה. אני עושה previous שווה list ואז why list, בלה בלה בלה, if list.id שווה שווה id, אוקיי. אז אני אומר if previous is list, אז אני אומר list שווה list next, else previous נקודה  שווה list next, זה כבר יותר מתקרב לרעיון, ואז עוברים הלאה. ולא משנה,

98
00:42:51,060 --> 00:43:21,060
למה בסוף אני מחזיר את ליסט? רגע, שכחתי פה משהו, נכון? שימו לב, את מי אני מחזיר פה? איפה ליסט כרגע נמצא? לא, תסתכלו, הריטיונל הזה אני שם אותו אחרי סוף הוואט הזה, אבל הוואט הזה העביר את המצביע, את הקופי ליסט מקומי עד סוף, כן, זה לא טוב, אז צריך פה להיעזר במשתנאי עזר כמו כרן.

99
00:43:21,060 --> 00:43:51,060
כדי שבסוף אני עדיין אחזיר לי שהוא ראש הרשימה, לא סוף הרשימה. אז זה הגרסה, שאנחנו היינו רוצים יותר לעבוד איתה, גרסה שגם דואגת לפתור את התקרית של מה אם יש לנו ראש רשימה רק או איבר אחד, וגם גרסה שבסופו של דבר לא משלמה, תחזיר לנו את ראש הרשימה ולא אחרי שעברנו על כל הרשימה עד הסוף. עכשיו, זה דברים חשובים, זה באמת דברים חשובים, הדקויות האלה זה כאילו...

100
00:43:51,060 --> 00:44:21,060
להכיר איךן עובדות, כי אחרת... לא יודע. אתם הייתם כותבים פונקציית מימוש לרשימה�ק מקושרות שלא ממש היית.. היו עובדות לכן, ולא בהכרח הייתם יודעים למה. אוקיי, לפני שאני ממשיך, האם יש שאלות? לא שומע? אה, קודם כל הניסיון הראשון, היה ניסיון שלא היה לו ערך חזרה ולא ידע להתמודד עם רשימה ריקה או רשימה של אוור אחד.

101
00:44:21,060 --> 00:44:51,060
כי אז מה היית מחזיר, אם היית מוחק את האיבר הראשון. ‫הניסיון השני, תיקן את הבעיה של רשימה ריקה ‫או רשימה של איי אלא רק איבר אחד, ‫אבל הניסיון השני שכח, ‫שאם אתה עושה וייל לבליסט ‫ומקדם את ליסט עד הסוף, ‫אתה לא יכול להחזיר ‫ליסט שהוא נאן, שקידמת עד הסוף. ‫אתה צריך לעשות קופי, ‫כזה מצביע עזר, נקרא לו קורנט. ‫לא, להפך, הקרנט הוא זה ‫שאתה יכול לקדם אותו עד הסוף.

102
00:44:51,060 --> 00:45:21,060
אבל בסוף אתה מחזיר את אותו ליסט שקיבלת מלכתחילה או ליסט אם העבר הראשון נמחק, העיף הראשון הזה, אז כאילו אתה מחזיר את העבר השני, אבל זה טיפול בתרחישי קיצוני. טוב, אז עכשיו בסוף סוף אנחנו יכולים להתחיל קצת לעבור על כמה תרגילים, אז כל העבודה הקשה הזאת הייתה כדי שעכשיו לפחות רשימות מקושעות יהיו לכם כל כך מושלע שעמוק לראש, שכבר התשובות יהיו לכם טבעיות יחסית. אז

103
00:45:21,060 --> 00:45:51,060
פה אנחנו מקבלים בתרגיל אולי הדבר הכי פשוט בעולם לעשות, התרגיל הזה הוא קל בצורה מכשילה, שימו לב. אומרים לנו תכתבו פונקציה שהיא מקבלת שתי רשימות מקושרות והיא פשוט משרשרת את הרשימה השנייה לסוף הרשימה הראשונה. מה הייתם עושים? שוב, קחו שתי רשימות, שרשרו את רשימה 2 לסוף רשימה 1. איך הייתם מממשים את זה? במספר הכי קטן האפשרי של פקודות ו..

104
00:45:51,060 --> 00:46:21,060
עוד יותר כדי להקל עליכם, תניחו שרשימה ראשונה לא ריקה. כן. תעשה נניח LST1、 LST2, תעשה מקביע על LST1, תעשה יו וייל על המקביע הזה, עד שאייפתיים מגיע לסוף אתה תפקוד. עד שמי, מי? הקרנט. קרנט או? שים לב אני רוצה לשרשר את ליסט 2 לסוף של ליסט 1. מה זה עוזר לי אם הקרנט הוא ניין?

105
00:46:21,060 --> 00:46:51,060
Ops לא, זה קרנט נקודה נאקס, בטח כאשר אתה מסתכל על מקום הפעולה ואז אתה אומר קרנט נקודה נאקס שווה ל 2 וגמרת זהו, זה כל מה שאנחנו צריכים לעשות, או פה בכלל, אנחנו אפילו לא עושים ריטרן, אנחנו עובדים רק עם קופי מקומי וזהו, קופי מקומי וזהו זה בדיוק מה שאמרת, הצלחת

106
00:46:51,060 --> 00:47:21,060
מצביע שאלה ראשונה, קריא, עדיין קיים. תמשיך, תמשיך, תמשיך. הגעת לסוף הרשימה הראשונה, יופי, שרשר. זהו, זה עד כדי כך היה פשוט. באמת שלא היה פה צריך לחשוב על משהו. אוקיי, הבנתם את השאלה הראשונה? אני חושב שאיבדתי את רוב הכיתה, שלושת你们 מהכיתה העבודה. אבל תבינו, זה היה הקליטה היחידה שיהיה מהתרגול הזה. הפעם לא היה לי זמן לשבת בנחת מול המיקרופון בבית ולהקליט, לבודדים שרואים את זה. טוב

107
00:47:21,060 --> 00:47:43,820
זה השאלה הראשונה. עכשיו שאלה שנייה, היא לא שאלה מאוד מאוד קשה, אבל עדיין שימו לב. אגב, פה אנחנו אפילו נעבוד עם משתנה צומת, מסוג עוד יותר פשוט. יש לו רק שני שדות, שדה value ושדה מצביע next. זה התבנית הקלאסית של צומת ברשימם כושרת. אוקיי.

108
00:47:43,820 --> 00:48:13,700
הטייפ בר הזה זה סתם, זה לא אני אגיד לכם מה אני לא רוצה להסביר על זה יותר מדי, כי זה באמת זה רק משהו שהוא לשם נוחות, לא ממש חלק קריטי במימוש, זה סתם דרך להגיד שהמילה נוד, אם אין גדולה, היא ממש תהיה כאילו סוג משתנה, אבל באמת אל תתעכבו על זה, בבקשה אל תתעכבו על זה. אם אתם רוצים להבין מה זה?

109
00:48:13,700 --> 00:48:43,700
‫אם יש לכם זמן פנוי, אין לכם, ‫תתעסקו עם זה בקוד פייתון, ‫אבל שוב, אין לכם, ‫אז בזמן שאין לכם. יופי. ‫בקיצור, נעבוד עם רשימה מקושעת פשוטה. ‫מבקשים איתנו, תכתבו פונקציה ‫שנקבלת N מספרים שלמים ‫ככלת מהמשתמש, ‫יהיה לנו אינטג'ר על אינפוט, ‫ובסוף מה? ‫הפונקציה תדפיס את המספרים האלו ‫בסדר עולה מהקטן הגדול, ‫זאת אומרת,

110
00:48:43,700 --> 00:49:13,700
‫אנחנו מזינים מספרים, והפונקציה ‫בסוף צריכה לדעת להדפיס לנו אותם ‫כבר ממוינים מהקטן הגדול. ‫והדרישה הסודית כאן, ‫או המומלט הנרמזת לנו, ‫שנעבוד עם רשימה מושכרת. ‫איך לדעתכם היינו ‫רוצים לגשת לכזה דבר. ‫מה היינו עושים? ‫-אנחנו מקורנים במוציאיינוו אה.. ליסק..  ‫אנחנו בונים. אנחנו בונים, ‫ואנחנו נרצה לבנות אותו ‫בצורה חכמה, בצורה ממויינת.

111
00:49:14,240 --> 00:49:26,260
אתה אולי חושב על אינסרצ'ן סורט, אבל לא למדנו על אינסרצ'ן סורט פה, אז לא משנה, אבל כן, אתה מתקרב מאוד, כן, דבר.

112
00:49:26,260 --> 00:49:43,600
אוקיי, אנחנו לא מקבלים אותם בסדרתית. לא, אנחנו מקבלים אותם סדרתית. פר אינפוט, אנחנו נרצה מראש לשים אותו במבנה נתונים שלנו, ככה שבסוף, מעבר אחד ליניארי על הרשימה המקושרת, ידפיס לנו אותם.

113
00:49:43,600 --> 00:50:13,600
them מהקטן הגדול. מי הולך להיות ראש הרשימה המקושרת? לא, העבר הכי קטן ברצף כל האינפוטים. שימו לב, אני אומר לכם עכשיו את הדבר הקריטי שמגדיר לנו את התשובה פה: אנחנו נרצה, כל פעם שאנחנו נקלוט מספר מהמשתמש, מראש, כל כל קלט  אחרי כל כלט כזה, לעשות אינסרט לרשימה מקושרת כך שהמספר הכי נמוך

114
00:50:13,600 --> 00:50:43,600
יהיה ראש הרשימה, אתם מבינים למה? -הסדר יעולה. -הסדר יעולה, המספר הכי קטן בהכרך יהיה ראש הרשימה והבן שלו יהיה המספר הכי קטן הבא בתור, והבן שלו יהיה הבא בתור, אתם מבינים? ויש דרך קלה לעשות את זה, כן. -אז נקבע נאוד, בואו נקבל איקס. -קיבלת מספר. -כן. אני בונה נאוד ואז אני מקבל, אלףים ... -אתה עושה נאוד עם ה-X הזה, כן? -כן.

115
00:50:43,600 --> 00:51:13,600
אני מתחיל Y ומקבל את ה-X שוב, אם הvalue שאני קיבלתי יותר קטן, אז אני מגדיר נוד חדש עם ה-X החדש שלנו ועושה insert מהחדש לישן, כך שהישן יהיה אחרי החדש, הוא יותר קטן, אחרת הוא יהיה ב.. הוא יותר קטן והוא נראה הראשון. ערך, צריך קצת להאדם את זה.

116
00:51:13,600 --> 00:51:43,600
אז בואו טיפה נעדן את זה. בסדר, בסדר, אתה בערך שם. אוקיי, אז בואו שימו לב. נניח שפה כפילויות לא מעניינות אותנו כי זה עניין של גדול או גדול שווה. אז נגיד אם כפילות, זה יהיה חלק מתרחיש אחר. אז ככה, נגיד כזה דבר. אוקיי, אז זה. קודם כל בואו להסתכל דווקא על הפונקציה שהם בחוץ. תסתכלו. אז, בואו דווקא להסתכל על הפונקציה החיצונית קודם.up getting portsoaded ideal..and exerced

117
00:51:43,600 --> 00:51:47,740
אפילו תדמינו שיש פה בסוגריים n כלשהו, סתם.

118
00:51:48,280 --> 00:52:18,280
אז אני מגדיר ראש רשימה כרגע שווה non, תראה, הוא 4-i in range n, דמינו שn הוא ערך כלשהו, אני אומר כזה דבר, value שווה האינט של אינפוט, אינטר אין אינטגר, אוקיי. אז יש לי פה מספר, דמינו שכל, הקלט, הקין וכולי וכולי. אז הנה מה שאני אומר, head שווה התוצאה של insert sorted עם מצביע ראש רשימה והvalue שאני שולח, זאת אומרת בכל רגע נתון שאני אקבל מספר,

119
00:52:18,280 --> 00:52:27,820
אני הולך להכניס אותו בצורה ממ�יינת את עצמה ולעדכן לעצמי את הרשימה המקושרת להיות כזאת אחרי המיון.

120
00:52:27,820 --> 00:52:36,140
ואז בסוף בסך הכל אני אגיד curren שווה ראש הרשימה ואז אני פשוט אעשה מעבר על הרשימה הזאת ואני אצא פרינט לvalue.

121
00:52:36,140 --> 00:52:46,440
אוקיי, זה רק המבחוץ זה המעטפת. עכשיו באמת איך אנחנו נעשה את זה. אז הנה הפונקציה עצמה. היא נראית קצת ארוכה אבל היא לא באמת ארוכה.

122
00:52:46,440 --> 00:53:16,440
אני הולך עכשיו להכניס לרשימה המקושרת, שאני מקבל אותה עם המשתנה הד, צומת שיש לו value כזה. אז קודם כל אני בונה את הצומת, אני אומר new_node = בנייה של משתנה מסוג node, m גדול, והשדה value שלו הולך לקבל את הערך value שבדיוק עכשיו קיבלנו באינפוט. אוקיי, בנינו צומת, עכשיו איפה מכניסים אותה? אז דבר ראשון, מקרה קיצוני.

123
00:53:16,440 --> 00:53:46,440
מה עם head רק? מה עם ראש הרשימה לא קיים? מה אם set  א הוא none? אז אנחנו בונים רשימה. נגיד כזה דבר - if head is none או, יותר טוב, אם המספר שעכשיו קיבלנו - שימו לב - המספר שעכשיו קיבלנו הוא קטן יותר מהמספר שהיה בראש הקודם. זאת אומרת קיבלנו עכשיו את המספר הכי קטן. אז לא משנה מה, אנחנו רוצים שהnew node שלנו יהיה הראש החדש. אנחנו נגיד new node נקודה לק שווה...

124
00:53:46,440 --> 00:54:16,440
מה שזה לא יהיה שהיה בהד, אם היה נאן, שיהיה נאן, אם לא, הרשימה קיימת, היא תהיה עכשיו יותר למטה, ואנחנו נחזיר את ה-new node בתור ראש חדש, נשמע הגיוני? Cellulose- קיבלנו value שהוא הכי קטן, בזה נשמע הגיוני לכם? רשימה מקושרת שהיא תהיה מסודרת מ-value הקטן הגדול,  זה היה מקרה הקהל, היא שאלה בסבבה , מה קורה בעקרון הזה שהיה קטן? יושב בהקאלה , נראה להם מחוץ שמחזיק

125
00:54:16,440 --> 00:54:46,440
וסקורד נוד = נקסט = head. 
שקר אתה מדבר על המקומה שלך? מי? אתה בדחומ על... отив לא הבנתי אותך. בוא נגיד שהיה 2,1,3. 2,1,3 לא רגע שנייה, אנחנו בונים את הפונקציה הזאת ככה שכל פעם שהפונקציה רצהhead הקיים הוא כבר היה ראש רשימה ממויינת, זה קריטי, אנחנו בונים את הפונקציה הזאת שקודם כל if head some search現ק

126
00:54:46,440 --> 00:55:16,440
איד איז נאן הבנייה הנכונה מתחילה עכשיו, כי אתה אומר ניו נוד הוא ההד החדש ואז ניו נוד נקודה נקסט הוא הד הישן, ואם הד הישן היה נאן, בנית רשימה של נוד 1 והוא כמובן ממוין בצורה ריקה, נכון? ועכשיו דמיין לעצמך שיש לך הד שהווליו שלו זה 2, וקיבלת בווליו חדש 1, אז תסתכל על האיף הזה, האיף הזה שואל שני דברים. אם הד

127
00:55:16,440 --> 00:55:46,440
האזנן או שהווליו החדש שקיבלת קטן מ-head.value - זה החלק שפספסת, כי עכשיו פה אנחנו תמידום שראש הרשימה יהיה הווליו שהוא קטן יותר אפילו מזה של head אם יש head. ועכשיו השאלה האחרת , מה אם קיבלנו value שהוא גדול או שווה למי שנמצא ב-head שהוא כן קיים? פה מגיע החלק השני של הפונקציה. אנחנו אומרים כרן שווה הד, זאת אומרת

128
00:55:46,440 --> 00:56:16,440
מצביע עזר, while current-next קיים וגם, זאת אומרת, מעבר על פני הרשימה וגם אם הvalue שקיבלנו עכשיו כפרמטר גדול מהcurrent נקודה-next, נקודה-value, זאת אומרת, הvalue שעכשיו קיבלנו אנחנו נרצה לשים אותו יותר בהמשך הרשימה, שוב, כי אנחנו בונים רשימה ממויינת ופה נגיד current שווה current נקודה-next עד שנקרא לזה.

129
00:56:16,440 --> 00:56:46,440
הגיעה למצב שבו, או שהגענו לסוף הרשימה, או שהגענו למצב שבו ה-value שלנו הוא קטן שווה לקרנט נקסט ואז, מצאנו בדיוק את המקום לעשות את פעולת אינסרט לרשימה המקושרת. נגיד, new node נקודה נקסט שווה לקרנט נקודה נקסט, ואז, קרן נקודה נקסט שווה לניו נוד. פה אנחנו בדיוק פשוט דוחפים, ממש כאן, את הנוד החדש שבנינו מה-value שקיבלנו

130
00:56:47,400 --> 00:57:06,500
זה מה שבונה לנו את הרשימה בצור הממויין, ויש כאן אפילו שאלה ששואלת אם אתם עקבתם מה היה קורה אם הסדר שלנו של new node next שווה ועד current .next שווה, מה היה קורה אם היינו עושים את זה בצורה הפוכה, האם זה עדיין היה מקשה לנו כמו שצריך? לא, למה?

131
00:57:11,500 --> 00:57:39,720
אם נניח היינו אומרים current .next, נניח ש-current .next היה non, זאת אומרת סוף הרשימה, non שווה ל-new node זה לא היה עוזר, כן, בדיוק, היינו עושים פה קישור שהוא לא טוב, כי אז היינו מאבדים את שאר הרשימה, אז הסדר כאן דווקא כן חשוב, בסדר. שוב, הייתי שמח להתעכב ואפילו להריץ לכם את הקוד שכתבתי, אבל אין לנו זמן, אני באמת רוצה לחסות איתכם את כל התרגול.

132
00:57:39,720 --> 00:58:09,720
נכון, נכון, בדיוק, מלכתחילה מעין אותנו שני דברים, גם לוודא שעדיין אנחנו נמצאים ברשימה וגם שאנחנו ממשיכים להעביר את value למקום המתאים שלו, אחרת הרשימה הייתה שוברת מיון קיים וזה לא טוב. בקיצור, שני חלקים של הפונקציה שבסך הכל דואגים, מיון קיים נשמר ואם המספר שקיבלנו ממייל הוא הכי קטן, הוא הולך להיות הראש. כדי לעשות את זה אנחי לא לחסוכים בטעות. נתחיל בלפרט model ערך מצד קמברנו מיואב דו ואנחנו הולכים למציאות צפון מהתקשינו של leaks לע

133
00:58:09,720 --> 00:58:32,540
את השאלה, שאלה, אם, תסתכל על הif הראשון, יש פה מילת מופתח שאתה אולי לא רואה מרחוק, כתוב פה, if head is none, or value קטן מ head נקודה value, כאשר head הוא לא none, אתה מבין? ה-or הזה שואל, קודם כל, אם head is none, אז בסבבה,

134
00:58:32,540 --> 00:59:01,400
New node הולך להיות ה-head החדש, אבל אם head הוא לא none, אז הבדיקה השנייה שואלת, היא נשאלת, עם value קטן מ-head הקיים, בסדר? אה, לא, כאן, new node נקודה next, שים לב השורה הראשונה, אולי שכחת אותה, בנינו כבר node מהvalue החדש, ואז אנחנו דוחפים new node נקודה next שווה head, מה?

135
00:59:01,400 --> 00:59:31,400
לא, לא, לא, אנחנו עובדים פה בצמתים, אנחנו לא משנים שדות value, וואו, כן, לא הספקתי להדגיש לכם, בעבודה עם רשתות מקושרות, עם צמת, עם רשימות... רשימות מקושרות, אתם לא משנים את שדות ה-values כדי למיים רשימה מקושרת, אתם לא עושים את זה, וואו, אין לכם מושג כמה פעמים בקורס המשך שאני פעם תרגלתי, הייתי צריך לדפוק את זה בראש של אנשים, לא נוגעים בשדה ה-value, ולא משנים את זה

136
00:59:31,400 --> 01:00:01,400
משנים את המצביעים כדי למייר. אז עכשיו, רפיט אאפטר מי, משנים את המצביעים, לא את השדות, זה בסדר, אל תחזור עליה, אבל לא משנם, תזכור. עוד שאלות? אוקיי, חייבים להמשיך. בסדר, שאלה שלישית, שאלה קלאסית, קלאסית קלאסית קלאסית, קחו רשימה מקושרת, תהפכו אותה, יש שתי דרכים לעשות את זה, גם בצורה איטרטית.

137
01:00:01,400 --> 01:00:23,800
וגם בצורה של פונקציה רקורסיבית, פה אומרים לכם אתם ממשים את זה בצורה של פונקציה רקורסיבית. שימו לב זאת באמת שאלה קלאסית. חייבים לדעת איך לעשות את זה, יש לכם רעיון? איך אני הופך רשימה מקושרת? יש לה רק שדה וואליו ושדה נט, לא משנים את שדה הוואליו, אגב. ממשים פונקציה רקורסיבית.

138
01:00:23,800 --> 01:00:52,300
קריאה רקורסיבית שמביאה אותי לתחתית, ואחרי שאני בתחתית, מה קורה אחרי הקריאה הקורסיבית? אני מקשר נקסט עם, מה אני מקבל? לא וואליו. תזכרו, עובדים על המצביעים, לא על הוואליו.

139
01:00:52,300 --> 01:01:22,300
אוקיי, אז הנה, בדיוק, זה הרעיון בערך. קודם כל, רגע, תגידו לי שיש פה מימוש רקורסיבי. יש. אוקיי, ואז אני אעשה את המימוש האיטרטיבי, רק שתדעו שאפשר גם וגם. קודם כל, רקורסיה, תראו, אז אני קורא לפונקציה הזאת reverse linked least recursive, היא מקבלת צומת, ועכשיו, דבר ראשון, התחתית של הקריאה הרקורסיבית, היא

140
01:01:22,300 --> 01:01:52,300
מה שאתם הייתם מצפים. אם צומת הוא כלום, או צומת נקסט הוא כלום, אז אני מחזיר עכשיו ראש חדש הצומת שקיבלתי, האם זה הגיוני לכם? שוב, אני רוצה להפוך את הרשימה המקושרת. העיף הראשון שלי זה תנאי הצירה כשהגעתי לתחתית. ואני אומר אם עכשיו אני כבר על נאן, או שאני הגעתי לעיוור האחרון ברשימה כי הבא בתורו הוא נאן, אני מחזיר את העיוור

141
01:01:52,300 --> 01:02:22,300
שקיבלתי בתור ראש רשימה, יופי, ועכשיו הקריאה הרקורסיבית מגיעה, הרשימה ההפוכה, זאת אומרת זה מצביע שאני בונה עכשיו, רוורס ס לית שווה מה שהפונקציה הרקורסיבית תחזיר לי, כשאני שולח לה את node.next. אתם יודעים למה? כי ראש הרשימה הולך להימצא בשאר הרשימה, כי אני הופך אותה, אז ראש הרשימה בהכרח הולך להתקבל מלעשות רוורס לשאר

142
01:02:22,300 --> 01:02:52,300
הרשימה המקושרת. ואז מה הפואנטה? מה הפואנטה? יש לי את זה. עשיתי רברס לשאר הרשימה ועכשיו אני עם הנוד הנוכחי שלי, ואני רוצה שהנוד הנוכחי שלי יהיה עכשיו האיבר האחרון של הרשימה. שוב זה פעולה רקורסיבית, ברקורסיה אתם יודעים ששאר הבעיה נפתרה ואתם רק מטפלים במה שנשאר. במק... במי שאתם נמצאים בו עכשיו. זה רקורסיה, אז הנה אנחנו מטפלים...נניח

143
01:02:52,300 --> 01:03:22,300
שאני עכשיו בראש הרשימה המקורית קראתי קריאה אקורסיבית שער הרשימה כבר נהפכה אקורסיבית ועכשיו אני רוצה שראש הרשימה יהיה האיבר האחרון אז שימו לב מה אני עושה. שימו לב מה אני עושה. אני עושה כזה דבר: אני אומר ראש הרשימה הישן נקודה נקסט. זאת אומרת האיבר השני נקודה נקסט

144
01:03:22,300 --> 01:03:44,660
שלישי שווה, רגע, יש מצב, יש מצב שיש, רגע, רגע, רק שנייה, אני רוצה להבין, בוא נראה, חכו שנייה, בוא נראה, מה אתם חושבים, אתם חושבים שזה יעבוד? בואו נראה, בואו ננסה לחשוב על זה, מה קורה כאן?

145
01:03:44,660 --> 01:04:14,660
לא מזל טוב, ב�יזיון שלך יש עוד עסק מאמציה, נתחיל להציג להחלט בדרך השאלה שלך. לא רגע רגע, חכם שניה רגע קודם כל, הכרה אקרוסיבית אני מקווה שהבנתם אותה נכון? זאת אומרת, יש לי reverse list עם ה-node next שמה, וה-node next הוא עכשיו האיבר האחרון. הבנתי, אוקיי, בסדר, יש מצב שקצת הלכת לאיבוד, עכשיו נזכרתי. אוקיי, בואו תסתכלו שניה בבקשה. תסתכלו בבקשה. קודם כל, מי זה?

146
01:04:14,660 --> 01:04:44,660
מי זה נוד נקסט? אני עכשיו רוצה לשאול אתכם, מי זה נוד נקודה נקסט? זה העבר האחרון ברשימה המקושרת שהפכנו מקודם, שוב, אנחנו הפכנו את הרשימה המקושרת החל מNode Next עד לעבר האחרון, הפכנו אותם, זאת אומרת, העבר השני של הרשימה המקורית הוא עכשיו העבר האחרון בהפוכה, ונשאר לי רק צעד אחרון, להגיד, ה

147
01:04:44,660 --> 01:05:14,660
העבר האחרון של הרשימה שהפכנו, הנקס שלך הופך להיות ראש הרשימה הישן. ואז אני אומר ראש הרשימה הישן, עכשיו הנקס שלך הוא כלום. ובכך סיימתי את העבודה על להפוך את הרשימה המקושרת, זה לקח לי אפילו לי קצת זמן להיזכר, אבל אני רוצה לדעת האם אתם הצלחתם לעקוב. אם לא, אם לא, אני יכול לכתוב פה נופט זריז מאוד ואתם תראו שאתם תעקבו גם. חכו שנייה. לא לא. בבקשה...

148
01:05:14,660 --> 01:05:44,660
באמת, באמת, זה יהיה מאוד מאוד מאוד זריז, תסתכלו. אוקיי, ממש ממש חשוב שתראו. נניח יש לי Node, יש לי Node.next, רגע, אני כן רוצה שתבינו את זה. אוקיי, יש לי Node.next ויש לי ..תחטיט אהלן ותחטיט אהלן. אוקיי, תראו מה קרה, ברקורסיה אני שלחתי את Node.next עד לתחתית הרשימה, אתם מבינים? זה השורה הזאת. אתם מכירים את זה? למחרת גרופאיה, כאילו עם השורטרame שבבינינו רק בבחינתה שנקראים פשוט "קט" יש לה את זה האלוק שלמשהו אותה שקושפת בבינינו המיועד

149
01:05:44,660 --> 01:06:14,660
אז אחרי השורה הזאת שם r vs small ס שמא, הפכנו את שאר הרשימה המקושרת ככה שעכשיו node next עכשיו נכון לרמה הרקורסיבית הזאת הנוכחית node nxt הוא בכלל העבר האחרון של הרשימה שהפכנו, אתם מצליחים להבין למה? תחשבו על זה ככה, אני שולח רשימה מקושרת שמתחילה ב

150
01:06:14,660 --> 01:06:44,660
ונגמרת בN, ואני הופך אותם מי הראש החדש N ומי הזנב החדש 2 יופי node-next זה 2 עכשיו מה אני אומר 2.Next = הראש הישן. ואז אני אומר ראש הישן עכשיו אין לך מישהו הבא בתור, עכשיו הבא בתור שלך הוא כלום. אתה הבן אדם האחרון. עכשיו הבנתם?

151
01:06:44,660 --> 01:06:54,400
פה אני רק מסיים את העבודה שעשינו את הרקורסיבית עבור שאר הרשימה. לא הצלחתם?

152
01:06:57,820 --> 01:07:14,640
לצייר, האמת לצייר זה לא אופציה רעה, פשוט אין לנו זמן לכלום, אבל אוקיי, גם ככה אנחנו נגררים מעבר להפסקה אז וואטאבר. טוב, אז שנייה. אוקיי, שנייה, שנייה, שנייה. זה לא אמור להיות, רגע.

153
01:07:14,640 --> 01:07:44,640
אני באמת, זה זה יכול להיות די מובן, אוקיי שנייה, אוקיי, אז נניח יש לי פה... אה, הרזולוציה כל כך קטנה, שנייה הרגע, אה... כן, אוקיי. לא לא לא, אני לא.. אני טיפוס דיגיטלי, אוקיי. וואי וואי זה ממש גבוה, כן כן כן. אתה משתמש ב..ב..2016 למה?מוריד ב..זה הטו שלי, אוקיי, אתם יודעים מה שהוא בסדר, תסתכלו לרגע.

154
01:07:45,740 --> 01:07:55,320
תסתכלו לרגע, איזה גרוע, אבל הרשימה הישנה, דמינו שהיא שלושה איברים בסדר? אחד והנקסט שלו זה שתיים והנקסט שלו זה שלוש.

155
01:07:56,500 --> 01:08:15,720
רקורסיבית, הקריאה הרקורסיבית שלחה את שתיים שקורה לשלוש, ועשתה מהם רוורס. עכשיו יש לי, הנה אני אכתוב את זה ממש... הנה, הסתכלו, הסתכלו. עכשיו יש לי את שלוש והנקסט שלו...

156
01:08:15,720 --> 01:08:45,680
זה שתיים, זה ברקורסיה. עכשיו, עכשיו אני גרום לכם להבין, גם מי שאיבד אותי, אתם תחזרו חזרה לחיים. אוקיי, אתם רואים את השורה, את הפקודה הזאת? קריאה רקורסיבית לשאר הרשימה? יופי. התוצאה שלה זה מה שאתם רואים פה בכחול. עד כאן מי שאיבד אותי, את זה לפחות אתם מבינים? את ההיפוך הזה בסך הכל.

157
01:08:45,680 --> 01:09:15,680
אז אה איך זה התכלס? אין בעיות, אתה יודע משהו? וואו כמה שאין לזה זמן, אבל אני אגיד לכם, לא זה בסדר, מה? אני אגיד לכם מה? חכו שנייה. אני אגיד לכם מה אני אעשה, אני אציג למסך עכשיו, לכמה שניות, קובץ TEX שאני בניתי כדי להסביר היפוק של רשימה מקושרת, בקורט רחוק כשמזג.

158
01:09:15,680 --> 01:09:45,680
Assembly ואז בהקלטה אתם תוכלו להסתכל על קורבץ הזה את הסופאוז. לא, זה קוד ששייך לקורס אחר, אבל שנייה רגע, חכו שנייה, תנו לי רק כמה שניות ואז אני פשוט אעבור לשאלה הבאה, רק רגע. חכו שנייה, פשוט אין לנו הרבה זמן, כמו שאתם אולי מבינים. רק שנייה, כן, סבלנות, סבלנות.

159
01:09:46,640 --> 01:09:52,420
סברנות אוקיי אני אוקיי תראו

160
01:10:00,540 --> 01:10:30,540
אוקיי, אני רק מציג את זה לרגע, בשביל ההקלטה, אבל שתדעו, בקורס אחר שתרגלתי פעם, אני למעשה בניתי קובץ טקסט, עם האינדנטציות המתאימות,..כדי להראות לכם, איך הסיפור הזה עובד. הרעיון היה ש, אני באמת לוקח רשימה מקושרת, אני אומר, הראש החדש הוא התוצאה של לעשות רברס לשאר הרשימה, ואחרי זה,

161
01:10:30,540 --> 01:11:00,540
אני אומר, אני קודם, אני פה זה כתוב בסדר הפוך אבל אחרי זה אני אומר הנקסט של האיבר האחרון מהרשימה, תן לי משהו, אנחנו הולכים לאיבוד, בקיצור, עשינו, הפכנו את שאר הרשימה, פשוט הפכנו את שאר הרשימה ואז אמרנו, הראש הישן נקודה נקסט, שזה האיבר האחרון,

162
01:11:00,540 --> 01:11:30,540
בעצם החדש, נקודה נקסט שלך, הולך להיות שווה לראש הישן. זאת אומרת, זה. טוב, מפאת חוסר זמן משווה, אני חייב לעצור את זה כאן. המ.. אם אתם עדיין לא מבינים, אתם יכולים פשוט לשאלו בדיסקורד אפילו, אני אנסה להסביר לכם, זה פשוט, אין לנו זמן, ואני עוד לא דיברתי איתכם על תור ומחסנית, וזה חומר חובה לקורס, ואפילו בהרצאה, לא לא לנספיק להעביר לכם את זה. אז אני חייב

163
01:11:30,540 --> 01:12:00,540
שהם תהיו מרוכזים. מה? בסדר, נו, אוקיי אז, בסדר, אוקיי. הפתרון האיטרטיבי, אני אשאיר לכם אותו לאחר כך, תקראו אותו בזמנכם הפנים. אוקיי, אין זמן, אין זמן, אין מה לעשות, יש כל כך הרבה מה ללמד אתכם, אבל אין מספיק זמן. טוב, יש פה שאלה שהיא בודקת האם יש מעגל ברשימה המקושרת

164
01:12:00,540 --> 01:12:30,000
אני אגיד לכם את הגרסה הקצרה, אם אתם לוקחים שני מצביעים, מצביע איטי ומצביע מהיר, ואתם פשוט מקדמים את המצביע איטי, אתם עושים לו פשוט איטי נקודה נקסט כל פעם, ואת המהיר אתם עושים לו מהיר נקודה נקסט נקודה נקסט כל פעם, אז בעצם יקרה שהמצביע מהיר יתקדם אחד מהר יותר מהאיטי כל פעם. ומה הרעיון? אם יש מעגל ברשימה המקושרת, אגב מה זה מעגל?

165
01:12:30,000 --> 01:12:59,860
זה אומר שהנקסט של האיבר האחרון הולך להיות אחד מהאיברים היותר מוקדמים ברשימה, על כן מעגל, אז מתישהו המצביע האיטי והמהיר בהכרך ייפגשו, כי המהיר כל הזמן מתקדם קדימה צעד אחד יותר מהר מהאיטי, אז מתישהו הם ייפגשו, כי כל צעד המהיר הוא יחסית מתקדם אחד יותר מהר מהאיטי.

166
01:13:00,340 --> 01:13:28,880
כל פעם, מתישהו במעגל הזה המהיר יתפוס את האיטי, יש לזה הוכחות, ההוכחה המלאה לזה אתם תקבלו בקורס אלגו, יש פה רק דוגמא על המימוש הזה בפייתון, המימוש הוא פשוט בצורה מחרידה, ויש פה אפילו שקופית שניסיתי לתת לכם אינטואיציה, אופה, לא הוכחה, רק אינטואיציה, מקווה שהאינטרנט לא חוסל פה בקמפוס, טוב, נקיה ונראה.

167
01:13:28,880 --> 01:13:58,260
בקיצור, אני שם את זה לאחר כך. עכשיו חלק של החומר שגם אם אתם תלכו הביתה עכשיו, אתם תצטרכו להשלים אותו אחר כך לא משנה מה. אז תנסו להיות איתי. (אז אופק לך להפיליק חיפוש בינארי?) -לא. אני מנסה להגיד מה שאני לא מספיק מהתרגול הוא עדיין חלק מהחומר חובה. אגב, זוכרים לפני שני תרגולים כשדילגתי על חיפוש בינארי? אני מקווה ששלמתם אותו, כי חיפוש בינארי זה חלק מהחומר חובה. (נתיים להפיליק חיפוש בינארי) תרגול 8 (אה, תרגול 8)

168
01:13:58,260 --> 01:14:24,660
מה? זמן. מה? מקווה שהשלמתם, מה שאני תמיד מדלג עליו, אתם כן צריכים להשלים אותו. אגב, ההפסקת חשמל שחוויתם עכשיו, היא כן חיסלה את האינטרנט, אז הזום חוסל. אבל זה בסדר, אני מקליט בקומית, אז הכל טוב. אין בעיה, בואו נמשיך. טוב, מי שבזום נדפקו, מי שפה, לא יודע, נדפקו בסיבות אחרות. אוקיי, טוב.

169
01:14:27,900 --> 01:14:57,900
תעשו רפרש, רגע, תעשו רפרש, F5 במוח, תיקחו שנייה לנשום. אין וי-פיי. אין וי-פיי, נכון, אז... השתמש על ה-.. בסדר, אה, אין וי-פיי, כן, חיפוש וי-פיי, כן. טוב, יש שני מבנה נתונים מאוד מאוד סופר-דופר בסיסיים, שהם יצריכו שתכירו, הם מבוססים על רשימה המקושרת עם שנויים קטנים. למעשה, אתם יכולים לממש אותם, אפילו בלי רשימה המקושרת, אלא פשוט להשתמש ברשימה רפתית.

170
01:14:57,900 --> 01:15:27,900
רגילה, ופשוט להתייחס אליה בתור המבני נתונים האלה. איך? אתם כבר תראו. אז רק שנייה בבקשה, כן, הזום נדפקו... תכתבו מקסימום בוואטסאפ למי שבזום, שאני אפתח את הזום אחר כך במעבדה, ושהקלטה ממילא לא נהרסה, אבל תכתבו להם. אוקיי, מה זה תור? מה זה קיו? זה ארבע מילים האלה. פרסט אין, פרסט אאוט. מה זאת אומרת?

171
01:15:28,620 --> 01:15:58,620
דמינו לעצמכם, רשימה. הבן אדם הראשון שנכנס לתור, הוא יהיה הראשון שיצא. למה? כל פעם שאתם מכניסים מישהו לרשימה, אתם מכניסים לרשימה בהתחלה שלה. כלומר, אינדקס 0 החדש של הרשימה, הולך להיות מי שעכשיו אתם מכניסים. אבל מי שיוצא כשאתם עושים פעולת הפופ, יהיה הבן האדם האחרון ברשימה. עכשיו למה...

172
01:15:58,620 --> 01:16:28,620
למעשה אפשר להדגים לכם איך זה עובד בליסט. אני אומר תעזבו אתכם לרגע מלינקד ליסט זה פשוט בצורה להחריד. נניח שאנחנו עושים פושט טו קיו. מה זה? זה בסך הכל לקחת רשימה ולעשות לה אפנד, שימו לב מה אני עושה, באינדקס 0. לא לא, לא רגע רגע, אפנד לא, סליחה, לא לא, אפנד

173
01:16:28,620 --> 01:16:58,620
לא, לא, הפן מוסיף לסוף, סליחה, מה שאני עושה, זה כזה, אני עושה ליסט, לא, אני עושה, לא, תראו מה אני עושה, אני עושה, נקרא לזה, שימו לב, שימו לב, זה בסדר, זה ישרוד, node פלוס שווה list, new node נקרא לזה new value, רק כדי שלא תלכו לאיבוד לרגע, כאילו, עכשיו אתם, אתם, לא רגע, מה אנחנו אמרנו ברשימות רגילות בפייפ

174
01:16:58,620 --> 01:17:28,620
זה. אוקיי, כרגע אני רק מראה לכן אינטואיציה ברשימות רגילות, כמובן שאפשר לממש את זה ברשימה מקושרת, אבל אני רוצה שתראו את התחילות, תקבלו אינטואיציה. מה זה אומר לדחוף להתחלה של... לשים מישהו בהתחלה של התור? זה בדיוק ככה, אני אומר, הבן אדם החדש שאני דוחף לתור, אני דוחף אותו בהתחלה של התור, אז אני אומר ניו ואליו, אבל כי חלק מרשימה, פלוס שווה הליסט הישן, זאת אומרת. אה, לא פלוס שווה, סליחה,

175
01:17:28,620 --> 01:17:58,620
רגע, שנייה, לא אני לא רוצה שאנחנו נלך לאיבוד, מה אני צריך לכתוב ליסט שווה לניו נוד פלוס ליסט, טוב בסדר, אוקיי, זה נראה לכם מובן, הרעיון הזה, אנחנו דוחפים, מישהו נכנס, מישהו שהוא נכנס, הוא נכנס, לא, לא, שנייה, שנייה, רגע, רגע, זה בסדר, אני אומר כאילו, אני מכניס מישהו, מישהו כאילו…

176
01:17:58,620 --> 01:18:28,620
מה זה סוף התור בעצם? סוף התור זאת אומרת, תחשוב שהבן אדם הראשון שיוצא מהתור, זה הבן אדם שהכי רחוק ממך בתור, כשאתה בדיוק נכנסת, נכון? אז זה איך שאני אכנס לתור, ואז איך שאני עושה פופ פרום קיו, אז זה קל, אני עושה ליסט נקודה פופ. פונקציית פופ תעיף את האיבר האחרון ביותר מהרשימה, רגילה, ליסט רגיל בפייתון, פופ רגיל. יש פונקציית פופ.

177
01:18:28,620 --> 01:18:58,620
שהיא עובדת במשתנה מסוג רשימה בפייתון. היא מעיפה את העיבר האחרון ביותר, אחרון. 
- אבל שנייה, אתה אמר... 
- לא חובה. הדיפולט, הדיפולט. 
- זה האחרון?
- זה האחרון ברשימה 
- אבל, גלגל, אנחנו אומרים, הכול שנכול... 
-  אתה צודק, אתה צודק, אבל שתדע שיש גם תור. 
- אבל, אבל שנייה, אתה, כשאתה מכניס לי התור, אתה מכניס לי הטור, כי זה...

178
01:18:58,620 --> 01:19:02,740
‫לפעוף עם פס אופטוס, ‫לא להפעוף עם פס אופטוס.

179
01:19:04,740 --> 01:19:07,740
‫זה גם אופציה. ‫לא, אתם צודקים.

180
01:19:07,800 --> 01:19:19,180
‫לשם נוחות, להכניס מישהו לתור, ‫אפשר, כן, אפשר לעשות נקודה, ‫ליסט נקודה, אתה יודע, אפנד.

181
01:19:19,240 --> 01:19:22,200
‫לא, אבל זה ככה ארוך, לא? ‫-לא, שנייה, שנייה.

182
01:19:22,260 --> 01:19:28,560
‫נניח שאתה עושה אפנד, ‫אפנד זה אתה יודע שאתה מוסיף לסוף, נכון? ‫אם ככה, אם ככה...

183
01:19:28,560 --> 01:19:58,560
כדי לעשות פופ פום דה קיו, אתה בעצם עושה פופ באינדקס 0, זאת אומרת, סבבה, קחו אלטרנטיבה, זה גם יעבוד אותו דבר, אין בעיות, אין בעיות, הנה אלטרנטיבה שגם תעבוד לגמרי, מה הרעיון של תור, קחו רשימה רגילה בפייתון, ליסט רגיל, אתם מוסיפים מישהוא לתור, אין בעיות, לך לסוף התור, אפנד, אתם יודעים מה זה עושה, אתם רוצים להוציא מישהו מהתור, מישהו סוף סוף הגיע תור שלו, הוא

184
01:19:58,560 --> 01:20:28,560
הוא באינדקס אפס. אז זה מפרסם לי נקודה פה, באינדקס אפס. בדיוק כמו תור של... כן כן, הדוגמא פה היא תור לרופא. בסדר. אוקיי. יופי, בקיצור זה מה שזה, אוקיי? זה  מה שזה. זה מה שזה, זה הרעיון. בן אדם שנכנס לתור, בסדר, הוא נכנס אחרון, הבן אדם שיוצא מהתור, זה הבן אדם שנכנס הכי מוקדם, בסדר? נו כן, כן, בסדר, אתם יודעים איך תור עובד, אתם יודעים איך תור

185
01:20:28,560 --> 01:20:58,560
אני לא צריך להסביר לך, אני מקווה, לא יודע, יש אנשים שבשביליהם תור זה רק המלצה, בכל מקרה, מקווה שאתם יודעים. אוקיי, בסדר, יש לנו סלק תור, עכשיו, זה התרגול, בסדר, טוב, יש לנו פה המלצה למימוש, זה רק המלצה, זה לא חובה, אנחנו יכולים בעזרת Node וData Class לעשות תור, אז אנחנו מגדירים לעצמו סתם איזשהו צומת, יש לו שני שדות נתונים ושדה אחד Next,

186
01:20:58,560 --> 01:21:28,560
בסדר לא רלוונטי, אפילו נגדיר q, פשוט נכתוב q, האות q בתור q, תור... מדהים, זה לא חדווה אבל תודה, q שווה n, ואז איך אנחנו יכולים לדחוף אנשים לתור? האמת? פשוט מאוד. זה רק המלצת מימוש, אתם לא חייבים לזכור אותו בעל פה אבל אתם כן צריכים לדעת לכתוב כזה מימוש לבד. זה כן, לא שאתם צריכים להתעסק הרבה. הנה נניח המלצה למימוש

187
01:21:28,560 --> 01:21:58,560
של דחיפה לתור, הדחיפה לתור מקבלת את התור הקיים כפרמטר ואת מי שאנחנו רוצים לדחוף לתור כפרמטר, אז יש לנו q קיים ונote, ומה אנחנו אומרים? את הדברים הבוררים אליהם, אם q is none, כלומר אם התור ריק, נחזיר את הנote, הנה הבן אדם הראשון בתור, זה שהוספנו, קסם. זה המלצה למימוש של פונקציית push לתור, אם אנחנו מממשים תור בעזרת

188
01:21:58,560 --> 01:22:28,560
Data Class Node, למי ששאל אותי. שוב, מה שנראית לכם בנוטפד זה למי שלא רוצה לממש מבנה נתונים חדש, אלא רוצה לקחת ליסט, רשימה רגילה, ורוצה להשתמש בפונקציונאיות הקיימת שלה בצורה של תור. בסדר? פה זה המלצה למימוש סביב דוגמה למבנה נתונים שאנחנו

189
01:22:28,560 --> 01:22:58,560
נותנים רק לשם המחשה, זה דוגמה, אתם יכולים לעשות אימפורט, יש לפייתון האמת היפ וסטרק וכל מיני, יש לפייתון דברים שאתה יכול לעשות להם אימפורט, שוב פה אנחנו רק נותנים דוגמה, אוקיי. בדוגמה הזאת של לדחוף לתור, אז אנחנו כותבים פונקציה, מקרה בסיס, אם התור ריק, התור הוא עכשיו הצומת שרצינו לדחוף לתור, אז אנחנו כותבים פונקציה, מקרה בסיס, אם התור ריק, התור הוא עכשיו הצומץ שרצינו לדחוף לתור בעצם, לא בשייה שלנו ושנמגיעי לכסי של יותר משהו, זהו שאתם לא מוכנים להיות

190
01:22:58,560 --> 01:23:28,560
עכשיו, אם התור לא ריק, אנחנו נעשה פה טרוורס על התור כדי להוסיף לסוף שלו איך? לפי פונקציונאיות האינסרט שכבר ראיתם פה הרבה נגיד קרנט שווה מצביע איזר שהוא מתחיל מהתחלה של התור, ווייל קרנט נקסט עדיין קיים, תקדם את קרנט, ואז כשהגעת לסוף התור, קרנט נקודה נקסט שווה הבחור שעכשיו התווסף לתור, נחזיר את התור המקורי שהתווסף לו לסוף, הנוד שבדיוק הוסף לו

191
01:23:28,560 --> 01:23:58,560
זה כמו שראיתם מקודם, זה אינסרט של נוד לסוף הרשימה. זה הכל. עכשיו, אפשר גם כמובן להעיף מישהו מסוף הרשימה, אז נעשה, ניתן דוגמא למימוש ההאפה מישהו מסוף הרשימה, לא שומע? שוב, זה תלוי מימוש, פה ספציפית בפוש, אנחנו כאילו דוחפים אותו לסוף התור, למה? כי אז מי שיוצא מהתור, זה הופיע שם,Jeremy, משמש. הטור החוה עובד הזה הוא שאתה מוציא עצמך לחיים את עצמך ואתה חושב בחפיש ממנו שאנחנו מוצאים את זה בגללככשיו מחורך לדעתתעסקתנו

192
01:23:58,560 --> 01:24:28,560
זה הראשון בתור, נכון? הבן אדם הראשון בתור. מה? -מסתכל ב.. התור שמעלה. לא, אז פה אנחנו עושים את זה הפוך, במימוש הזה. תקשיב, תור ומחסנית - יש לך הרבה דרכים לממש אותם, רק תהיה עקבי בתוך המימוש שלך. פה אני מראה דוגמה למימוש, שבה ראש הרשימה, ה head, זה באמת הבן אדם הראשון שנכנס לתור, וסוף הרשימה, זה הבן אדם האחרון שעכשיו נכנס לתור. זה למה בדוגמת המימוש פה, בחור,

193
01:24:28,560 --> 01:24:58,560
אני דוחף לסוף הרשימה את הבן אדם החדש בתור. ועכשיו כשבן אדם סוף סוף יוצא מהתור הגיע תור שלו, אני קורא לפונקציית פופ. פופ תעשה את הדבר הכי פשוט שבעולם, קודם כל היא תגיד: אם התור ריק, אז ריק, תחזיר כלום. אחרת, אני אומר כזה דבר, אני אומר: התור החדש שווה לתור הקיים נקודה next, ואז אני אומר:

194
01:24:58,560 --> 01:25:28,560
הראשון בתור, עכשיו אין לך נקסט. כי אתה עכשיו יוצא מהתור ואני פשוט מחזיר את הראשון בטור ואת התור החדש. זאת אומרת, אני קורא לפונקציה q_pop, אני אקבל את מי שיצא עכשיו מהתור, מנותק משאר התור ושאר התור כבר קודם. q.next, אני מנתק את הקשר שלו משאר התור. זה הכל, מקוויץ תשלים. ונהיה לחכם. אה...

195
01:25:29,000 --> 01:25:59,000
בסדר, אוקיי זה רק דוגמא למימוש, בסדר זה דוגמא למימוש. עכשיו היה את הרעיון של תור, עכשיו אני כן צריך להראות לכם גם את הרעיון של מחסנית, מחסנית, הרעיון במחסנית הוא: הדבר האחרון שהכנסתם, הוא הראשון שייצא, וכמה שעבר יותר זמן, כמה שהכנסת ממישהו, והכנסתם על גביו עוד ועוד ועוד דברים, הוא פשוט יהיה האחרון שייצא, זה הרעיון של מחסנית.

196
01:25:59,000 --> 01:26:29,000
אפשר יותר, last in, first out, אוקיי, ומחסנית גם יש לה שתי פונקציות הבסיסיות, יש לה פונקציה לדחוף מישהו למחסנית, או פונקציה להוציא את מי שהכי למעלה במחסנית, יש אפילו פונקציה עוד יותר פשוטה שהיא סתם אומרת, לא יודע, זה סתם פונקציית עזר, תראה לי מי נמצא עכשיו הכי למעלה במחסנית, אבל זה מה שנקרא חלק מהקוד של להוציא את מי שנמצא הכי למעלה במחסנית

197
01:26:29,000 --> 01:26:47,080
אז אני אפילו לא יודע אם מגיע לזה פקודה משל עצמו, מה שתגידו. בכל מקרה, גם את זה אפשר לממש בעזרת רשימה רגילה, אפשר לממש את זה בעזרת רשימה רגילה, ואפשר גם לממש את זה בעזרת רשימה מקושרת.

198
01:26:47,080 --> 01:26:58,080
ופה אני רק נותן דוגמה מאוד מאוד זריזה לאיך אני מממש את זה בצורה של רשימה מקושרת. אני יכול לעשות פוש למישהו לרשימה, שזה הכי פשוט שבעולם.

199
01:26:58,080 --> 01:27:28,040
אם הרשימה המקושרת שלי ריקה, הבן אדם שדחפתי הוא עכשיו ראש הרשימה ביי. אחרת אני אומר, רשימה ישנה, את הולכת להיות הנקסט של הבן אדם החדש שקיבלנו. דוחפים מישהו לטופ של הסטייק, אז הוא הראש החדש. כן? נוד חדש, אתה הולך להיות ראש הסטייק החדש, אתה הראש הסטייק החדש. אז אני אומר, נוד חדש הנקסט שלך, הוא הסטייק הישן.

200
01:27:28,040 --> 01:27:58,040
אנחנו נתנו שלושה שניות ל�אחרון, אתה מכניס את זה?  כן, אתה דוחף מישהו למחסנית, אז דחפת, הנה, זה הראש החדש, מחסנית. אז תמיד נקבל את האחרון בפוד, נכון? הבינאדם האחרון שדחפת הוא הטופ של הסטייק עכשיו? כן. וזה אגב למה פונקציית ה-S_TOP פה, היא קצת טריוויאלית, מה אני עושה פה? מחזיר את הסטייק, זאת אומרת, ראש המחסנית, שזה הטופ, בסדר. אז בוא תאכל את זה, זה טוב, בגלל שאתה, בזה, אם מורכזי לנן, אתה

201
01:27:58,040 --> 01:28:07,380
כן, כן, ואז פה כשאני עושה פופ, אז קודם כל, אם אני רוצה לעשות פופ עם מחסנית רכז, לא, לא, לא, סטופ, ריטרנט כלום, אחרת אני אומר, אין בעיות.

202
01:28:07,380 --> 01:28:27,860
המחסנית החדשה היא מי שהנקס של הראש שעכשיו נמצא, זאת אומרת, המחסנית היא עכשיו כל השאר, ואני אומר עכשיו, הטופ שאני עכשיו הולך להעיף, אני מנתק אותו ממחסנית כי אני עושה s.next=non, ואז אני מחזיר את שאר המחסנית ואת מי שאני עכשיו ניתקתי.

203
01:28:27,860 --> 01:28:57,600
שוב, זה רק המלצות למימוש, אפילו הסדר פה, זה תלוי בכם, כאילו סתם, זה רק דוגמאות. ועכשיו, אני כנראה לא אספיק, אז תוכלו להשלים. בעקרון יש פה שני תרגילים, תרגיל אחד שאתם יכולים לממש אותו בעזרת תור, ותרגיל אחר שאתם יכולים לממש אותו בעזרת מחסנית, ובהצעות הפתרון, אני ממש הלכתי על הכי פשוט שיש, וכתבתי את הפתרון.

204
01:28:57,600 --> 01:29:27,600
נטו בצורה של ליסט רגיל. ליסט רגיל ופשוט הצורה שבה אני מתייחס לליסט בתור או תור או בתור מחסני, אבל שוב זה תלוי מימוש, זה תלוי בכם, זה תלוי בדרישות שתקבלו בתרקית בית או במבחן והגענו לסוף התרגול. אני רק אומר מה שדילגתי עליו תשלימו לבד מה שלא היה לכם ברור תסתכלו שוב להקלטה תקראו את התרגול תסתכלו על קוד הפייתון אני אפילו

205
01:29:27,600 --> 01:29:57,600
זה מה שעצוב, לא הספקתי אפילו... רגע שנייה, חכו רגע, חכו שנייה רגע רגע, חכו שנייה. אני רק אומר, יש במודל קוד פייתון מלא של כל התרגול, כל החלקים של התרגול, מחולק לתאים נפרדים של ג'ופיטר, כמו בהרצאות. תריצו מה שאתם לא מבינים, תשענו מה שאתם לא בטוחים לגביו, הכל נמצא פה. הכל פה.

206
01:29:57,600 --> 01:30:03,760
בסדר? אוקיי, אז מבחינתי תשלימו את כל מה שנשאר מהתרגול. זהו, התרגול נגמר. נעצור הקלטה.

