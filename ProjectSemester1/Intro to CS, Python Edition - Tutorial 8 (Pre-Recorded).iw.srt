1
00:00:00,420 --> 00:00:24,120
היי, ברוכים הבאים לתרגול השמיני של הקורס מעבור למדעי המחשב. נושא התרגול היום יהיה בעיקר ענייני סיבוכיות, סיבוכיות זמן ומקום של כל מיני תוכניות שנכתוב, ובסוף ניגע קצת בחיפוש בינארי. אז בואו נתחיל. מה זה בעצם בשבילנו סיבוכיות?

2
00:00:24,120 --> 00:00:50,960
אז נחשוב על זה באופן כללי, מבחינתנו סיבוכיות בשביל משהו שנרצה לעשות, תוכנית שנכתוב, אלגוריתם שנרצה להריץ, סיבוכיות זה בעצם מדד לכמה משאבים, כמה זמן אנחנו צריכים, או כמה זיכרון אנחנו צריכים בשביל להריץ את התוכנית או את האלגוריתם שלנו.

3
00:00:50,960 --> 00:01:20,820
ספציפית, אנחנו נמדוד סיבוכיות ביחס לגודל הקלט שאיתו אנחנו נעבוד, כי בסופו של דבר, כמעט כל תוכנית וכמעט כל אלגוריתם שנריץ או שנכתוב, הם תמיד יעשו פעולה על קלט כלשהו. זאת אומרת, יש קלט, יהיה את האלגוריתם או את התוכנית שיקבלו את הקלט, יעשו מה שהם יעשו, ויוציאו פלט, אז סיבוכיות זה בעצם...

4
00:01:20,820 --> 00:01:50,120
כמה זמן וכמה מקום היינו צריכים בשביל להריץ את כל הסיפור הזה. וזה ייתן לנו דרך לדעת אם התוכנית או האלגוריתם, הם משהו יעיל, יחסית יותר, יחסית פחות, הכל אנחנו למדוד בצורה השוואתית. אז אם כבר מדברים על השוואות, תראו כאן שתי דוגמאות לקוד פייתון פשוט, שפשוט מחשב סכום.

5
00:01:50,720 --> 00:02:19,920
מה הסכום שהוא מחשב? אנחנו בעצם מחשבים את הסכום החל מהמספר 1 עד מספר n טבעי כלשהו. אז אתם רואים כאן שתי דרכים לחשב את הסכום. הדרך שמימין, ממש מחשבת את הסכום הזה איך שאנחנו היינו עושים את זה מה שנקרא על הידיים, סופרים אצבע אצבע. אז היינו אומרים נתחיל מסכום ששווה 0, ואז עבור כל מספר.

6
00:02:19,920 --> 00:02:27,620
שבטווח בין 1 עד לאותו n נוסיף אותו לסכום הרץ וכשנסיים את הכל נחזיר את הסכום.

7
00:02:28,480 --> 00:02:38,960
מנגד בצד שמאל יש לנו קוד פייתון שאומר היי אנחנו כבר יודעים מה הנוסחה של סכום המספרים מ-1 ועד n כולל.

8
00:02:38,960 --> 00:02:49,500
אנחנו יודעים שזה n כפול n ועוד 1 חלקי 2, אז מה אתם חושבים? ירוץ יעיל יותר.

9
00:02:49,500 --> 00:03:19,500
ירוץ מהר יותר, מה אתם חושבים ייקח פחות משאבים להריץ? ובכן, אנחנו נחזור לזה. בינתיים, נדבר על הסוג הראשון של סיבוכיות שיעסיק אותנו, סיבוכיות זמן. אנחנו בעצם נרצה לקבל מדד כלשהו, לכמה יעיל האלגוריתם או כמה יעיל התוכנה שאנחנו נריץ, מבחינת זמן ריצה. כמה זמן ייקח לזה מחוק ראשון או להתיישב בו עוד מאות שעושר תמים לפני שאל מסתכלים אצלנו. הזמן ריצה רצה להיות נוסף בטבעות וצ רוצה להגיד שהכל מה שאנחנו עושים להיות שיופיע רק בשל כך לפי לפי הש

10
00:03:19,500 --> 00:03:49,500
לרוץ. כמה פעולות זה ייקח. העניין הוא שאנחנו לא באמת עכשיו הולכים לספור ממש על השעון, כמה שניות לוקח להריץ קוד כלשהו על מחשב מסוים. הרי אתם מבינים שהדבר הזה תלוי במחשב, תלוי במהירות שלו, תלוי בשפת התכנות שבה מימשנו אפילו את הקוד שלנו. לא, אנחנו נרצה למדוד את הסיבוכיות בצורה יותר כללית וצורה שכבר לא...

11
00:03:49,500 --> 00:04:18,220
תלויה בחומרה שלנו אלא צורה יותר מתמטית יותר אבסטרקטית, אז סתם דוגמא בואו נסתכל פה על איזה שהיא באמת פונקציית הסכימה הזאת, תגידו לי אתם כשאנחנו מסתכלים על הפונקציה הזאת, ואנחנו רוצים לחשוב כמה כמה פעולות תתעריץ כמה פקודות תירוצו עבור קלטים שונים נניח עבור n שווה 10 כמה פעמים.

12
00:04:18,220 --> 00:04:47,120
כמה פקודות ירוצו, כמה פעולות יפעלו, יש לנו את הפקודה הראשונה סם שווה 0, נגיד זה פקודה אחת, יש לנו פה לולאת 4 שתרוץ פעם אחת איטרציה אחת לכל מספר בין 1 עד ל-n עצמו, אז נניח שאנחנו סופרים עבור n שווה 10, אוקיי, אז זאת אומרת יש לנו כאן 10 פעמים כפול,

13
00:04:47,820 --> 00:05:17,100
פקודה יחידה, אז יש לנו פה סם שווה לסם ועוד i, ואז בסוף יש לנו עוד פקודה כאן שקוראים לה, פשוט מחזירה את הסם הסופי, אז כאילו יש לנו פה פקודה קבועה אחת בהתחלה, פקודה קבועה בסוף, ופה יש לנו, מה, נקרא לזה פקודה אחת, אולי נחשב פה בעצם שתי פקודות, נחשב פה סם פלוס i בתור פקודה חישובית,

14
00:05:18,000 --> 00:05:23,020
אז נעשה סמ שווה הסמפלוס איי הזה, זאת אומרת, בעצם יש פה שתי פקודות בפנים.

15
00:05:23,720 --> 00:05:33,660
אתם מבינים, יש כאן, יש כאן קשיים מסוימים, אבל הרעיון הכללי, זה בעצם הרעיון שאנחנו נרצה לעבוד לפיו.

16
00:05:34,080 --> 00:05:41,800
אנחנו נרצה בעצם לחשב את הסיבוכיות שלנו, את כמה פעולות תהיו לנו, בתלות בכלת.

17
00:05:42,200 --> 00:05:49,640
אתם מבינים שהכלת כאן, אורך הכלת, לא אורך, סליחה, פה ספציפית זה גודל הכלת, אבל אנחנו גם נדבר על זה.

18
00:05:50,340 --> 00:06:08,760
אז אתה רואה שכאן, זה מה שמכריע את רוב הסיבוכיות של התוכנה הזאת. אבל אנחנו נדבר על זה בצורה קצת יותר מדויקת, או אולי דווקא בצורה פחות מדויקת, עוד מעט, ואז אתם תראו שבעצם כן נוכל לחשב את הסיבוכיות של הקוד הזה.

19
00:06:10,300 --> 00:06:20,500
אז כדי שבכלל נוכל להבין משהו פה ולעבוד עם זה, אנחנו צריכים לדבר על כמה עקרונות מאוד מאוד בסיסיים בענייני סיבוכיות.

20
00:06:21,280 --> 00:06:25,900
אז באמת נתחיל מהעקרון הראשון, משהו שהזכרתי בדיוק מקודם.

21
00:06:25,900 --> 00:06:55,900
סיבוכיות לדוגמה סיבוכיות זמן של תוכנית היא תלויה בגודל הקלט שהיא מקבלת. זאת אומרת, בn הזה ממש גודל הקלט כמה גדול הקלט הזה. למעשה אתם יכולים להגיד שהסיבוכיות זמן של תוכנית או של אלגוריתם היא פונקציה של גודל הקלט שהיא מקבלת.זאת אומרת סיבוכיות הזמן של הקוד שאתם ראיתם כאן אפשר לחשב אותו בתור פונקציה על n. תחשבו

22
00:06:55,900 --> 00:07:25,880
ממש תחשבו F על N, ממש כזה דבר. אז באמת, כמו שאמרנו Mcודם, כמה פעולות היו כאן, האם היינו רוצים לכתוב בתור פונקציה כמה פעולות יש כאן, אז יכולנו לכתוב, לא יודע, נניח F של N שווה ל, בואו נראה, יש את הפקודה הקבועה הזאת פה, אז נניח 1, ועוד. פה בפנים בתוך חלולה יש לנו.

23
00:07:25,880 --> 00:07:55,880
אם פה n איטרציות אז אני יכול לכתוב n כפול ואז בפנים א.נלך יטרים רחוק שתי פקודות: פקודה אחת לחשב את סם פלוס ,י, ואז פקודה שנייה לעשות הסמה בזיכרון. אז אני אעשה n כפול 2 ולמטה עוד פקודה אחת קבועה זאת אומרת יש לי פה 2 כפול n ועוד 2, נכון? זה נראה ככה אז תחשבו על זה מה שאתם רואים כאן זה בעצם

24
00:07:55,880 --> 00:08:21,780
בעצם נקרא לזה פונקציה ציבוכיות הזמן של הקוד הזה ובמה היא תלויה? בגודל כלת, ב-n. אז מה שכן, לפעמים הכלת יכול לשנות בצורה דרסטית את כמה זמן ריצה קוד צריך בשביל לעבוד, הרי תראו דוגמה לדוגמה.

25
00:08:21,780 --> 00:08:51,720
יש לנו פה קוד קצר, קוד שמקבל איזשהו מערך, רשימה ואיזשהו טארגט. וכל מה שהקוד הזה עושה, הוא בודק, אם טארגט נמצא איפשהו ברשימה, אז נחזיר true. ואם לאורך כל הרשימה הזאת לא מצאנו את זה, אז נחזיר false. מה הבעיה? יש לנו פה שתי דוגמאות קיצוניות. דוגמה ראשונה אומרת, הנה רשימה של כל המספרים.

26
00:08:51,720 --> 00:09:18,860
מ,-1 עד -N. והטרגט שלנו יהיה המספר הראשון. אז מן הסתם שאם אנחנו נריץ את הפונקציה contain target הזאת עם הקלט הזה, מה נגלה? נריץ את האיתרציה הראשונה של עולולה, four item in R, האיתם הראשון שלנו יהיה האחד הזה, והאיתם הוא כן שווה שווה לטרגט, כי טרגט הוא גם אחד, ונחזיר true באיתרציה הראשונה.

27
00:09:18,860 --> 00:09:48,860
אז זו דוגמה best case scenario, שבו הקוד ייקח לו זמן מאוד קצר לרוץ. מצד שני יש לנו worst case scenrio, שבו אנחנו נריץ את האלגוריתם, נריץ את הקוד עד הסוף, ולא נקבל שום קיצור דרך, שום ריטרן טרוק הזה, שיקרה לפני שכל האיטרציות ירוצו. אז במקרה הזה, אם הטרגט שנחפש בכלל,

28
00:09:48,860 --> 00:09:59,660
לא קיים ברשימה אז אנחנו נריץ בלולאת אפור הזאת לאורך כל אורך הרשימה ועדיין לא נצליח וניאלץ להחזיר פולס.

29
00:09:59,660 --> 00:10:09,640
אז אם יש לנו best case scenario, יש לנו worst case scenario ואתם רואים שההבדל ביניהם קיצוני הרי בבסט קייס סנריו.

30
00:10:09,640 --> 00:10:22,840
היה לנו בסך הכל מה 2 3 פקודות בסך הכל שרצו מנגע יש לנו את ה-worst-case סנאריו ולא לקח לפחות אין פקודות אז זה הבדל משמעותי.

31
00:10:22,840 --> 00:10:30,700
איך את מה נקבע מה נקבע שייה מדד שלנו לגבי סיבוכיות הזמן של אלגוריתם או של קוד.

32
00:10:30,700 --> 00:10:37,120
אז מה שאנחנו נבחר לעשות תמיד מבחינת חישוב הסיבוכיות?

33
00:10:37,120 --> 00:11:06,300
הוא במקרה הגרוע ביותר. כלומר לכל אלגוריתם ולכל תוכנת קוד שאנחנו נכתוב כדי לחשב סיבוכיות אנחנו תמיד נניח שהכלת שאנחנו עובדים איתו הוא המקרה הגרוע ביותר. זה שייקח לנו את הכי הרבה פקודות להריץ כדי להגיע לסוף התוכנית. על ידי זה אנחנו באמת נוכל לתת מדד שהוא מה שנקרא.

34
00:11:06,300 --> 00:11:36,180
מדד שבו אנחנו לא מוותרים לעצמנו כשאנחנו בודקים את היעילות של מה שאנחנו מחשבים את מה שאנחנו בונים. זאת תהיה הדרך הנכונה. עכשיו כמובן שבעולם האמיתי יש גם את המדידת סיבוכיות לפי הדרך הגרועה לפי הקלט הגרוע ביותר, ויש גם מדידת סיבוכיות לפי המקרה הממוצע. ומן הסתם שבעולם האמיתי המקרה הממוצע כן מנחה את העבודה.

35
00:11:36,180 --> 00:12:06,100
שהיה לנו בהרבה מקרים. אבל כשאנחנו רק לומדים על הקונספט של סיבוכיות זה עיקרון. אנחנו נתייחס לסיבוכיות של קוד של אלגוריתם על פי הקלט שיביא אותנו לסיבוכיות הכי גדולה. הוא עשתה סצנריו. אז אני רוצה לחזור שוב למשהו שאמרתי לכם מקודם. עכשיו בתור עיקרון שלישי. אתם מבינים כשאני כל הזמן אומר קוד.

36
00:12:06,100 --> 00:12:36,100
וכל הזמן אני אומר אלגוריתם ואני אומר אותם בצורה שהיא אינטרצ'יינג'יבל, אני מנסה בעצם להגיד לכם, שאנחנו לא מחשבים פה סיבוכיות, ספציפית, לפי איך שהקוד הזה ירוץ בפייתון, או בשפת C, או באיזי שהיא שפת תכנות אחרת, או באיזשהי מימוש מסוים. מה שאנחנו באמת מדברים עליו וזו אגב, דוגמא או יותר נכון הסיבה ללמה בתרגול הזה אני לא הולך להריץ לכם אפילו שורת קוד,

37
00:12:36,100 --> 00:12:37,960
קוד אחת בפייתון בריל טיימפ,

38
00:12:38,640 --> 00:12:39,680
כי זה לא מטרה של התרגול.

39
00:12:40,900 --> 00:12:45,260
אנחנו בעצם מדברים כאן על סיבוכיות של אלגוריתמים,

40
00:12:45,800 --> 00:13:05,960
זאת אומרת, של תבניות, של הוראות, ממש של... תחשבו על זה, הגרסה של על הנייר, שמה שאנחנו כותבים, ההוראות שאנחנו רוצים למלא כדי להגיע למטרה, לא שירות הקוד הפרקטיות שירוצו על המחשב.

41
00:13:05,960 --> 00:13:20,000
אז העקרון השלישי שלנו אומר, שאנחנו מחשבים פה פעולות לפי אלגוריתם, לפי פשוט אבסטרקציה של הפעולה שאנחנו עושים.

42
00:13:20,000 --> 00:13:34,920
אז פה, אם אנחנו חישבנו מקודם, כמו שאתם זוכרים, שתי n ועוד שתי פעולות בסך הכל, זה כי אני התייחסתי פה לפקודות בתור דברים נפרדים. התייחסתי לסם שווה 0 בתור פקודה אחת.

43
00:13:34,920 --> 00:14:04,840
להחזיר סם, פקודה אחת, זה השתיים. אנחנו יודעים שלולת four תרוץ פה בדיוק, n איטרציות, זה החלק הקל, אז n כפול, ובפנים, אמרנו, החישוב, סם פלוס i, נקרא לזה פקודה כלשהי. ואז, ההסמה, סם שווה לסם פלוס i, נקרא לזה פקודה אחרת. אוקיי, אבל תראו, אפשר...

44
00:14:04,840 --> 00:14:34,240
אפשר ליפול לפח מאוד מאוד פשוט וקל כאן. אפשר להתעכב על רגע, האם הפלוס שווה זה פקודה אחת, האם זה פקודה, שתי פקודות. אבל אתם מבינים שאנחנו מתווכחים פה על מספר קבוע, נכון? כאילו, מיותר. מקסימום יכולנו להגיד, לא יודע, זה פקודה אחת, ואז במקום שני n ועוד שתיים, זה n ועוד שתיים. אבל עדיין, מה שינינו בעצם? שינינו פה קבוע כפול אותו n.

45
00:14:34,240 --> 00:14:59,520
וזה מביא אותנו, ואנחנו ממש מתקרבים עכשיו, להגדרה של איך באמת נחשב את הסיבוכיות הזאת. כי אתם מבינים, לא יהיה עניין אותנו באמת, אם אנחנו מסתכלים על פונקציה בסיבוכיות זמן של 2 n ועוד 2, או 3 n ועוד 1, זה לא משהו חשוב.

46
00:14:59,520 --> 00:15:29,440
מה שחשוב לנו, זה בעצם התמונה הגדולה יותר, הקצב גדילה האסימפטוטי של הפונקציה. זאת אומרת, נשים בצד לרגע את הקבוע כפול, ה-n הזה, ופשוט נתייחס ל-n עצמו, לפונקציה סביב ה-n. האם זה n בחזקת משהו? האם זה לוג של n? האם זה שורש n? זה מה שיעניין אותנו, התמונה הגדולה, לא הפרטים הקטנים של ה- כמה כפול.

47
00:15:29,440 --> 00:15:59,380
כפול n. אז באמת, אתם רואים כאן דוגמאות שונות. נניח, יש לנו פונקציה, שסיבוכיות שלה היא בערך 2 וחצי כפול n ועוד 2. מבחינתנו, זה סיבוכיות שאנחנו נקרא לה, או גדול של n, או בדרך כלל אנחנו אפילו לא נגיד את המילה גדול, פשוט נגיד או של n. כלומר, נגיד שזאת פונקציה, שיש לה סיבוכיות, לינארית.

48
00:15:59,380 --> 00:16:29,380
בn זאת אומרת איזשהו משהו כפול n ועוד איזשהו קבוע זה זמן הריצה שלה או פונקציה אחרת שאנחנו מחשבים ואנחנו רואים וואלה עבור n כלשהו הסיבוכיות של הפונקציה הזאת הוא בערך log של n ועוד שתיים אז מבחינתנו הסיבוכיות של הפונקציה הזאת היא ב-o של n, סליחה, o של log n אל תתבייבו, o של log n, כן?

49
00:16:29,380 --> 00:16:59,380
זה מה שמוביל אותנו לקבוע את הסיבוכיות, או פונקציה שפשוט רצה מהפקודות תמיד בלי קשר ליהן. זה הכי פשוט. כי הפונקציה כזאת, אנחנו נגיד, יש לה סיבוכיות של קבוע, מה שנקרא O של 1. למה 1? כי עוד פעם קחו קבוע, תכפלו אותו ב-1 הזה, תעשו פלוס קבוע איפשהו. זה עדיין אותו רעיון.

50
00:16:59,960 --> 00:17:09,660
או תראו כאן בכלל תרחיש שבו פונקציה של סיבוכיות של 4 n בריבוע ועוד 4 n ועוד 1. בקיצור אני חושב שאתם כבר מבינים החזקה הכי גדולה.

51
00:17:09,660 --> 00:17:28,280
היא תהיה מה שמוביל אותנו היא מה שתגיד לנו בעצם. או של איזה סוג פונקציה זה פה או של n בריבוע וכאן בכלל. יש לנו פה פונקציה.  שהזמנ ריצה של זה כאילו. 2 בחזקת n ועוד 1.

52
00:17:28,820 --> 00:17:58,820
ואז יש לנו ועוד שני n ועוד 1 אז אנחנו נגיד שזה ב-o של 2 בחזקת n. למה לא או ב-o של 2 בחזקת n ועוד 1? כי מה זה 2 בחזקת n ועוד 1 זה פשוט 2 כפול 2 בחזקת n. מה שבאמת מעניין אותנו זה פשוט סוג הפונקציה ב-n. ממש הסדר גודל או פה בכלל, תראו כאן פונקציה מאוד מאוד ארוכה ומתוסבכת ארוכה ומתוסבכת אבל

53
00:17:58,820 --> 00:18:11,620
מה העיקר? החלק הזה, ה-n כפול לוג-n, זה הסדר גודל בתכלס של הסימוכיות פונקציה שאנחנו מקלמים בדוגמה הזאת.

54
00:18:11,720 --> 00:18:20,520
אז אני מקווה שאתם מקבלים פה תחושות, ולמעשה, עכשיו אנחנו נוכל ממש להגדיר את הרעיון הזה של קצב הגדילה סימטוטי.

55
00:18:20,620 --> 00:18:28,720
אז יש לנו כאן הגדרה שהיא דומה למה שראיתם בהרצאה, אני אנסה לגרום לזה ליראות יותר אינטואיטיבי. אז תראו.

56
00:18:28,720 --> 00:18:58,620
נניח שיש לכם את הפונקציה f של n, זאת הפונקציה שאתם מחשבים, פונקציה שתלויה ב-n, וואלה, הפונקציה הזאת תגיד לנו בערך את סימוכיות הזמן של האלגוריתם הזה, במקרה הגרוע, כמובן, כן. נניח כלת הכי גרוע, ואנחנו מחשבים לכל אורך הכלת, או כמה שצריך. בקיצור, זמן הריצה, בלי שקרים לבנים, של הפונקציה, של האלגוריתם, של מה שזה לא יהיה.

57
00:18:58,620 --> 00:19:28,620
束 כל-פנים מפגש ישורד כנlab חשדות משלוש מינוס פינופן בין גמל הזדרתה אל תשוקו ולהשווק בהתפתחים של חרב, האיבור והפוכניות שלנו, ולבודל אותנו כמוכרפנים, גם מיני עובדים.

58
00:19:28,620 --> 00:19:58,160
כן פונקציות חיוביות עולות רק פשוטות כאלה. אז תראו מה אנחנו יכולים להגיד, אנחנו נגיד f היא o, פה ספציפית o גדול של g או g של n, או אפילו נכתוב f של n שווה o של g של n או בסוגריים f של n שייכת ל-o של g של n, אבל פה זה כבר עניין של קבוצות, דברים שאתם לא מבינים בדיסקרטית, לא משנה.

59
00:19:58,160 --> 00:20:11,360
בכל מקרה אנחנו נוכל להגיד כזה דבר, f היא o של g ועכשיו הנה הגדרה מתמטית, הנה הקטע שבו אנחנו אומרים מכאן והלאה אנחנו יכולים לתת הכללות.

60
00:20:11,360 --> 00:20:27,960
נניח שאנחנו נגדיר איזשהו מספר טבעי כלשהו, n0, נגדיר איזשהו קבוע, קבוע ממש חיובי, זה לא מ0, c. אז מה בעצם, מה אנחנו בעצם מנסים להגיד? שלכל קלט, באורך...

61
00:20:27,960 --> 00:20:50,380
לאורך n שהוא כבר גדול יותר מ-n0, אם מתקיים ש-f של n קטנה שווה מאותו קבוע c כפול הפונקציה השוואתית שלנו, g של n, אז בעצם אנחנו נוכל להגיד ש-f היא o של g של n.

62
00:20:51,500 --> 00:21:21,420
זאת אומרת, תחשבו על זה, נניח יש לנו באמת את הפונקציה f של n, נגיד שהפונקציה הזאת שלנו היא 2n ועוד 2, בסדר? אז מה? נגיד ש-g של n שלנו היא פשוט n, בסדר? g של n עצמה היא n, הפונקציה g של n שווה ל-n, אז מה? אנחנו יכולים להגיד ש... לא יודע, קחו n f.

63
00:21:21,420 --> 00:21:46,560
כלשהו, לא יודע, חמש, אם משהו, יאללה, ניקח n0 שווה 5, הנה, אני ממש אכתוב לכם את זה בנוטפט, שתראו למה, למה הכוונה פה, נניח n0 שווה 5, סתם שיהיה, אז g של n שלנו שווה ל n, f של n שווה לשני n ועוד שתיים, ועכשיו אתם תראו לאן אנחנו חותרים, אז מה קורה?

64
00:21:46,560 --> 00:22:10,240
אנחנו יכולים להגיד ששני n ועוד שתיים, קטן שווה ל, אז פה אנחנו צריכים איזשהו c ממש משמעותי. בואו ניקח, לא יודע, c שווה 10. למה לא? בואו נראה. 10n, מה אתם אומרים?

65
00:22:10,240 --> 00:22:20,840
אז עבור, לא יודע, n0 פמת שווה 5, אז כאילו יש לנו 2 כפול 5 ועוד 2.

66
00:22:22,280 --> 00:22:30,300
האם זה קטן שווה ל-10 כפול 5? לא יודע מה אתכם, אני חושב שכן.

67
00:22:30,840 --> 00:22:40,220
בקיצור, מה אני מנסה להגיד לכם? אני מנסה להגיד לכם שכל הרעיון של הדרך להגדיר כאן את הקצב גדילה סימטוטי, זה בעצם להגיד לכם...

68
00:22:40,220 --> 00:22:52,360
תראו, בסופו של דבר, אתם יכולים להגיד שהפונקציית סיבוכיות זמן שלכם היא נמצאת בקבוצת ה-O של מה שזה לא יהיה שיש שם בפנים.

69
00:22:53,000 --> 00:23:06,100
זאת אומרת, כשאתם הגעתם, אתם יכולים להגיד שה-F שלן, F שלן היא בעצם כן, היא נמצאת בקבוצה הזאת של הפונקציות, שזה כאילו הבסיס שלהן.

70
00:23:06,100 --> 00:23:35,660
זאת אומרת, אם הפונקציה שלכם זה סיבוכיות זמן של שתי N ועוד שתיים, אתם מבינים שאתם בקבוצת הפונקציות שהסיבוכיות שלנו היא קבוע כפול ה-G של N עצמה, הקבוע הזה יכול להיות קבוע גדול מספיק לבחירתכם, ואתם אפילו יכולים להגיד, לא חייב להיות עבור כל קלט N, יכול להיות.

71
00:23:35,820 --> 00:24:05,440
מספיק עבור כלט N מסוים, גדול מספיק והלאה. זאת אומרת, שמגודל כלט מסוים ויותר גדול, ועבור קבוע C, גדול מספיק לבחירתכם, אתם כבר מבינים שמשם והלאה, הפונקציית ימשיכו לגדול לאן שהן יגדלו, לכיוון האינסוף, ואתם מבינים שאתם בערך באותו מה שנקרא בול פארק אסימפטוטי, בערך באותו תחום אסימפטוטי.

72
00:24:05,440 --> 00:24:26,860
אז זה למה פה, אם הפונקציה של ה-2N ועוד 2 שלנו, אנחנו מבינים שבתכלס, מנקודה מסוימת והלאה, זה הולך להיות בערך באותו תחום של כל הפונקציות שהן קבוע כפול N, כן? ברמה ממש של פלוס מינוס קבוע, כן? קבוע כפול פלוס מינוס קבוע.

73
00:24:26,860 --> 00:24:39,620
דרך אגב, זה גם בסדר גמור להגיד את זה עבור חזקות אחרות. נניח יש לכם פונקציה בסיבוכיות זמן של 2 כפול n בריבוע? אז אוקיי.

74
00:24:39,620 --> 00:24:56,400
אתם רואים שזה די מסביר את עצמו, כן? עבור פונקציות שמבוססות סביב n בריבוע, כלומר קבוצת ה-o של n בריבוע, קחו קבוע c2 כפול n בריבוע, תגידו לכל n0, כן? לכל n טבעי.

75
00:24:56,400 --> 00:25:26,140
או אפילו יותר טוב מזה, o גדול זה סוג של חסם עליון על הקבוצת פונקציות שלנו לחישוב סיבוכיות. הרי אתם רואים למה, כן? בגלל הקטן שווה הזה. אז שום דבר לא מונע מאיתנו להגדיר g של n שתהיה יותר גדולה סימפטוטית מאותה f של n. זה למה חופשי, אפשר לכתוב פה o של n בשלישית.

76
00:25:26,140 --> 00:25:56,040
ולהגיד שפונקציה בסיבוכיות זמן ריצה, 2n בריבוע, לחלוטין שייכת ל-o של n בשלישית. כי פונקציות בסיבוכיות זמן כזאת, כן? לוקח להן לכל הפחות, מינימום, לפחות או יותר זמן ריצה מאותה f של n. אז בעצם כשאנחנו מדברים על o גדול, כשאנחנו מדברים על קצב גדילה סימפטוטי, על הטרמינולוגיות.

77
00:25:56,040 --> 00:26:26,040
ציבוכיות הזאת או גדול, אנחנו בעצם מנסים להגיד זה חסם עליון לזמן ריצה של הפונקציה שאנחנו מדברים עליה. שהפונקציה שאנחנו מדברים עליה דרך אגב היא בעצמה ציבוכיות הזמן של האלגוריתמים שאנחנו מתעסקים איתו. אז זה הכוונה שלנו-א�חנו אומרים עבור קבוע גדול מספיק החל מקלט באורך N0 או יותר מבחינתנו. א-אנחנו נמצאים באזרק, א-אינסופה בגלל הסמוך של הגרסציה שמגרסציה, בגלל (לבכות אשראי,יבודא עובד בחינא ושחסום) לשמרא אכשר להתקשם במציאות, מא�

78
00:26:26,040 --> 00:26:56,040
באותו תחום קצב גדילה סימטוטי. ואין, אני רוצה אף טיפה לדלג לכם קדימה. אני רוצה להראות לכם רק לרגע את השקופית הזאת כאן של קצבי הגדילה סימטוטיים. פה אולי אתם יכולים לראות על גרף משהו שקצת מסביר את מה שניסיתי להכווין עליו מקודם. אתם רואים כאן, יש לכם פה גרף שציר ה-X זה פשוט גודל הקלט N וציר ה-Y זה באמת

79
00:26:56,040 --> 00:27:26,040
כמה חישובים צריך ממש כמה סיבוכיות זמן פה אנחנו נדבר על זמן וזמן ריצה אז אתם רואים שיש לכם קו שהוא לא משתנה זה ה-O של אחד שלנו זה בעצם כל הפונקציות שהן ערך קבוע לכל כלת אז הדבר הכי אינטואיטיבי הבא בתור זה פשוט קצף גדילה ליניארי זאת אומרת יש לכם לכל n אתם אומרים קבוע כפול n וזה...

80
00:27:26,040 --> 00:27:47,020
ועוד קבוע, אז תבינים שזה הולך להיות קו ישר, ככל שהקלט שלכם יגדל ככה גם מספר החישובים שלכם יגדל בצורה לינארית. אתם גם מכירים את החלק החיובי של פרבולה, נכון? של n בריבוע, לכל הגדלת קלט n אתם מגדילים בריבוע את מספר חישובים שלכם.

81
00:27:47,020 --> 00:28:17,000
אז העניין הוא שיש לכם כל מיני סוגים של פונקציות שאנחנו בעצם מתעסקים איתן ומחשבים סיבוכיות בעזרתן. יש לנו לדוגמה פונקציה לוג של n, שאנחנו בהמשך התרגול אנחנו נראה דוגמאות לקודים שירוצו בעצם בלוג של n. אתם תראו מה הכוונה, זה לוגריתם. אני מקווה שאתם מסתדרים עם הרעיון של לוגריתם.

82
00:28:17,000 --> 00:28:46,880
אם אתם צריכים לעקוב אחרי זה, זה כאילו ההפך מחזקה. אנחנו נראה דוגמאות לזה. יש לכם גם את הרעיון של n כפול log של n, זה גם משהו שאתם תראו יותר מאוחר. אז אמרנו יש n בריבוע, n בשלישית, n וכולי וכולי, יש אפילו יותר גרוע, יש 2 בחזקת n, שזה בכלל גדילה סמטות יותר גדולה, או אפילו עוד יותר גרוע, n בחזקת n.

83
00:28:46,880 --> 00:29:05,860
n כמו n עצרת, n כפול מינוס 1 כפול מינוס 2 וכולי, בקיצור אתם מקבלים פה סדרי גודל, תראו כמה משפיע הגדילה של n לעומת כמה פעולות אנחנו נצטרך להריץ.

84
00:29:05,860 --> 00:29:16,440
בסדר עכשיו שקפצתי קדימה והדיברנו קצת על הרעיון הזה של קצף גדילה סימתוטי פה ספציפית בהקשר של זמן.

85
00:29:16,440 --> 00:29:46,180
ואל תדאגו אם כל זה נראה לכם מסובך עכשיו אם כל זה נראה לכם קצת מה זה פה מה זה כל הגדרה המתאימתית הזאת מה מה הולך פה. אל תדאגו אתם תבינו את הרעיון כל מה שאתם צריכים להבין. זה שהגדרה הזאת היא נותנת לכם את המרווח נשימה להגיד עבור כלת n גדול מספיק עבור קבוע גדול מספיק וואלה הפונקציה g של n שלנו שזה יכול להיות.

86
00:29:46,180 --> 00:30:16,180
N בריבוע, M השלישית, מה שזה לא יהיה, היא חסם, חסם עליון, היא בערך תיתן לנו חסם עליון לסדר גודל של כמה סיבוכיות יש לפונקציה הזאת, אוקיי? זה בערך הרעיון. אז אני רוצה להישאר אתכם פה ולהגיד לכם, חוץ מסיבוכיות של זמן, יש לנו גם עיסוקים, נכון? יש לנו גם עיסוקים בסיבוכיות מקום, אז מה הכוונה בסיבוכיות מקום?

87
00:30:16,180 --> 00:30:46,180
אז תראו בסופו של דבר אנחנו כן כותבים אלגוריתמים, כותבים תוכנות וכולי, דברים שצריכים גם זיכרון, איחסון. אנחנו צריכים לאחסן מידע תוך כדי העבודה שלנו. אז אנחנו בעצם נדבר על סיבוכיית מקום בתור הסיבוכיות מסוג שני שאנחנו גם צריכים לחשב. אז, תראו, אנחנו לא באמת, כמו שדיברנו איתכם בסיבוכיות אה... סיבוכיות של זמן, גם פה, אנחנו לא באמת נדבר איתכם

88
00:30:46,180 --> 00:31:16,180
איך מדברים על כמה ביטים ספציפיים, המימוש הספציפי של האלגוריתם, על המחשב הספציפי שאנחנו משתמשים בו, כמה ביטים אנחנו נצטרך. לא, אנחנו מדברים איתכם משהו שהוא יותר אבסטרקטי, יותר כללי, אנחנו נדבר איתכם על יותר כמו תאי זיכרון, יחידות מידע, אם זה עוזר לכם. גם פה זה יהיה תלוי בn. אז, לדוגמה, אתם רואים כאן פונקציה, שהיא מקבלת את n ככלת,

89
00:31:16,180 --> 00:31:46,180
ואנחנו סוכמים פה את כל המספרים, מ-1 עד n, כמו שאתם ראיתם, אז אם אני שואל אתכם, מה הסיבוכיות, המקום של כזה קוד, כזה אלגוריתם? אז כאילו, אנחנו מסתכלים על זה, אז יש לנו פה את המשתנה sum, אוקיי, נקרא לך יחידת זיכרון אחת, יש לנו פה את המשתנה i, שאנחנו פשוט משנים לו את הערך לכל איטרציה. אוקיי, אז-

90
00:31:46,180 --> 00:31:47,880
אוקיי, יחידת זיכרון אחת.

91
00:31:48,580 --> 00:32:05,060
ריינג' - אתם יודעים שריינג' זה לא משהו ששמור בזיכרון כל הזמן, אלא אנחנו בסך הכל עושים פה איטרציה על מספרים. אחד, אחר כך שתיים, אחר כך שלוש..לא שומעים את הכל ביחד. אז גם זה, מקסימום נקרא לך יחידת זיכרון אחת.

92
00:32:05,960 --> 00:32:15,840
החישוב - sum פלוס I... יאללה, גם לך ניתן יחידה זיכרון אחת, ואפילו.. לא יודע.. משתנה זמני..

93
00:32:15,840 --> 00:32:45,400
return value בשביל sum. בקיצור, אתם מבינים שפה אנחנו כנראה מדברים על סיבוכיות זיכרון ב-O של אחד, בסדר? פה קבוע. אז גם פה בסיבוכיות מקום, יש לנו את העקרונות האלה שמאוד מאוד דומים לעקרונות שדיברנו עליהן בסיבוכיות זמן, ופה אותם קונספטים. העקרון הראשון שלנו זה שהסיבוכיות מקום שאנחנו מדברים עליו הוא יהיה...

94
00:32:45,400 --> 00:33:15,360
בעצם החישוב הזה של סיבוכיות מקום הוא בעצם יהיה פונקציה שהיא תלויה בגודל הקלט שהאלגוריתם הזה הולך לקבל. אותו דבר כמו בסיבוכיות זמן ריצה. אז לדוגמה, אם יש לכם פה קוד קצר, create array, אנחנו מקבלים כקלט n, ואז פה מה אנחנו עושים? אנחנו בונים רשימה, ופה תראו מה אנחנו עושים, כמה איברים ברשימה.

95
00:33:15,360 --> 00:33:44,920
בעצם אנחנו פותחים פה ריינג' מ-0 עד n-1, כלומר ריינג' של n איברים, ואנחנו אומרים לכל מספר בריינג' הזה בין 0 ל-n-1, נדחוף אותו בתור איבר לרשימה. במילים אחרות, אנחנו עכשיו צריכים פה סיבוכיות זיכרון n, ממש אפשר להגיד o של n, סיבוכיות זיכרון כאן, זה בדיוק מה שיש לנו כאן.

96
00:33:44,920 --> 00:33:58,040
בסדר? אתם רואים למה אנחנו בונים בזיכרון רשימה, זה ממש העבודה של האלגוריתם הזה, בונים בזיכרון רשימה באורך n.

97
00:33:58,040 --> 00:34:08,400
אוקיי, ועכשיו עיקרון השני, best case scenario, worst case scenario, זה עובד גם בסיבוכיות מקום.

98
00:34:08,400 --> 00:34:38,000
סיבוכיות מקום? לדוגמה, יש לנו פונקציה שטוטית כזאת, שמה היא עושה? היא בונה רשימה שתהיה מורכבת מהערכים החיוביים ברשימה שאנחנו מקבלים ככלת. מה זאת אומרת? תראו, הנה list comprehension שכולל בפנים אפילו if, תראו את זה. אנחנו נחזיר רשימה, אוקיי?

99
00:34:38,860 --> 00:35:07,760
איך הרשימה מוגדרת? לכל מספר בתוך הרשימת כלת נשים מספר Kف עם אותו מספר גדול מ 0. זאת אומרת, אנחנו נעשה איטרציה לאורך כל רשימת הכלת ולכל מספר שאנחנו נעבור עליו, אם הערך שלו הוא חיובי, אז נשים אותו בתור איבר ברשימה שאנחנו הולכים להחזיר בתור הרשימת כלת.

100
00:35:07,760 --> 00:35:37,760
בתור ה-return value מהפונקציה הזאת, אז קודם כל איך נגדיר את הסיבוכיות מקום כאן? כי הרי תראו, אם נניח רשימת הכלת שלנו מוקבת רק ממספרים שליליים, אז אנחנו נחזיר רשימה ריקה. ואז מה הסיבוכיות מקום? או של 1 או של 0? מה, כמעט כלום, נכון? מי נגד? אם רשימת הכלת שלנו היא כולה,

101
00:35:37,760 --> 00:36:07,760
את תהיה מורכבת במספרים חיוביים, אז מן הסתם שאנחנו הולכים להחזיר רשימה באורך n, כלומר כל הרשימה שקיבלנו ככלת, אז מקום בזיכרון אין יחידות זיכרון, ושוב זה מחזיר אותנו לעיקרון השני שדיברנו עליו, עוד בסיבוכיות זמן, אנחנו מדברים על המקרה הגרוע ביותר, אנחנו מדברים על ה-worth case scenario, הוא אומר לנו את סיבוכיות המקום שאנחנו מתעסקים איתה פה, ולכן אתם רואים כאן

102
00:36:07,760 --> 00:36:37,760
דוגמה מאוד פשוטה מאוד קלאסית לסיבוכיות מקום ב-O של N. ולבסוף העיקרון השלישי זה בדיוק כמו שאמרנו מקודם אנחנו לא באמת תלויים במימוש של השפה ומה שזה לא יהיה אנחנו מדברים בצורה אבסטרקטית מתמטית כללית. אנחנו מדברים פה ברמה האלגוריתמית לא ברמה של קוד שרץ בזמן אמת. אז בואו נסתכל פה.

103
00:36:37,760 --> 00:37:07,760
על דוגמאות וננסה להבין מהם משהו, בואו נראה. יש לנו כאן פונקציה בשם reverse list, מקבלים רשימה בכלת, בונים רשימה - reverse list. אז מתחילים לבנות רשימה שהיא פשוט באורך הכלת, הכל אפסים. ועכשיו מה אנחנו אומרים, אנחנו עוברים על רשימת הכלת, פה אתם רואים שאנחנו אפילו משתמשים בפונקציית enumerate

104
00:37:07,760 --> 00:37:37,180
שמה שהיא עושה זה מעבר באמת איטרציה על פני רשימת הקלט לולאת for. for זה כאילו אייטם אין דה ליסט אבל מה? אנחנו גם אייטם וגם לוקחים אינטג'ר i בתור אינדקס. זאת אומרת האייטם הראשון בתוך האיטרציית אינומריישן הזאת אז באיטרציה הראשונה של ה-for יהיה לנו גם את האייטם הראשון בליסט ו-i יהיה שווה 0.

105
00:37:37,180 --> 00:38:07,160
אנחנו הרבה פעמים נשתמש בפייתון בן יומרייט כי הרבה פעמים אנחנו רוצים לעבוד ברשימות לא רק לעבור על האייטמים של הרשימה אנחנו גם רוצים שיהיה לנו גישה מהירה ונוחה לאינדקס של אותו משתנה ברשימה זה נוח. אז זה למה הרבה פעמים אנחנו לא סתם לכתוב for אייטם אין ליסט אלא הרבה פעמים אנחנו נכתוב for אינדקס פסיק אייטם אין ואז נשתמש בפונקציית.

106
00:38:07,160 --> 00:38:37,100
איניומירייט על הרשימה זה סתם פרט טריוויה כזה אם אתם לא ידעתם בקיצור לולאת for לאורך רשימת הקלט ומה אנחנו עושים אנחנו מגדירים בעצם את הרשימה שאנחנו עושים לרוורס אנחנו אומרים רוורס ליסט באיזה אינדקס? באורך הרשימה מינוס 1 כלומר החל מהסוף פחות i ואז שווה אייטם ככה בעצם.

107
00:38:37,100 --> 00:38:46,960
בעצם אנחנו דוחפים, בעצם כמו שאתם מבינים, אנחנו דוחפים את העברים בסדר ההפוך לרשימת הרוורס שלנו, ואז אותה אנחנו נחזיר.

108
00:38:48,100 --> 00:39:05,880
יש לנו גם מימוש אלטרנטיבי שפשוט אומר רוורס ליסט, אין בעיות. נחזיר סלייס בקפיצות של מינוס 1 של הרשימה המקורית, בכל מקרה. לא משנה המימוש הראשון ולא משנה המימוש השני.

109
00:39:05,880 --> 00:39:35,440
אנחנו עדיין תופסים בזיכרון, מגדירים בזיכרון רשימה חדשה, וברור לנו שהיא באורך שהוא אסימפטוטית אותו אורך כמו רשימת הקלט. אז מבחינתי, שתי הפונקציות האלו הן סיבוכיות מקום של או שלהן. לא ממש מעניין אותי המימוש, כי אתם רואים, יש פה שני מימושים שונים שעובדים טיפה שונה.

110
00:39:35,440 --> 00:39:42,120
ובסופו של דבר זה אותו אלגוריתם, לשמור לרשימה את אותם איברים בסדר הפוך.

111
00:39:43,280 --> 00:39:51,180
אז אתם מבינים את זה, נכון? שני המימושים הם עדיין משהו ליניארי, שימוש ליניארי תאי זיכרון.

112
00:39:51,760 --> 00:39:59,880
קבוע כפול ה-n ועוד קבוע שיהיה. בסופו של דבר, אנחנו עדיין מדברים על אותו רעיון של הגדרה.

113
00:39:59,880 --> 00:40:17,600
אז אם ראיתם את ההגדרה מקודם של קצב גדילה סמטות היא עבור זמן, אז אותה הגדרה בדיוק עבור מקום, ופעם נגיד שפונקציה f של n שלנו היא תייצג את סיבוכיות המקום של אלגוריתם שאנחנו מתעסקים איתו, שוב במקרה הגרוע.

114
00:40:17,600 --> 00:40:29,700
ושוב g של n תהיה פונקציית כנה מידע כלשהי. אז אותו דבר בדיוק. אנחנו אומרים f היא o של g של n, או אפילו נגיד שf של n.

115
00:40:29,700 --> 00:40:59,420
היא שווה לאו של g של n, או בסוגריים f של n שייכת לאו של g של n. אם עבור כלת באורך n שהוא גדול יותר מאיזשהו n0 טבעי כלשהו, ואם עבור קבוע c גדול יותר מירך מסוים, כן, חיובי, אנחנו פשוט נגיע למצב שבו, אנחנו מצליחים לחסום את פונקציית f של n שלנו, בc קבוע c.

116
00:40:59,420 --> 00:41:29,280
כפול g של n, מה שזה לא יהיה. ואז שוב אותן דוגמאות שאתם ראיתם מקודם, כי זה אותו חישוב מתמטי. בסדר? זה פשוט, אנחנו מצליחים לחסום מלמעלה את ה-f של n שלנו, בקבוע כפול פונקציה מסוג מסוים. n, n בריבוע, לוג n, n כפול לוג n, קבוע כפול זה. אתם מבינים? אנחנו בעצם בהגדרה הזאת, מאלימים את הפרטים הקטנים.

117
00:41:29,280 --> 00:41:58,580
המציקים האלה של פלוס מינוס קבוע, או הקבוע עצמו, שקופל בחזקה המובילה של n. אנחנו רק רוצים להגדיר קבוצות כלליות של פונקציות. בסדר? כי זה יותר נוח לעבוד עם זה. להגיד שפונקציה היא o של n בריבוע. אני לא צריך להתעסק עם, הפונקציה הזאת היא 2n בריבוע ועוד 5, עזבו אתכם. בסדר? גודל n בריבוע. טוב מספיק.

118
00:41:58,580 --> 00:42:28,580
בסדר, זאת אור היו, ופה הנה אשקופית שהגנבתי ממקודם, עכשיו היא מופיעה, במקום המתאים שלה, מאינו פה סדרי הגודל הסימפטוטיים. ויש כעל גדלים סוגי פונקציות שמאוד פופולריות שאנחנו נראה אותן שוב ושוב ואולי סוף סוף נראה עכשיו כמה דוגמת אמיתיות ואתם אולי תבינו קצת יותר טוב. אז בואו נראה דוגמה. דוגמה ראשונה.

119
00:42:28,580 --> 00:42:44,380
הנה פונקציה, אז שאלות שאנחנו יכולים לשאול, מה הפונקציה עושה? מה סיבוכיות הזמן שלה? מה סיבוכיות הזיכרון, מקום שלה? אז בואו נענה על זה אחד אחד. קודם כל מה הפונקציה הזאת עושה?

120
00:42:44,380 --> 00:43:14,180
define maximum list. אוקיי אז הפונקציה הזאת מקבלת כנראה רשימה, אז בואו נראה. מקסימום שווה העבר הראשון בליסט, ואז לכל אייטם בליסט, אם האייטם הזה גדול מהמקסימום שהגדרנו, אז מקסימום הוא האייטם הזה. וככה נסיים מעבר על כל הרשימה, ובסוף נחזיר את המקסימום. בקיצור, זאת פונקציה שמחזירה את העבר בגודל המקסימלי של הרשימה.

121
00:43:14,580 --> 00:43:44,580
זה מה שהיא עושה. אני יכול כבר עכשיו להגיד לכם שסיבוכיות המקום של הדבר הזה היא או של אחד. למה? תראו בעצמכם. הגדרנו משתנך בזיכרון מקסימום, אין בעיות. אתה תופס מקום אחד, ניגשנו לאיבר כלשהו בזיכרון ליסט. בסדר אבל אחרי זה לא צריך אותו יותר זה לא משנה. לקרוא בוא נגיד זה ככה לקרוא ערך.

122
00:43:44,580 --> 00:43:54,960
אם אנחנו לא שומרים שומרים יותר מערך אחד הזה במקום אחד בזיכרון, אנחנו לא צריכים יותר ממקום קבוע.

123
00:43:54,960 --> 00:44:07,220
אוקיי, יש לנו פה משתנה אייטם שכל פעם הוא הולך לקבל ערך אחר, אנחנו עושים איתרציה לרשימה, אז גם זה יתפוס מקום אחד בזיכרון, יחידה אחת.

124
00:44:07,220 --> 00:44:14,440
אוקיי, אנחנו עושים פה חישוב השוואתי, זה תופס מקום קבוע בזיכרון, התוצאה של זה.

125
00:44:14,920 --> 00:44:44,920
הסצמה, אין פה משהו מיוחד, פשוט אומרים מקסימום שווה לאייטם שכבר קראנו, זה קריאה מקומית.  וזהו. בקיצור סיבוכיות מקום פה היא o של 1. יש לנו פה מספר קבוע של משתנים, אנחנו עובדים איתם. בסדר, מה לגבי סיבוכיות. כל עכשיו דיברנו על סיבוכיות מקום כן? זה הסיבוכיות מקום, מה לגבי סיבוכיות הזמן? אוקיי, יש לנו פה פקודת הסצמה

126
00:44:44,920 --> 00:44:59,320
משהו קבוע, יש לנו פה איטרציית for לכל אייטם ברשימה, רשימה באורך n, אז n כפול, פקודת if זה משהו אחד,

127
00:44:59,320 --> 00:45:16,880
מקסימום שווה אייטם, זה גם משהו אחד, זאת אומרת יש לי פה n כפול, לא יודע, 2, 3 מקסימום, 2, ואז פה פקודה קבועה בסוף, בקיצור, סיבוכיות זמן o של n, זה לינארי.

128
00:45:16,880 --> 00:45:29,220
אני מאוד מאוד מקווה שעכשיו אתם לאט לאט מבינים איך זה עובר, אתם ראיתם כאילו ממש אינטואיטיבית, מבינים, מתי.

129
00:45:29,220 --> 00:45:59,120
משהו פשוט סיבוכיות קבועה, ומתי יש לנו כבר n כפול, או משהו n כפול. אבל בואו נמשיך לראות עוד דוגמאות. הנה דוגמא לפונקציה שמחשב את הסכום, אבל יש לנו כבר את הנוסחה לחשב סכום של כל המספרים בין 1 ל-n. אז אנחנו יודעים מה היא עושה, אנחנו מחשבים את כל הסכום של מספרים בין 1 ל-n, סיבוכיות זמן, לא יודע.

130
00:45:59,680 --> 00:46:28,300
פקודה אחת שעושה n כפול, פקודה אחת שעושה n ועוד 1, לא יודע, פקודה אחת שעושה את כל זה חלקי 2, בקיצור, o של 1. סיבוכיות מקום, גם o של 1, לא משנה מה הוא n, אנחנו עושים פשוט את החישובים האלה על n, ושומרים את זה בזיכרון, במה שזה לא יהיה. בקיצור, הכל o של 1 פה. עכשיו משהו אחד קטנצ'יק.

131
00:46:28,300 --> 00:46:58,240
כתבנו כאן כוכבית קטנה בסיבוכיות של הפונקציה הזאת, כי למרות שאנחנו אומרים שהפונקציה הזאת כאילו עושה פעולות שלא תלויות בגודל הכלת, עדיין מותר להיזכר לרגע שבחיים האמיתיים יש משמעות לגודל הכלת, כי בוא נגיד את זה ככה, מחשבים כן עושים אופטימיזציות לפי גודל של משתנים, ובמחשבים יש...

132
00:46:58,240 --> 00:47:28,240
את הקטעים האלה שעברו סוגי משתנים גדולים מספיק, פתאום אין אופטימיזציות וצריך לעשות עבודה הרבה יותר קשה וכולי, אבל אתם יודעים משהו? אתם לא צריכים לזכור את הפרט הקטן הזה, מבחינתכם כשאתם רואים כזה דבר בקלות אתם אמורים להגיד כל זה או של אחד גם זמן גם מקום, כי זה פקודה אחת, גג ( updates )

133
00:47:28,240 --> 00:47:31,880
השתיים שהן חישוביות, בלי לולאות, בלי כלום.

134
00:47:33,680 --> 00:47:37,220
אוקיי, בואו נסתכל על דוגמא הבאה בתור, כמה קשה היא כבר יכולה להיות.

135
00:47:38,460 --> 00:47:43,220
יש לנו פה פונקציה, שאם נאמין למה שכתוב לנו, היא מקבלת מטריצה.

136
00:47:44,140 --> 00:47:56,820
אוקיי, אנחנו יוצרים רשימה בשם טרינגל, משתנה n שווה אורך המטריצה, בסדר? אורך הכלת, n, משתנה.

137
00:47:57,420 --> 00:48:25,900
עכשיו, אנחנו עושים איטרציה לכל i בריינג' של n. אוקיי, זאת אומרת, יש לנו פה n כפול, מה יש פה למטה? טריינגל, נקודה. אפנד את העבר במטריצה בשורה ה-i, החל מהעמודה הראשונה עד לא כולל לעמודה ה-i. מעניין.

138
00:48:26,960 --> 00:48:56,940
אז מה אתם אומרים? אתם מצליחים להבין מה קורה כאן? תראו, אם הייתם מנסים לריץ את זה על דוגמא, על נייר או על מחשב, הייתם בעצם מבינים שמה שאנחנו עושים כאן, אנחנו לוקחים מטריצה, נניח שזו מטריצה דו-ממדית, כן? ואנחנו שומרים מתוכה משולש תחתון בגודל n על n. מה זאת אומרת משולש תחתון?

139
00:48:56,940 --> 00:49:26,760
זאת אומרת, דמיינו לרגע שיש לנו מטריצה, לא יודע, 1, 2, 3, 4, 5, 6, 7, 8, 9, כן, מטריצה שלוש על שלוש. אז תראו איך החישוב הזה הולך. אוקיי, n שלנו, בסדר? n שלנו, שימו לב, לנקט של מטריצה, אבל אני מקווה שאתם זוכרים מה דיברנו על רשימות רב-ממדיות. העורך הזה,

140
00:49:27,760 --> 00:49:56,660
אתם מבינים שאם כל שורה במטריצה היא בעצמה רשימה, כן? אז בעצם יש לנו רשימה 1, רשימה 2, רשימה 3. אז הלנקט של המטריצה הוא בעצם שלוש, כן? מקווה שאתם מבינים את זה. אז בעצם אנחנו ניקח i שווה 0, אין בעיות. אז הטריינגל אפנד, אנחנו ניקח מטריצה בשורה i, מהעמודה הראשונה עד ולא כולל עמודה 0.

141
00:49:56,660 --> 00:50:26,460
בקיצור, הקודקוד יהיה כאן כלום, עכשיו נעבור ל-i שווה 1, ואז אנחנו נוסיף רשימה שהפעם היא לא תהיה ריקה, כאילו אנחנו, מה אנחנו נוסיף הפעם? נוסיף מטריצה בשורה 1, ואז מהעמודה 0 עד עמודה 1, לא כולל עמודה 1. היו לנו אחרות, היה לנו את זה.

142
00:50:26,460 --> 00:50:56,460
את זה, אני חושב, ואז ב-i שווה 2 יהיה לנו משהו כמו 7 וגם 8, נכון? כל זה תחת ההנחהשמימין על נקודתיים, כאילו אנחנו אומרים "איפה לעצור, אבל לא כולל".זאת אומרת יהיה לנו את 0 ו-1, ו-היי, אם אני טועה, אם אתם חושבים שהמשולה שדווקא יהיה 1, 4, 5, 7, 8, 9, אתם מוזמנים לכתוב את הכל הזה ולהריץ אותו, אבל זה

143
00:50:56,460 --> 00:51:23,180
זה לא מה שחשוב, אנחנו מדברים פה נטו על סיבוכיות, אז רק היה חשוב שהבנו מה הפונקציה הזאת עושה, אנחנו בעצם מחזירים רשימה שהיא משולש שמאלי תחתון של המטריצה שאנחנו קיבלנו ככלת. עכשיו, מה סיבוכיות הזמן לדעתכם, סיבוכיות מקום, סיבוכיות זמן, בואו נסה להבין, אז אפשר לחשוב על זה בסיבוכיות מקום.

144
00:51:24,740 --> 00:51:54,700
גם בסיבוכיות מקום וגם בסיבוכיות זמן, האמת זה די דומה, כי מה שבעצם קורה, אנחנו בכל איטרציה, כן? בכל איטרציה מ-0 עד אורך רשימה n, כי הרי, תראו, הקלט שלנו, הקלט שלנו בעצמו, אנחנו נתייחס אליו n בריבוע, נכון? מה הקלט? הקלט זה מטריצה שהיא n על n בסך הכל. ויש לנו פה איטרציה, for r.

145
00:51:54,700 --> 00:52:20,700
i n ריינג' n, אז זאת אומרת, זה יקרה n פעמים, אז כל פעם מתוך ה-n פעמים האלה, אנחנו בעצם בונים רשימה, באורך שינה בין 0 ל-n פחות 1, לכל איטרציה, נכון? כמו שאמרנו, משולע שמאלי תחתון, כל פעם אנחנו בונים את זה, אנחנו יוצרים את זה.

146
00:52:20,700 --> 00:52:50,700
זה דרך אגב גם מה שאנחנו שומרים לזיכרון, זאת אומרת כי תראו את האפנד הזה, אפנד הזה אנחנו עדיין צריכים לבנות ב.. מילא, תגידו.. תשאלו כמה האפנד יקר, אז אני אגיד לכם בגלל שפייתון עובד בזיכרון זה לא מאוד יקר, בסדר. אז נניח שאפנד כשלעצמה היא לא יקרה, פעולה אפילו של או של אחד, זה עניין של מצביעים לזיכרון אבל הבנייה הא בנייה הצלילה.. סופו של דבר שאנחנו מצביעים לזיכרון ולא מה שאתם שומעים מכן את זה לצדדת או להפסוד את זיכרון של אישץ. שאתם

147
00:52:50,700 --> 00:53:15,340
לייס הזאת של המטריצה הבנייה של האיזו רשימה לבנות עכשיו וכולי וכולי אתם מבינים זה תהליך שלוקח עד או של n פעמים בנפרד, שוב אנחנו במקרה גרוע ביותר אז בעצם אנחנו מחשבים סכום כזה.

148
00:53:15,340 --> 00:53:45,260
כמובן אתם ראיתם דרך אגב את החישוב של 1 עד n, כן? אתם ראיתם שזה n כפול n פחות 1 חלקי 2 בקיצור או של n בריבוע, אז גם מבחינת מקום וגם מבחינת זמן זה גם הבנייה של הסלייסים האלה וגם לשמור אותם בזיכרון. זה בעצם החישובים שאנחנו עושים. שוב אתם מבינים? מה שאתם רואים כאן ממש הסכום הסדרה הזאת שאנחנו מחשבים סכום סדרה חשבונית.

149
00:53:45,260 --> 00:54:15,180
אפשר להגיד על כזה דבר קודם 0 או 1 מה שזה לא יהיה אתם מבינים אז 0, 1, 2 ונניח שזה היה ממשיך אז 3 ואז 4 ככה לכל שורה במטריצה אנחנו בונים יותר ויותר ויותר עד ל n פחות 1 וגם בזמן יצירת הסלייס זה עבודה זה באמת עבודה זה באמת מעבר על אותה שורה במטריצה.

150
00:54:15,180 --> 00:54:45,180
סטופ ואז להגיד 'הנה אתה רשימה חדשה' שאותה אנחנו נעשה אפנד לטריינגל, אז בדוגמא הזאת, אני לא יודע אם זה היה לכם מאוד אינטואיטיבי, אבל בדוגמא הזאת הסיבוכיות שאנחנו מתעסקים איתה היא תהיה או של m בריבוע. או-קיה. אז נניח שראינו מספיק דוגמאות.עכשיו זמן לראות כמה תרגילים ברצף, והפעם התשובות לא כתובות ישר על השקופית.

151
00:54:45,180 --> 00:55:15,180
אנחנו באמת צריכים לחשוב על מה שאנחנו רואים. אז נתנו לנו פונקציה ואנחנו צריכים לבחור את סיבוכיות הזמן והזיכרון. אז כאן אנחנו ממש חייבים לראות אם יש לנו את האינטואיציה הנכונה של חישוב סיבוכיות. בואו נתחיל. פונקציה, מקבלת ככלת n ו-m. בהתחלה אנחנו אומרים a ו-b שווים 0. עד כאן זה משהו קבוע.

152
00:55:15,180 --> 00:55:26,080
ועכשיו 4i in range של n, a פלוס שווה איזשהו מספר אקראי.

153
00:55:26,080 --> 00:55:31,440
עכשיו אני הולך להניח שהרנדום הזה, זה באמת מספר אקראי.

154
00:55:31,440 --> 00:55:37,340
דרך אגב, we do in it live, כן כן, ראיתם את זה עכשיו?

155
00:55:37,340 --> 00:55:45,140
בקיצור, n פעמים, n גדול פעמים, משהו כבוה.

156
00:55:45,140 --> 00:56:15,140
ואז m גדול פעמים, משהו קבוע. אז מבחינת סיבוכיות זמן, מה קרה פה? היה לנו, אני אפילו ממש יכול לכתוב את זה על הנוטפד, לראות אם זה אולי יעזור לכם. אוקיי, אז מבחינת time, היה לנו משהו קבוע, אז אני אגיד o של 1 זה ה-a פסיק b שווה 0,0 ועוד o של n גדול.

157
00:56:15,140 --> 00:56:45,140
זה האיטרציית for i in range n, היה לנו פה משהו קבוע בפנים, ועוד 0 של m גדול. שימו לב שמה שאני כותב עכשיו זה מאוד לא פורמלי, אני סתם כותב את זה בראש, כי אני חושב. בקיצור, מבחינתי, מה שאני רואה פה זה 0 של n ועוד m. עכשיו מבחינת ספייס, דווקא אם אפשר לדאן את ה-model בואו לתראות את זה, לחיים של כולם, זורקו מלוכות של כולם, יתרצים להחזיק כמה שאני רוצה ומביאו בשום מילה, מאוד יוצא מן כלום של כולם סמוך את כולם ולהצטרך: עושים  במחיר לא בדרך, אבל ח

158
00:56:45,140 --> 00:57:13,960
משתנה, משתנה, איטרטור משתנה, כלום כמעט, איטרטור, כלום כמעט, בקיצור, או של אחד. אז אם אתם שואלים אותי מה התשובה בתרגיל אחד, אני אומר לכם, התשובה שאומרת, סיבוכיות זמן, או של n ועוד m, סיבוכיות מקום, או של אחד, זה מה שאני חושב שנכון פה.

159
00:57:13,960 --> 00:57:42,200
נקסט, מה התרגיל הבא בתור? פונקציה מקבלת ככלת n גדול. יש לנו פה פקודה קבורה, a שוף 0. ועכשיו, 4i בריין של n, זאת אומרת, יש לנו פה n כפול, אז הנה, אני ממש פה, אני אכתוב את זה תוך כדי. אז 2, יש לנו פה o של 1 ועוד.

160
00:57:42,200 --> 00:58:10,400
בדיוק, שווה, אני אכתוב בנקודתיים, או של 1 ועוד, או של n גדול, אבל מה? תסתכלו טוב, בפנים, 4j in, רוורס של הריינג' בין i ל-n גדול. אוקיי, זה עדיין i עד n, גם בסדר הפוך. זאת אומרת, יש לי פה סיגמה.

161
00:58:10,400 --> 00:58:40,200
זה מרגיש קצת כמו סיגמה, אתם לא חושבים? כי תראו, אנחנו כאילו, עבור i שווה 0, יש לנו 0. עבור i שווה 1, יש לנו כאילו, 0 עד 1, עבור כאילו, זאת אומרת, יש לנו פה 0 ועוד 1 ועוד 2 ועוד 3 ועוד זה, עד ועוד n. זאת אומרת, אני מרגיש שזה בעצם, זה סיגמה של 1 עד n, ואני חושב שכבר ראינו את זה. זאת אומרת, ראינו את זה.

162
00:58:40,200 --> 00:59:10,200
ואני חושב שאני יודע מה להגיד לכם,אני חושב שהסיבוכיות זמן כאן, אה וכמובן בתוך הלולה כאן יש פשוט משהו קבוע, זה פקודה אחת מבחינתי, אז זאת אומרת אני רואה כאן, אני רואה כאן ממש סיגמה, סיגמה של I מבחינתי, כזה מ-0 עד N פחות 1, אתם רואים את זה? אבל...

163
00:59:10,200 --> 00:59:40,200
יש לנו פה את עלולה חיצונית שכאילו עוברת מעפס עד n פחות 1, זה כאילו n פעמים בחוץ, והם בפנים, זה...זה...זה... כאילו משהו שעולה. אתם רואים את זה? זה ממש ככה, זה כזה... קשה כבר להסביר את זה, כן? זה כזה for i in range של n, ואז בפנים יש לכם for j in... ככה... חייב להיות, לא יורדנו ל... קשה כבר להסביר את זה, כן? זה כזה for by,

164
00:59:40,200 --> 01:00:10,120
ריינג' של I, אז אתם מבינים את זה? זה מה שיש לנו פה. בקיצור התשובה כאן היא סעיפתא לציבור חיות זמן של O של N בריבוע, למה? בגלל סדרה חשבונית, אז time זה ממש, לא יודע, נקרא לזה 1 ועוד 2 ועוד 3 ועוד טהטהטה ועוד, אה, M פחות 1.

165
01:00:10,120 --> 01:00:40,040
זה מביא לנו O של N בריבוע. אוקיי, נניח שהבנו. הלאה, תרגיעי 3. פונקציה שנקבלת כ-N, נקבלת כאלת N, בסדר. נגדיר K שווה 0, זה משהו קבוע. עכשיו אנחנו אומרים, for I in range שבין חצי N ל-N.

166
01:00:40,040 --> 01:00:55,780
אז שימו לב שגם אם הריינג' הוא חצי מ-n זה עדיין o של n, ה-4 שלנו, כלומר יש לנו 4, o של n, נקודתיים, ואז משהו שקורה בפנים, כאילו קורה o של n פעמים.

167
01:00:59,780 --> 01:01:10,000
מה יש לנו פה? j שווה 2, ואז אנחנו אומרים, כל עוד ש-j קטן שווה ל-n, עושים משהו עם k, לא ממש מעניין אותי.

168
01:01:10,000 --> 01:01:30,000
j כפול שווה 2, זה כן חשוב, תראו את זה. אנחנו מתחילים ב-j שהוא שווה 2, ואז אנחנו אומרים, כל עוד ש-j קטן שווה ל-n, אנחנו מכפילים את j בשתיים.

169
01:01:30,000 --> 01:01:52,000
אז j כפול 2, ואז עוד פעם כפול 2, ועוד פעם כפול 2, ועוד פעם כפול 2, עד שאנחנו מגיעים בעצם ל-n. אז פה מגיע הקטע של לוג, משהו שאמרתי לכם מוקדם יותר בתרגיש שאנחנו נצטרך להתעסק איתו. ומה הקטע?

170
01:01:52,000 --> 01:02:22,000
לוג זה בעצם נותן לנו את החזקה של מה שהיינו צריכים להעלות בסיס כדי להגיע לתוצאה. או זאת אומרת, תסתכלו... נניח יש לי 2 ואני רוצה לקחת את 2 ולהביא אותו ל 8. אני רוצה להביא אותו ל-8. כדי לעשות את זה אני צריך לעשות 2 בחזקת 2, 2 לשמונה ואני צריך להעלות לקחת את 1 לחזקת 2 לשמונה ואני צריך להעלות להעלות לשמונה. זה דומה לסכולת שפיפה הפינימית של ערבי. אז פעמיים במדינה רבעה שאתה חתיך מצפצף לעשות לבסיס חמש טירומונות לגופות. שתתרחיש בטוצר ערך קטטיב חס

171
01:02:22,000 --> 01:02:51,600
שלוש שווה שמונה, זאת אומרת, אני צריך לעשות שתיים, כפול שתיים, כפול שתיים, וזה מביא אותי לשמונה. אז מה הרעיון? כמה פעמים הייתי צריך לעשות פעולה של כפול שתיים, כדי להביא אותנו לשמונה? אז התשובה היא, לוג בסיס שתיים של שמונה שווה שלוש. זה, זה הסוד פה.

172
01:02:51,600 --> 01:03:02,040
אז אתם יודעים למה אתם רואים את הווייל הזה? מה שקורה כאן, הווייל הזה אומר, כל עוד שלא הבאנו את j להיות n, נכפיל את j בשתיים.

173
01:03:02,040 --> 01:03:18,200
אז בעצם, יש פה לוג בסיס שתיים, n פעמים, שאנחנו עושים את פעולת הכפול שווה שתיים הזה, עד שהבאנו את j להיות n גדול.

174
01:03:18,200 --> 01:03:41,200
זאת אומרת, יש לנו n, יש לנו n חלקי שתיים פעמים, יש לנו n חלקי שתיים פעמים, זה ה-for i החיצוני, כפול, לוג בסיס שתיים של n פעמים, שעשינו את הפעולה הזאת, j כפול שווה שתיים, כדי להביא את j להיות n.

175
01:03:41,200 --> 01:04:11,100
היי, n חלקי שתיים זה פשוט n, o של n, לוג בסיס שתיים, אגב זה בסיס הכי פופולרי שנתעסק איתו, כן? אבל כמובן שיש בסיסים אחרים. בקיצור, o של n כפול o של log n, במילים אחרות, סיבוכיות זמן כאן, היא o של n כפול log n. למה? n פעמים, לולאת הפור, כפול, log n פעמים.

176
01:04:11,100 --> 01:04:41,080
הווייל, ואז אתם רואים שכל שאר הדברים פשוט קבועים שנמצאים בפנים, אבל זה לא מה שמעניין אותנו, נכון? אמרנו בסיבוכיות, מעניין אותנו התמונה הגדולה, הלולאות, הוויילים, הרשימות, האורך כלת, זה הבשר האמיתי, אז זאת התשובה, o של n log n. אוקיי, אנחנו יכולים להמשיך לתרגיל 4.

177
01:04:41,080 --> 01:05:06,400
מה יש לנו פה. פונקציה מקבלת n ככלת, a שווה 0, בסדר. i קטן שווה n גדול. עכשיו מה אנחנו אומרים, כל עוד שi גדול מ-0, נגדיל את a, לא מעניין. אוקיי, i חלקי חלקי שווה 2. זאת אומרת, מה קורה כאן?

178
01:05:06,400 --> 01:05:35,960
התחלנו את i מלהיות שווה n עצמו, ואז אנחנו אומרים, כל עוד שi עדיין חיובי, עדיין סליחה גדול מ-0, זאת אומרת עדיין ממש מספר שהוא גדול מ-0, אנחנו מחלקים אותו ב-2. אוקיי, כמה פעמים זה ירוץ? זה די דומה. מה יש לנו? i בחזקת כמה פעמים.

179
01:05:36,800 --> 01:06:05,940
עוד אני יכול... כן, i בחזקת כמה פעמים שווה ל-n, אתם יודעים מה התשובה? התשובה היא, כמה פעמים שהוואל הזה ירוץ. זאת אומרת, לוג בסי 2 של n, זה כמה פעמים ייקח לזה לרוץ, כי... וואלה, זה מה ש... זה מה שיביא את ה-i שלנו להיות 0.

180
01:06:05,940 --> 01:06:25,880
בסופו של דבר. סתם דוגמא נניח ש n היה 8 בסדר? תחשבו על זה n היה שווה 8. אז אמרנו פעם אחת i חלקי חלקי שווה 2 אין בעיות i שווה 4. נריץ את זה שוב.

181
01:06:25,880 --> 01:06:52,100
i חלקי חלקי שווה 2, i שווה 2. נריץ את זה שוב, i חלקי חלקי שווה 2. נקבל את ה-1 או את ה-0. מה שזה לא יהיה, הרעיון הוא שזהו, ירדנו מתחת לשתיים. אין יותר כבר מה לחלק. עד כדי קבוע, עד כדי פלוס מינוס 1, הגענו לזה, הגענו לתשובה. לא הגן.

182
01:06:52,100 --> 01:07:22,000
אז אתם ראיתם עכשיו דוגמא שנייה ברצף של איך שכפל או חלוקה בשתיים, יש איזה מערכת יחסים מאוד מאוד אדוקה עם לוג של n. הרעיון הזה של כפול שווה 2 כל פעם, כל הקטע הזה של חזקות וזה, תמיד תחשבו על לוג בעניין הזה. אז התשובה פה, למקרה זה לא היה ברור.

183
01:07:22,000 --> 01:07:51,000
היא או של לוג n סיבוכיות זמן. אוקיי, sanity check. מה הקריטריון הכי טוב בשביל להשוות בין יעילות של אלגוריתם? מה הקריטריונים שהכי טובים לנו? כמה פעולות אנחנו עושים? כמה מקום אנחנו תופסים בזיכרון? אולי שום דבר? אז בתכלס התשובה היא, גם...

184
01:07:51,580 --> 01:08:03,440
סיבוכיות זמן וגם סיבוכיות מקום זה שני דברים שחשובים לנו התשובה פה היא תהיWhoa ג, אוקיי.

185
01:08:03,940 --> 01:08:13,480
בוא נראה אם שאנחנו עדיין ערענים איך אנחנו מודדים סיבוכיות מקום זוכרים אנחנו סופרים כמה ביטים הקצינו בזיכרון של המחשב.

186
01:08:13,960 --> 01:08:32,240
אנחנו סופרים כמה פעולות פרימיטיביות האלגוריתם מבצע לפי גודל הקטע הנתון. מה הגיע? זה סיבוכיות זמן מה אתה עושה פה? האם אנחנו סופרים תאי זיכרון באופן כללי שנשמרו במלאך ריצת התוכנית? או שאף תשובה לא נוכחה.

187
01:08:32,980 --> 01:08:49,940
או שאף תשובה לא נכונה, אז התשובה הנכונה כאן היא ג' בסדר? בסיבוכיות מקום, מה שמעניין אותנו זה תאי זיכרון, זה יחידות זיכרון כלליות שאנחנו עובדים איתן. זה איך שאנחנו מודדים סיבוכיות מקום של אלגוריתם כללי.

188
01:08:50,860 --> 01:09:02,180
אוקיי, חזרה ל-main programming, מה שנקרא. אוקיי, הנה פונקציה. מקבלים ככלת n ו-k.

189
01:09:02,180 --> 01:09:16,140
מתחילים ב-i שווה 1, עכשיו, כל עוד ש-i קטן מ-n גדול, מה נגיד? i כפול שווה k, אוקיי, אז פה זה שונה.

190
01:09:16,140 --> 01:09:45,640
לוקחים את ה-i שלנו, מכפילים אותו ב-k כל פעם, כל פעם כפול k, כפול k, כפול k, עד שנגיע ל-n. בסדר. אז פה חוקי לוגריתמים. יש בסיסים ללוג. הרי כל הפואנטה בחזקות ואז בלוגים, זה בחזקת מה, מה בחזקת מה, בסדר? אז פה ספציפית, זה...

191
01:09:46,260 --> 01:10:14,320
זה כבר יותר כמו, איך אני אגיד לכם? k בחזקת מה, שווה ל-n גדול. זה בעצם התשובה, כן? זאת אומרת, כאילו, התשובה כאן היא חייבת להיות, כמה פעמים לולאת הווייל הזאת תרוץ, היא תהיה לוג בבסיס k של n. למה? המספר הסופי שהגענו אליו זה n, כן?

192
01:10:14,320 --> 01:10:44,300
ומספר הפעמים שהעלינו בחזקה את k בעצמו, k בחזקת משהו, ראיתם? כי זה כל הזמן כפול שווה k. אגב, k בחזקת 0 יהיה 1, כן? אז מבחינתכם, התחלנו את ה-i בלהיות k בחזקת 0. אז זאת אומרת, k בחזקת 0, ואז כפול k, אז עכשיו k בחזקת 1, כפול k, k בריבוע, כפול k.

193
01:10:44,300 --> 01:10:55,180
K, K בשלישית, עד שהגענו ל-n, אתם מבינים? אז K בחזקת כמה פעמים לולאת ה-Y הזאת רצה, עד שהגענו ל-n.

194
01:10:55,660 --> 01:11:14,140
ולכן התשובה חייבת להיות לוג בבסיס של K של n. זאת אומרת, כמה פעמים העלינו בחזקה את K כדי לקבל n? זאת התשובה. כאן התשובה היא ג'.

195
01:11:14,140 --> 01:11:43,580
לוג בסיס K של n. אוקיי? שאלה הבאה בתור גם סיבוכיות זמן. בואו נחשב. יש לנו פונקציה שהיא מקבלת איזשהו מכרוזת, קיקלת, ואז אנחנו אומרים, לכל אות באותיות שיש באנגלית. אוקיי. זה יכול לבלבל אתכם.

196
01:11:43,580 --> 01:12:13,420
שימו לב. בשאלה הזאת, אנחנו מניחים שאתם יודעים שיש מספר קבוע של אותיות באלפאבית האנגלי. ספציפית, 26. פה כתוב English Letters שווה 3 נקודות, אבל הרעיון הוא, תניחו שזה אולי רשימה או, לא יודע, טאפל של A, B, C עד ל-Z. 26 אותיות. בסדר?

197
01:12:13,420 --> 01:12:43,040
מה הפואנטה? למה זה חשוב? אז אמרו לי את לולאת האפור הזאת. עכשיו, לולאת האפור הזאת, היא O של אחד פעמים, רצה. למה? בגלל שהלולה הזאת לא תלויה בשום אורך קלט משתנה כן או לא. לא. זאת לולה שתרוץ תמיד 26 פעמים, O של אחד פעמים, מספר קבוע. קבוע.

198
01:12:43,040 --> 01:13:13,040
אוקיי, זאת אומרת, יש לנו פה לולה שאומרת לכל אות מתוך 26 אותיות, זאת אומרת מספר קבוע של פעמים כפול. עכשיו שאלה, אם האוט הזאת not in המחוזת קדט שלנו, נחזיר false. עכשיו שאלה אם האוט הזאת not in המחוזת קדט שלנו, נחזיר false. אחרת, נחזיר true, זאת אומרת שכל האותיות שהיא אומרשה חזרת להיות לא חזרת להיות לחוזית כי היא חזרת להיות חזרת להתעורך מהדרך שלך בחיים וחזרת הצורה שלך והחזרת להחזיר להם גרע. או שאתה אפשר להחזיר את המקום שלך בשום דבר אלא לצריך להקרא לך חזרת, אתה צריך להח

199
01:13:13,040 --> 01:13:27,640
איפשהו באלפיית האנגלי היו, בסדר. עכשיו השאלה, איך נגדיר את, איך נגדיר את הסיבוכיות זמן כאן?

200
01:13:27,640 --> 01:13:42,860
הרי, הבנו שה for הזה, הוא לא ישפיע, הוא יהיה או של אחד כפול. אז, מה, איפה בשר פה? מה כבד כאן? כנראה שזה in,

201
01:13:42,860 --> 01:13:58,980
אופרטור אין, למה? כי מה שאלה? איף let'ר, זה שכתוב פה not, תתעלמו מזה לרגע, זה לא חשוב. זה כאילו איף let'ר משהו אין input-string.

202
01:13:58,980 --> 01:14:28,900
זאת אומרת, אנחנו צריכים לבדוק, לעשות השוואה בין let'ר וכל האיברים שבא input-string, כי רק אז אנחנו נדע האם ה-let'ר הזה כן שמה או לא שמה. זאת אומרת, מה קורה כאן בעצם? יש לנו o של אחד פעמים, שימו לב, let'r in English Letters, זה 26 אותיות, זה o של אחד עדיין.

203
01:14:28,900 --> 01:14:58,840
o של אחד פעמים כפול בדיקה אם האות נמצאת ב- input-string. מה האורך של ה- input-string? o של n. זאת אומרת, זה שהיינו צריכים לבדוק אם האות נמצאת בכלל במחוזת, זהו, אנחנו צריכים לעבור על כל מה שיש במחוזת, לעבור לכל הקלט. אז זה ה-o של n, וזה נמצא פה.

204
01:14:58,840 --> 01:15:28,800
אז O של N כפול O של אחד פעמים. זאת התשובה, O של N סעיף ב' תשובה ב' יותר נכון. אין בעיות בואו נמשיך, תרגיל תשע. נתונים לנו שני אלגוריתמים, אלגוריתם A שיש לו סיבוכיות זמן O של N ואלגוריתם B שיש לו סיבוכיות זמן O של הוגן. עכשיו הנה טענה.

205
01:15:28,800 --> 01:15:58,800
אלגוריתם B תמיד רץ יותר מהר מאלגוריתם A. הרי למה לא, כן? כי אומרים לנו שהסיבוכיות זמן של אלגוריתם B היא קטנה יותר משל אלגוריתם A, לא אגן. זה קטן יותר סמטוטית מ- n בחזקת 1. אז B תמיד רץ מהר יותר, לא? אז התשובה היא: לא. תזכרו לרגע בהגדרה של ה..

206
01:15:58,800 --> 01:16:08,060
הסמטוטיות ושל איך שהגדרנו את ה-O של, אנחנו אמרנו כל הקטע הזה ב-O של וכל זה, זה.

207
01:16:08,900 --> 01:16:21,140
החל מעורך כלת N גדול יותר מ-N טבעי כלשהו, עבור כבוע C גדול יותר מ-C כלשהו, זאת אומרת.

208
01:16:22,220 --> 01:16:52,000
למה הגדרנו את זה? למה הגדרה של הסיבוכיות זמן לפי הקצב גדיל הסמטוטי, למה אמרנו את זה? שזה חייב להיות עבור N גדול מ-N אפס, עבור C גדול מ-0 כלשהו. למה? הפואנטה היא, שיתכן מאוד שעבור קלטים קצרים מאוד, דווקא כן אפשרי שאלגוריתם אחר, אלגוריתם שהוא כאילו ב-O גדול יותר, וואלה מאוד אפשרי שהוא ספציפית עבור.

209
01:16:52,000 --> 01:17:21,860
הוא קלט קצר, יעבור מהר יותר. אבל זה כל עניין, זה מקרי קיצון בהתחלה. ההגדרה של קצב הגדיל הסמטוטי היא, מנקודה מסוימת והלאה, בעזרת קבוע כלשהו, או יותר גדולים ממנו. אז אנחנו יכולים להגיד בוודאות, כן, האלגוריתם שהסיבוכיות זמן שלו היא F של N, הוא כאילו חסום מלמעלה.

210
01:17:21,860 --> 01:17:28,720
על ידי האלגוריתם האחר שנמצא ב-O של G של N, בלה, בלה, בלה, בקיצור, בקיצור.

211
01:17:28,720 --> 01:17:51,420
התשובה לשאלה הזאת היא לא נכון, לא תמיד. יש תרחישים שבהם האלגוריתם עם סיבוכיות הזמן ב-O גדול יותר, כן ייקח פחות זמן. איזה תרחישים? במקרה הקיצון עבור קלטים קצרים, עבור C, עבור קבועים כאלה שקטנים מה-C,

212
01:17:51,420 --> 01:18:21,380
שקיים את ההגדרה שאתם ראיתם כאן. זאת התשובה, לא נכון, לא תמיד תמיד, רק מנקודה מסוימת והלאה, כן, אבל בהתחלה, לא תמיד. בסדר. יאללה, תרגיל עשירי. היי, פיבונצ'י, זוכרים אותו? חישבנו רקורסיבית את המספר פיבונצ'י ה-N, והיה לנו את התנאי הצירה שלה.

213
01:18:21,380 --> 01:18:41,260
שלנו, שזה היה העיף הזה, אז מבחינתנו אפשר כבר לקרוא לו פקודה יחידה או של אחד פקודות, ואז היינו תקריאות הריקורסיביות לסכום את הפיבונצי ה n פחות 1 עם ה n פחות 2. איך נחשב את ציבוריות הזמן של הדבר הזה? אז בוא נראה.

214
01:18:42,480 --> 01:19:08,160
אנחנו יכולים לכתוב משהו כזה, אנחנו יכולים לכתוב t של n, זאת אומרת הזמן לפי כלט של n שזה ייקח להריץ את זה, יש לנו את ה-o של 1, שזה החלק של הif והפעולת חישוב הסכום, עד כאן זה החלק הקל, אבל אנחנו תלויים גם ב-t של ה-n-1 הזה וגם ב-t של ה-n-2.

215
01:19:08,160 --> 01:19:38,100
זאת אומרת, לכל n כזה, יש לנו שתי קריאות כאלה עבור n קטן יותר. אז תראו, איך אנחנו יכולים לחשב o שזה, לפחות בצורה שהיא לא כל כך פורמלית, אבל מספיק טובה. כי כרגע אנחנו רק מתרכזים בחסם עליון שהוא די קרוב. אז תראו מה אנחנו יכולים לעשות. קודם כל, בתכלס o של 1, בסדר, בסדר, אפשר לשים אותך בצד.

216
01:19:38,100 --> 01:20:01,040
מה זה משנה, אפשר להגיד שכל הסיפור הזה, כל הסיפור הזה בעצם, הנה אני אכתוב פה קטן מ, תראו, תראו מה אנחנו עושים, כל זה קטן מ t של n-1 ועוד t של n-1 ועוד o של 1.

217
01:20:01,040 --> 01:20:31,040
זאת אומרת אני אומר שהחישוב של הסיבוכיות זמן ריצה כאן הדבר הזה הוא באמת יוצא קטן מקצ... קטן מ... אם במקום לקרוא לתהיש אליהם פחות אחד ותהיש אליהם פחות שתיים הייתי קורא פעמיים לתהיש אליהם פחות אחד, ברור לכם נכון, כי זה אומר שאני כאילו... בתחיש הזה היו לי קצת יותר קריאות אבל אז מה הרעיון ואגב ברשותכם רק אהמ...

218
01:20:31,040 --> 01:20:40,420
לשם התרגיל, אני אעיף לרגע את הווד או של אחד הזה, כדי שתבינו כמה שהוא חסר משמעות בחישוב הסימפטוטי שאנחנו עושים כאן.

219
01:20:40,880 --> 01:20:57,940
כי הרי ברור לכם שהקריאות האלה הן הרבה יותר משמעותיות מהאו של אחד. אז מה זה נותן לי? יש לי כאן, כאילו מה זה? יש לי פה שתיים כפול T של M פחות אחד.

220
01:20:59,180 --> 01:21:13,580
זאת אומרת, מה יש לי? t של n קטן מ-2 כפול t של n פחות 1, ואנחנו יודעים מה קורה בפיצול, כן?

221
01:21:13,580 --> 01:21:26,060
אנחנו יודעים מה קורה בפיצול, כל פקודה כזאת, כל t של n פחות 1, אנחנו יודעים שזה יהיה בסך הכל קטן מ-2 כפול מה? מה שעשינו פה?

222
01:21:26,500 --> 01:21:56,500
2 כפול t של n פחות 2. תסתכלו. האם אתם מבינים מה שקרה כאן? תראו מה עשינו. אמרנו, t של n קטן מ- 2 כפול t של n פחות 1. ואז מבפנים, אנחנו רצינו לחשב עבור t של m פחות 1. זה כאילו. אתם יודעים מה כתבנו? זה כאילו שאנחנו כתבנו פה t בסוגריים של m פחות 1 קטן מ- 2.1637373727175643�למולפנו מying שהם פחות אדם אצלך

223
01:21:56,500 --> 01:22:26,100
full t של n פחות 2, אתם מבינים את זה? אז אנחנו עושים את החישוב הזה, אבל מ-t של n כבר, כן? ועושים את זה 3 נקודות, 3 נקודות, מה הרעיון? זה בעצם תבנית כזאת, זה כאילו 2 קטן מ-2 בחזקת i, 2 בחזקת i, כל זה.

224
01:22:26,100 --> 01:22:48,980
כפול מה? כפול t בחזקת n פחות i. אתם רואים את זה? תסתכלו. t של n קטן מ-2 בחזקת 1 כפול t של m פחות 1, נכון? וזה קטן מ-2 בחזקת 2 כפול t של m פחות 2.

225
01:22:48,980 --> 01:23:18,880
בקיצור, זה התבנית, מה הפואנטה? בסופו של דבר, בסופו של דבר, מתישהו אנחנו נגיע ל-2 בחזקת n כפול מה? t של 1? מה זה t של 1? 2 בחזקת n כפול o של 1. זאת אומרת, 2 בחזקת n. אז כל העבודה הקשה הזאת, כל...

226
01:23:18,880 --> 01:23:47,580
כל העבודה הקשה הזאת, היא הייתה רק כדי להגיע איתכם למסקנה שחבר'ה, מה שבעצם ראינו פה, ראינו פה בעצם את הסיגמה של 2 בחזקת i, 2 בחזקת i, כאשר i שווה מ-0 או 1 עד ל-n פחות 1 או n, לזה אני מתכוון. זה הסיגמה שהיינו פה, היה לנו פה כזה דבר.

227
01:23:47,580 --> 01:24:17,540
ראיתם? איך אנחנו כאילו אמרנו אנחנו יודעים שזה קטן קצת מזה, שקטן קצת מפשוט חילצנו את זה החוצה, והיי מצאנו חסם עליון. התשובה כאן היא o של 2 בחזקת n בסיבוכיות זמן, והאמת שזה הגיוני, כי תראו כל קריאת fib קוראת היא מביאה לנו שתי קריאות, אז כשאנחנו יורדים.

228
01:24:17,540 --> 01:24:47,280
ברקורסיה, כל קריאה יוצרת 2. זאת אומרת כל קריאה יוצרת 2, אז זאת אומרת זה יצר שתי קריאות כאלה, שכל קריאות כאלה בעצמן יצרו 2. זאת אומרת 1, 2, 4, 8, 16. זאת אומרת זה סיגמה של 2 בחזקת i עבור ה-i שמתחיל מכלום עד ל-n, וזה נותן לנו...

229
01:24:47,280 --> 01:25:17,280
O של 2 בחזקת N, זה סכום שכדאי להכיר אותו. דרך אגב, מה לגבי סיבוכיות המקום של האלגוריתם? פה אני דווקא רוצה להגיד לכם שזה לא בהכרח מובן מאליו, חלק מכם יכולים לחשוב שזה אולי O של 1 כי,נו מה? אנחנו רק מריצים קורדאות פשוטות, אין פה שום רשימות, כלום. חלק אחרים יכולים להגיד, מה זה? כמו של 1 פשוט, זה אולי 2 או 3,8. חלק כך יכול להגיד "מה?" זה די פשוב, אבל חלק אחר מכם יכול להגיד לא להכיר את זה, רציני להגיד את זה. הדברים האלה לא כשר להבין פה אותם בטענות

230
01:25:17,280 --> 01:25:26,840
סיבוכיות הזמן ריצה, לא? כאילו, תראו כמה קריאות אגרוסיבית יש לנו, שתיים בחזקת אם סופו של דבר, וזה, לא? אז יאמר שזה לא זה ולא זה.

231
01:25:27,080 --> 01:25:47,100
למעשה, סיבוכיות המקום כאן היא דווקא יותר בסגנון של או של אין. אני רוצה להראות לכם המחשה ויזורלית שמצאתי לזה. הנה דוגמה, למישהו שקורא לפיב אף של ארבע. תראו מה קורה. אז אנחנו קוראים לפיב ארבע, בסדר? אז אתם יודעים שפיב ארבע...

232
01:25:47,100 --> 01:26:16,480
אבדוק, יקרא יותר נכון, ל-F3 ול-F2. אתם יודעים את זה. העניין הוא שהדברים האלה לא רצים במקביל, לא מבחינת האלגוריתם. זה רץ סדרתי, וזה חשוב. כשאנחנו נקרא לפיב שלוש ופיב שתיים, הנה תסתכלו על הקוד, פיב של אם פחות אחד ופיב של אם פחות שתיים, אל תניחו שזה רץ במקביל. תניחו.

233
01:26:16,480 --> 01:26:46,480
תניחו, שהדבר הראשון שאתם עושים, זה לקרוא לפי בשלם פחות אחד ולהיכנס פנימה ולעשות את מה שקורה שמה. זאת אומרת, כשקראנו לפי בארבע, אז דבר ראשון אנחנו נקרא לפי בשלוש. ואותו דבר, לפי בשלוש נקרא לפי בשתיים ואחד, אבל דבר ראשון אנחנו נריץ את פי בשתיים. וגם זה, אותו דבר, זה יקרא לפי באחד ולפי באפס. עכשיו תראו מה קורה, עכשיו תראו מה קורה. אנחנו כאן נמצאים,

234
01:26:46,480 --> 01:27:16,480
בעומק הרביעי, כן, עם העומק המקסימלי, שמעניין, זה כאילו כגודל הכלת. התחלנו מפיב 4, אנחנו עכשיו בעומק 4, אז יש לנו את 4 הקריאות השונות האלה, בסדר? אנחנו יודעים שכל קריאה של פיב היא O של אחד, אבל יש לנו פה N פעמים מספר קריאות של פיב, אוקיי? אז אנחנו כבר נמצאים בתחום של O של N, אבל אז תראו מה קורה.

235
01:27:16,480 --> 01:27:30,340
F של 1 ו-F של 0 הן מסיימות את עצמן מתקפלים משם ואז F2 נותן ערך מתקפל וזה מקום בזיכרון שמשתחרר לנו כן אנחנו לא צריכים אקסטרה.

236
01:27:30,940 --> 01:27:45,560
ואז F3 עכשיו עושה את הפעולה של F1 ואז גם זה יתקפל F3 כאן יתקפל ורק אז אנחנו נריץ את F2 שהוא גם יעשה דברים דומים למה שראיתם מפה.

237
01:27:45,980 --> 01:28:13,060
אז זאת אומרת, הכי עמוק שהיינו צריכים ברגע נתון מבחינת מקום, מבחינת תאי זיכרון אבסטרקטיים, אם אנחנו מבינים שכל פיב בנפרד זה פשוט o של אחד דברים, אז הכי עמוק שהיינו ברגע נתון שהיינו צריכים בזיכרון זה o של n פעמים קריאות פיב. אז o של n, זאת התשובה, o של n.

238
01:28:13,060 --> 01:28:27,000
רק שתדעו, הדברים שאתם רואים עכשיו, זה מסוג הדברים שממש אתם תעמיקו עליהם ותדברו עליהם בצורה יותר פורמלית בקורס המשך שקוראים לו מבני נתונים.

239
01:28:27,560 --> 01:28:32,820
אז, מה שאתם רואים עכשיו, יראה לכם מאוד מוכר, כשתגיעו לקורס ההוא.

240
01:28:33,440 --> 01:28:46,420
בכל מקרה זה עונה על תרגיל לסו ואגב טריוויה אם זה מעניין אתכם יש לנו פה גם שקופית חבויה שהיא מראה בעצם שינוי קוד קטן לפי.

241
01:28:47,080 --> 01:28:52,380
שבו אתם פחות או יותר מוסיפים עוד פרמטר עומק.

242
01:28:53,440 --> 01:29:23,420
ופה אתם ממש יכולים לראות מה העומק המקסימלי שהגעתם אליו בקריאות הרקורסיביות של פיב. כי אתם רואים שהשינוי הזה שפה אנחנו מוסיפים גם פלוס אחד לעומק עבור כל קריאה רקורסיבית לפיב. בסופו של דבר אנחנו מחזירים לא רק את הסכום של הפיבונאצ'י, אלא גם את המקסימום של כל העומקים שאי פעם הגענו אליהם. אתם ראיתם עכשיו מה הקטע המקסימום מתקבל בעצם בקריאה הראשונה של הקריאה.

243
01:29:23,420 --> 01:29:53,220
הראשונה של הקריאה הראשונה של הקריאה הראשונה עד הסוף. הפיב אל מינוס אחד של הפיב בין מינוס אחד כל הדרך עד הסוף שמאלה. זה מה שבעצם יחזיר המקס הזה אבל בסדר זה סתם טריוויה. יאללה בוא נעבור לשאלה הבאה בתור. אנחנו צריכים לכתוב פונקציה שנקבלת רשימה של מספרים שלמים, והיא תחזיר את הסכום המקסימלי שאתם יכולים להשיג עם שני איברים שונים ברשימה. זאת אומרת.

244
01:29:53,220 --> 01:30:19,820
איבר כלשהו, איבר אחר כלשהו, ואתם רוצים את הזוג המקסימלי בעצם. אז סתם דוגמא, אם יש לכם רשימה של 1, 2 ו-3, הזוג המקסימלי זה 2 ו-3, או 3 ו-2, אם כבר. זה ייתן לכם את 5. דורשים מאיתנו שתהיה לנו סיבוכיות זמן יעילה ככל האפשר. ... אוקיי.

245
01:30:20,460 --> 01:30:26,380
ואנחנו צריכים להיות יעלים פה, אז איך אנחנו נהיה יעלים כאן?

246
01:30:26,380 --> 01:30:36,180
אני לא יודע מה איתכם, אבל אני מבין שאני רוצה לעשות מקסימום לדעתי או של אין.

247
01:30:36,180 --> 01:30:47,380
זאת אומרת, אני רוצה מקסימום מספר קבוע של מעברים על פני הרשימה כדי להשיג לעצמי את הזוג המקסימלי הזה.

248
01:30:47,380 --> 01:31:17,300
אני לא יכול להרשות לעצמי לולאה בתוך לולאה. זאת אומרת, לכל מספר ברשימה לעשות לולאה פנימית שמסתכלת על הסכום שלו ביחד עם שאר האיברים ברשימה. זה לא ילך, זה יותר מדי לא יעיל. אז מה אני כן יכול לנסות לעשות כאן? מה שאני בעצם יכול לעשות, אני יכול להגדיר לעצמי כאן, נקרא לזה מקס אחד, מקס שתיים.

249
01:31:17,940 --> 01:31:46,380
אני אתחיל כבר מההתחלה. אני אגיד, איבר הראשון, אתה תהיה מקס אחד, ככה. ואני אגיד איבר שני, אתה תהיה מקס שתיים. בסדר? עכשיו מה? אני ארצה לעשות מעבר על הרשימה, כל פעם אני ארצה לעשות איזה שתיים שלוש השוואות כאלה. אני ארצה לבדוק, משהו כזה.

250
01:31:47,160 --> 01:32:12,160
נניח, נתחיל כמובן מהאיבר השני והלאה, כן? החל מליסט 2 והלאה, כן? עד ליסט, לא יודע, N פחות 1, כן? כאילו, לכל אחד מאיברים הבאים בתור, אני אעשה בדיקה, אני אשאל, ליסט, ליסט באינדקס I, האם אתה גדול ממקס 1?

251
01:32:12,160 --> 01:32:28,160
אם כן, אני אגיד ממש, אם כן, אז אם ככה, מקס 1 שווה לליסט I. זאת אומרת, אם מצאתי כבר מישהו שהוא גדול יותר, אז יש לי מחליף למקס 1.

252
01:32:29,160 --> 01:32:41,160
אם לא, אני יכול לשאול משהו אחר, אני יכול לשאול ליסט כזה, משהו כזה, אם לא, אני יכול לשאול, האם ליסט I? ליסט I.

253
01:32:41,160 --> 01:33:10,160
האם אתה גדול ממקס 2? ואז אם כן, אני יכול להחליף. זאת אומרת, הרעיון כאן הוא, אני ארצה לעשות מעבר אחד לאורך הרשימה, ושם, אני תמיד, לכל איבר, במעבר האחד הזה על הרשימה, אני אהיה אופורטוניסט, אני מיד אשאל, היי, האם אתה גדול, בעצם, מהשני איברים המקסימליים שיש לי עד עכשיו? כי אם כן, אז אתה עכשיו תתפוס מקום.

254
01:33:10,160 --> 01:33:18,760
אז אתה עכשיו תתפוס מקום. עכשיו שימו לב, כשכתבתי פה איפה יש, אז מקס אחד שווה לסתיים, חכו עם זה.

255
01:33:19,200 --> 01:33:33,740
קודם כל, התכוונתי מקס שתיים שווה מקס אחד, ואז מקס אחד שווה לסתיים. כן? כי שוב, אני רוצה את הזוג הגדול ביותר, אז אני שומר פה על שני המספרים הכי גדולים מהרשימה.

256
01:33:34,540 --> 01:34:04,520
זאת אומרת, זה סוג אלגוריתם, אני יכול לפרמל אותו, אני יכול קצת לעבוד עליו, אבל זה המחשבה שאני רוצה לעשות בראש, כדי להגיע לפתרון. ובסופו של דבר, אחרי שאני מפרמל את העניין הזה, אני יכול לעשות את זה. אז ככה. אז בעצם זה מה שאנחנו עושים. אנחנו יכולים קצת לעשות את זה בצורה יותר פורמלית ולהגדיר את זה. אז ככה, נגיד.

257
01:34:04,520 --> 01:34:34,520
את הפונקציה שלנו max sum שהיא תקבל את הליסט. קודם כל אם אורך הרשימה הוא קטן משניים זאת אומרת אם יש לנו רשימה שהיא מילא זה רק איבר אחד אז אין מה לעשות פשוט נחזיר את האיבר הראשון ויאללה. נניח שזה לא קרה, אז תראו מה אנחנו עושים. קודם כל אנחנו רוצים להסתדר על זה שמקס אחד היא האיבר הכי גדול ושמקס 2 היא האיבר הכי קטן, אז אנחנו עושים טריק כזה של פעולה שהיא או של אחד. נגיד מקס אחד אתה תהיה המקסימלי.

258
01:34:34,520 --> 01:34:58,200
בין האיברים הראשונים, אז זה כבר יותר חכם מההגדרה שעשיתי פה, כן? זה יותר חכם. כי אני רוצה שמקס אחד תמיד יהיה הכי גדול ומקס שתיים יהיה השני הכי גדול. אז מבין שני האיברים הראשונים, אני אומר מקס אחד אתה תהיה המקסימום שביניהם ומקס שתיים אתה תהיה המינימלי שבין השניים הראשונים. סבבה יש לי מה שנקרא Default Initialization.

259
01:34:58,200 --> 01:35:28,200
ועכשיו אני בונה את המקסימום שלי על ידי מעבר אחד ברשימה והנה אני עושה for item in list, הנה ה-o של n שלי, אם ה-item הנוכחי גדול ממקס 1 אין בעיות, מקס 2 אתה תקבל את מקס 1 הישן, מקס 1 עכשיו אתה תהיה ה-item הנוכחי, אם לא אז אני אומר אוקיי, אבל אייטם, יש מצב שאתה גדול יותר מהמקס השני, אם כן?

260
01:35:28,200 --> 01:35:58,200
אז max 1 עכשיו תהיה האריתם הזה, וזהו, נסיים מעבר אחד שלם על הרשימה, ואז יהיה לנו ב max 1 את האריתם הכי גדול בליסט, וב max 2 את השני הכי גדול בליסט. וזה רבותיי עונה על הדרישה של השאלה, וככה - אנחנו החזקנו את עצמנו, לא נכנענו, לא עשינו 4 בתוך 4, אלא עשינו לולאה 1 וניצלנו, ניצלנו כמה ש...

261
01:35:58,200 --> 01:36:28,200
איך אפשר את המעבר הזה, המעבר האחד הזה, על הרשימה. זה מה שעכשיו כשאנחנו לומדים על סיבוכיות, מה שאנחנו צריכים להתחיל לעשות. לחשוב איך לכתוב דבר שעושה פחות מעברים מיותרים. עכשיו דיברנו הרבה מאוד מאוד על סיבוכיות. עכשיו אני רוצה לדבר איתכם על משהו שהוא קצת שונה. על נושא של חיפוש. תראו, בעולם

262
01:36:28,200 --> 01:36:44,300
בעולם האמיתי, הרבה פעמים כשיש לנו מידע, רשימות, מערכים, ערמות, כל מיני מבני נתונים מסוימים שאתם תתעסקו איתם מאוחר יותר, הרבה פעמים אנחנו צריכים למצוא פריט כלשהו.

263
01:36:44,300 --> 01:36:52,420
מתוך כל המידע ששמרנו איפשהו, באיזשהו מבנה נתונים כלשהו, אנחנו רוצים למצוא משהו.

264
01:36:53,860 --> 01:37:12,320
אז האלגוריתם חיפוש, אלגוריתם שנותן לנו למצוא איזשהו איבר הכי יעיל, הכי פשוט, אפשר להגיד, שאנחנו יכולים לחשוב עליו, הוא כזה שתלוי בעובדה אחת.

265
01:37:14,040 --> 01:37:22,520
אנחנו צריכים שהרשימה או מערך או מה שזו לא יהיה, אנחנו צריכים שהדבר שאנחנו מחפשים בו יהיה ממוין, מהקטן לגדול.

266
01:37:23,140 --> 01:37:51,100
אנחנו צריכים, אם אנחנו רוצים למצוא איבר ברשימה בצורה יעילה, אנחנו צריכים שהרשימה תהיה ממוימת, למה? כי אם הייתה לנו, תחשוב על זה ככה, אני חושב שיש לנו רשימה שהיא בלאגן ענק, חמש, עשר, שתיים, לא יודע, שמונה, מינוס שלוש, אפס, לא יודע, מינוס אחד, זהו.

267
01:37:51,100 --> 01:38:20,740
זה בלאגן, אם אני רוצה עכשיו לחפש פה, האם, לא יודע, האם שבע אני אמצא פה, האם שמונה נמצא פה, אין לי פה סדר מסוים, לא הייתה לי ברירה אלא לעשות חיפוש, כזה, כזה ממש ברוט פור סארצ', ב-O של N, זה פשוט, Go Through One By One, כן? אבל זה לא מה שאנחנו רוצים.

268
01:38:21,700 --> 01:38:50,660
דמיינו אם היה תרחיש אחר, דמיינו אם הייתה לי רשימה ממויינת, ואז היה לי את מינוס שלוש, אחר כך מינוס אחד, אחר כך אפס, אחר כך, בואו נראה, שתיים, אחר כך חמש, אחר כך שמונה, אחר כך עשר, נכון? כמה איברים, אוקיי? אז תקלו. עכשיו נניח שאני רוצה למצוא ברשימה הזאת את שמונה.

269
01:38:50,660 --> 01:39:20,660
תראו קטע. הנה מה שאני יכול לעשות. דבר ראשון, אני יכול להסתכל באמצע של הרשימה. מה אתה? אתה שמונה? לא. אתה קטן או גדול משמונה? אה, אתה קטן משמונה! אין בעיות. אז אתם יודעים מה אני יכול לעשות? אני יכול להסתכל על החצי הימני של הרשימה באיט הרציה הבאה בתור. זאת אומרת, עכשיו אני צריך להסתכל. אני יכו להסתכל על את הצדק של המן השתכול בש אתרץ של הרשימה.Inrite  תקשבתי, הרבה פעמים אני לא יוכל להפוך דרכה כבר. הם תומכים לינbalance בשוב ‫לטוב  או כי אותך. ‫שראה לי כמי להפ

270
01:39:20,660 --> 01:39:31,780
אני יכול להסתכל על רייט האוף, אפילו להתעלם כבר משתיים, כי לא צריך אותו, הרי אמרנו שהוא לא שמונה, ואני יכול עכשיו רק לראות את חמש שמונה ואת עשר.

271
01:39:31,780 --> 01:40:04,846
עכשיו תראו, אני שואל, איבר האמצעי האם אתה שמונה, מצאנו אותו. עכשיו נניח שלא רציתי את שמונה, נניח שרציתי את עשר, לא נורא... אני הולך לאיבר האמצעי, ואני שואל אותו, תגיד אתה עשר? לא.. עשר זה הגבר... 566 125 ... 17 6 4  הכל אני.. להתבהיל על זה. 17 6 5 6 3 4 4 9 2 1 1 4 1 3 3 4 3 . 4 3 2 2 2 1 2 0 ? 40 מישהו צריך לצעוק או ש

272
01:39:31,780 --> 01:40:01,540
עכשיו תראו, אני שואל, עיוור האמצעי, האם אתה שמונה? מצאנו אותו. עכשיו נניח שלא רציתי את שמונה, נניח שרציתי את עשר, לא נורא. אני הולך לעיוור האמצעי, ואני שואל אותו, תגיד אתה עשר? לא. עשר גדול ממך? כן. אין בעיות? אני הולך עכשיו לרייט, רייט האף. זה כבר קוורטר, אבל שיהיה.

273
01:40:01,540 --> 01:40:31,500
אני מתעלם משמונה ומשהו משמאלו, ואני נוחת רק על עשר. ואני הולך אליו, עשר, אתה עשר? כן. יופי. בקיצור, מה ראיתם פה? אתם ראיתם פה מצב שבו, כשהרשימה שלנו הייתה ממויינת מהקטן הגדול, אני לא הייתי צריך לעבור איבר איבר כדי למצוא את מי שאני מחפש. אני בסך הכל הייתי צריך כל הזמן ללכת לאמצע, ולפי זה להחליט. תגיד, אם...

274
01:40:31,500 --> 01:41:01,500
אם אתה לא מי שאני מחפש, אתה קטן או גדול ממי שאני מחפש. אם אתה גדול ממי שאני מחפש, אז אני יודע שאין לי מה להתעסק ממך והלאה, אני אסתכל רק על מי שמשמאלך. אם אתה קטן ממי שאני מחפש, אין בעיות, אני אסתכל רק על מי שמממך. אני אעשה את החצייה הזאת, ונתחיל את החיפוש שוב. אני אסתכל על התת רשימה הזאת, ונתחיל מהאמצע.

275
01:41:01,500 --> 01:41:31,500
השאלה בדיוק זה חיפוש בינארי זה חיפוש דרך אגב שאני לא יודע אם אתם רואים את זה אבל בגלל שכל פעם אני חוצה לחצי את הרשימה שאני מחפש כל פעם אז כל פעם אני מחפש בחצי מהאיברים ואז חצי מהאיברים כאילו, אני כל הזמן עושה חלקי שתיים חלקי שתיים חלקי שתיים מתישהו אני אנחת על מי שאני מחפש או שאני אנחת על אין תוצאות

276
01:41:31,500 --> 01:42:01,500
בכל מקרה, חיפוש בינארי הוא רץ בזמן של O של לוג n, לוג בסי 2n. זה מה שקורה. אז פה אתם רואים דוגמה לקוד בפייתון, שעושה בדיוק את מה שדיברתי עליו ועכשיו בעל פה, שכאילו, אני מתחיל את החיפוש הבינארי, מגדיר אינדקסים קצה שמאלי קצה ימני, וכל עוד שהקצוות שלי, כל עוד שהקצוות שלי הן נפרדים

277
01:42:01,500 --> 01:42:31,500
ממש שמאל קטן שווה ממש לראייט, אני אומר נתחיל להסתכל על האינדקס האמצעי ואז אמצע, כן? אתם רואים שמאל ועוד ימין חלקי שתיים ממוצע.אמצע, כן? אז אני אומר אם העבר באמצע גדול מהטארגט שלי, זאת אומרת אם, לא יודע, אתה גדול מהטארגט, אין בעיות, אז לפט, נשאר אותו לקט

278
01:42:31,500 --> 01:42:48,100
אבל רייט הוא מידל פחות אחד, פשוט. או הפוך אם האיבר באמצע קטן מהטארגט אז left הולך להיות, אם נהיה חאטה קטן מהטארגט אז left הולך להיות עכשיו מידל וורד 1.

279
01:42:48,100 --> 01:42:59,540
ואחרי שאני עושה את זה, הי פשוט חוזה חזרה לעלולת ווייל הזאת, ממשיך שוב, מסתכל על אינדקסים יותר ויותר צמודים אחד לשני. דרך אגב.

280
01:42:59,540 --> 01:43:07,500
מה שכתוב פה אלס, הוא אולי יכול היה להיות בהתחלה מבחינתי יעילות אבל לא משנה, כמובן שאם.

281
01:43:07,500 --> 01:43:18,860
מידל הוא בדיוק מי שחיפשנו, אם ליסט במידל שווה לטארגט אז זה בדיוק מי שחיפשנו, נחזיר אותו. ואין כל עלולת ווייל הזאתי כשל, אם יגענו למצב שבו.

282
01:43:18,860 --> 01:43:28,740
left ו right כבר עברו אחד את השני, זאת אומרת, עשינו חצי ועוד פעם חצי ועוד פעם חצי ולא מצאנו, אז נגיד מינוס 1 לא מצאנו.

283
01:43:28,740 --> 01:43:58,400
בקיצור, זה חיפוש בינארי, הוא יעיל, הוא רץ ב-O של לוג-אן וזה דרוש שהרשימה תהיי ממויינת, אחרת כל זה חסר פוינטה. אז פה דרך אגב, אתם רואים כאן בשקופיות את מה שדיברנו עליו במילים, אז אתם רואים לדוגמה, אנחנו רוצים ברשימה ממויינת לחפש את 6, נגדיר את left להיות אינדקס 0, right האינדקס האחרון.

284
01:43:58,400 --> 01:44:28,400
מידל פשוטה, אין ס Forbes של ביניהם, ונבדוק, מידל גדול משש, אין בעיות, אז נגיד שרייט שווה מידל פחות אחת, ואז נחשב מידל, נו אנחנו נעשה, נעגל את זה איפה שצריך, אל תדאגו גם עם המספר זוגי, אז נניח שמידל שלנו יש 3, 3 קטן, אז ניקח את left להיות מידל ועוד אחד, ואז נחשב ממוצע, זה יהיה או left או right כמובן, נניח שנחתנו על שש

285
01:44:28,400 --> 01:44:54,000
שואלים "האם אתה מה שחיפשנו?" כן, זה מה שרצינו. זה חיפוש בינארי, פשוט עושה חצי, חצי, חצי עד שמוצאים או לא מוצאים. זהו, על סיבוכיות זמן - ראיתם עכשיו - אנחנו מקטינים את מה שאנחנו מחפשים בו בפי שתיים כל פעם, חצי, חצי, חצי וכמה איטרציות?

286
01:44:54,000 --> 01:45:23,960
נניח שאנחנו נעשה פשוט חצי פעמים כל הזמן, עד שנסיים את זה עם כלום, זה לא בסי שתיים של אין. מבחינת סיבוכיות מקום, אתם ראיתם, העבודה שלנו עכשיו היא הייתה על אינדקסים, לא על הרשימה, רק אינדקסים, לא שינינו את המקום, אז בצורה הכי יעילה, או שלך, למה לא? אז כן, זה החישוב שאתם ראיתם, רשימה באוכהן.

287
01:45:23,960 --> 01:45:34,320
כל פעם מחלקים בשתיים, מחלקים בשתיים את מה שאנחנו מסתכלים עליו ומחלקים בשתיים עד שנסיים וזהו.

288
01:45:35,820 --> 01:45:41,380
וכן, הרשימה חייבת להיות ממויינת - אם היא לא הייתה ממויינת כל זה פשוט לא היה עובד.

289
01:45:43,480 --> 01:45:56,440
אוקיי, אז עכשיו יש לנו פה תרגיל מעניין, אנחנו נרצה להסתכל על מטריצה שנקרא לה מטריצה ממויינת נחש.

290
01:45:56,960 --> 01:46:09,760
מה זה מטריצה ממויינת נחש? תסתכלו כאן, יש לכם פה מטריצה שהשורה הראשונה שלה ממויינת כמו שאתם מצפים, ואז השורה באה בתור ממויינת הפוך, ואז השורה באה בתור ממויינת הפוך.

291
01:46:09,760 --> 01:46:39,480
ממויינת הפוך, ואז השורה באה בתור ממויינת רגיל, ואז הפוך, ואז רגיל. מה קורה פה? השורות באינדקסים הזוגיים, כלומר 0, 2, 4, ממויינות רגיל, משמאל לימין. השורות באינדקסים האי-זוגיים, 1, 3, הן ממויינות בסדר הפוך, אבל יותר חשוב מזה, העברים שבכל שורה, גדולים מהעברים שבשורה הקודמת אליהם.

292
01:46:39,480 --> 01:47:09,060
ואז אתם מתחילים לראות שעם כל התנאים האלה מתקיימים, מטריצה ממויית נחש היא פשוט מטריצה שהעברים שלהם ככה, משמאל לימין, אחר כך ימין לשמאל, אחר כך שמאל לימין, פשוט גדלים מונוטונית ככה. אתם רואים את זה כבר, אתם ראיתם גם את הדוגמה הזאת של משמאל לימין, ואז ימין לשמאל, ואז שוב שמאל לימין, ועולים ככה, עולים ככה, אתם ראיתם את זה מתישהו.

293
01:47:09,060 --> 01:47:39,040
זה הכוונה למטריצה ממויית נחש. עכשיו, מה השאלה בתרגיל הזה? מבקשים מאיתנו לכתוב פונקציה שתקבל מטריצה ממויית נחש, של מספרים שלמים, ואיזשהו מספר טארגט, ואנחנו צריכים למצוא את טארגט, במטריצה. עכשיו יש בעיה, המטריצה הזאת היא כנראה n על n, בסדר? ודורשים מאיתנו סיבוכיות זמן של לוגן.

294
01:47:39,040 --> 01:47:52,660
אז, וסיבלו לתת מקום של O של 1, אז בכלל, אז מה הקטע? הנה משהו שלא מספיק טוב, הנה הצעת פתרון שתעשה את זה מה שנקרא ברוט פורס.

295
01:47:52,660 --> 01:48:02,060
זה לא מספיק טוב, זה יהיה ב-O של N בריבוע, למה? יש לנו פה לולאת 4 בתוך לולאת 4.

296
01:48:02,060 --> 01:48:32,020
לכל שורה במטריצה, לכל ערך בכל שורה, אם הערך הוא טארגט, ריטרן טרופ. אבל פה, אנחנו כאילו עוברים על כל המטריצה, עוברים על כל ה-N בריבוע, לא טוב, זה לא מספיק טוב. אז מה כן מספיק טוב? אנחנו בדיוק למדנו על חיפוש בינארי, כזה שלוקח רשימה כלשהי, ופשוט...

297
01:48:32,020 --> 01:49:01,940
מחפש איבר ברשימה על ידי שהוא חוצה ל-2 כל פעם, הרשימה ממויינת, אז תסתכלו לרגע, תסתכלו, מה אנחנו תמיד יכולים להניח? כל שורה, אגב זה לא קשה לדעת אם אנחנו נמצאים בשורה שהיא זוגית או היא זוגית, ברמה של... איף מודולו, מה שזה לא יהיה, זה כלום. אז לכל שורה אנחנו כן יכולים להריץ...

298
01:49:01,940 --> 01:49:31,940
עליה חיפוש בינארי אתם יודעים מה עוד אנחנו יכולים להריץ? על העמודות, תראו כל עמודה ללא יוצא מן הכלל ממויינת, מ-קטן לגדול, אז אנחנו יכולים לעבוד עם זה, אנחנו יכולים לעשות פה קומבינציה של חיפוש בינארי על שורות או גם על עמודות, וכל עוד שנעשה מספר קבוע ב-o של אחד נפעיל חיפוש בינארי

299
01:49:31,940 --> 01:49:44,720
זה מספיק טוב, אם ככה זה מה שאנחנו נעשה, המטריצה הזאת היא בעצם מבחינתנו רשימה שהיא באורך קלט n בריבוע ואנחנו נרצה לעשות עליה חיפוש בינארי.

300
01:49:44,720 --> 01:49:55,640
והאתגר הוא לעשות את זה תוך כדי זה שאנחנו יודעים אם השורה שלנו איך היא ממויינת אנחנו יודעים לעבודה שלנו באינדקסים וזהו.

301
01:49:55,640 --> 01:50:24,980
אז דרך אגב תראו משהו, נניח שאנחנו רוצים לעשות את החיפוש הבינארי שלנו אבל הקלט שלנו לא n הוא n בריבוע זה לא בגדיל, אתם יודעים למה? חוקי לוגים, לוג של n בריבוע פשוט שווה ל2 כפול לוג n ואז מן הסתם שזה קבוע כפול לוג של n, אז זה all o של לוג n אז זה כן יעמוד בסיבוכיות. אז חיפוש בינארי זה התשובה. אוקיי, מה? בוא נעשה.

302
01:50:25,580 --> 01:50:34,540
אז נעשה משהו כזה, תסתכלו, לא מאוד מאוד קשה. נגדיל חיפוש בינארי אבל קצת יותר מתוסבך, אז ככה.

303
01:50:34,540 --> 01:50:44,660
קודם כל, אנחנו ניקח את המטריצה שלנו, נוציא מתוכה את ה-n, n שיהיה לנו נוח לעבוד איתו, מספר אשורות במטריצה, כן?

304
01:50:44,660 --> 01:50:54,400
n, הרי גם ככה הן עלנו לצאת מטריצה שהיא n בריבוע, אז נוציא מזה n, שזה לנגף של מטריקס, אתם זוכרים איך זה עובד ברשימות?

305
01:50:54,400 --> 01:51:24,400
ברשימות דו-ממדיות, נכון? זה בעצם רשימה שכל האיברים שלה זה רשימות ואיך פשוט תצאים את מספר הרשימות האלה? מספר השורות. אין, חוץ מזה נגדיר אינדקסים, left, right, אותו דבר, 0 ו-n בריבוע פחות 1, אז מהתחלה עד הסוף. ואז אותו דבר נכתוב את ה while שלנו. כל עוד של left קטן שווה ל right, כל עוד שלא הגענו לאותה נקודה בדיוק ו..

306
01:51:24,460 --> 01:51:48,640
מצאנו, לא מצאנו, נתחיל, נגדיר middle להיות פשוט האינדקס האמצעי. עכשיו אנחנו צריכים לכתוב קוד שמתחשב בעובדה שזאת נוטריצה ממוענט נחש, אז ככה, קודם כל אנחנו נרצה אינדקס שורה ואינדקס עמודה, אז מה אנחנו נעשה?

307
01:51:48,640 --> 01:52:18,620
אנחנו יכולים להגדיר שורה, נגיד שהmidל שלנו חלקי חלקי n, גם ככה מידל אנחנו הלכנו לאמצע המטריצה, ואם את זה אנחנו נחלק ב-n, כי אנחנו יודעים שבכל שורה יש בדיוק n איברים, אז נחלק את זה במספר האיברים שיש בכל שורה, נעשה חלוקה שמאיפה את השארית, נקבל את האינדקס שורה בדיוק, זה חלוקה שמתאימה לנו, חלוקה שתעיף את השארית.

308
01:52:18,620 --> 01:52:48,620
שארית, נקבל ממש את האינדקס שורה ועכשיו מבחינת אינדקס עמודה עוד יותר פשוט, אנחנו יודעים שבכל שורה יש n איברים, אז שארית החלוקה בn תבין לנו בדיוק את האינדקס העמודה שלנו, אתם מבינים למה כן? תסתכלו, אינדקס עמודה 0, אינדקס עמודה 1, אינדקס עמודה 2, 3, 4

309
01:52:48,620 --> 01:52:56,900
נעבור לאיבר הבא בתור, זה איבר כבר באינדקס חמש, אבל חמש מודולו חמש זה אפס, כי זה בעמודה אפס.

310
01:52:56,900 --> 01:53:02,540
שש מודולו חמש - אחד, שבע מודולו חמש - שתיים, אתם מבינים?

311
01:53:02,720 --> 01:53:17,860
זה לא, לא מאוד קשה להגיע לזה. בקיצור, חישבנו את האינדקס שורה האינדקס עמודה. עכשיו, נגיד, אם השורה היא איזוגית, זאת אומרת אם...

312
01:53:17,960 --> 01:53:47,940
אם אנחנו בשורה איזוגית, ובשורה איזוגית אנחנו יודעים שהמיון הוא הפוך, אנחנו נרצה להתחשב בזה. איך נעשה את זה? נעשה כזה דבר. אנחנו נגיד שהאינדקס עמודה שלנו כרגע הוא דווקא, הוא המשלים, זאת אומרת, m פחות 1 פחות עמודה נוכחית. אני יודע.

313
01:53:47,940 --> 01:54:16,120
זה נראה קצת מוזר, וכאילו, אם נניח אני הייתי על... השורה האיזוגית הזאת, אז הייתי אומר, איך למשלים שלך דווקא? ותשמעו, יש מצב שזה הגיוני יותר, כן? כי אנחנו בכל זאת רוצים לוודא שאנחנו עושים את הפליקה שלנו בצורה שהיא תשמור על המיון. אוקיי, בואו נראה אם אנחנו צריכים לעקוב, שומרים על המשלים.

314
01:54:16,120 --> 01:54:22,820
ועכשיו בעיקרון אנחנו נעשה את אותו הדבר בדיוק.

315
01:54:22,820 --> 01:54:28,100
איפ מטריקס ברוב גדול מטארגט קטן מטארגט כך וכך.

316
01:54:28,100 --> 01:54:44,780
עכשיו יכולתי לנסות להתעכב ולנסות להראות לכם שזה רץ פה ושם אבל להגיד לכם את האמת זה לא בדיוק המטרה של התרגול הזה לא להריץ פקודות אז אם אתם לא סומכים עלי שזה רץ אתם מוזמנים לקחת את הקוד הזה מהשקופית להביא אותו לפייתון.

317
01:54:44,780 --> 01:54:57,140
להביא אותו לפייתון לטפל בכל הרוג אסקי קרקטר שיופיעו לכם כי אתם תוכלו לעשות קופי פסט אבל אתם יודעים שזה יש פה קרקטר של פאופרפוינט שיעשו בעיות לא משנה.

318
01:54:57,140 --> 01:55:08,320
ותבדקו עבור עצמכם אם זה עובד אבל הרעיון הוא עדיין עשינו פה חיפוש בינארי על המטריצה ממויינת הזאת ממויינת נחש.

319
01:55:08,320 --> 01:55:13,160
חיפוש בינארי זה לוג של אין בריבוע שזה פשוט אוג של לוגן.

320
01:55:13,160 --> 01:55:42,960
מגניב יאללה בואו נסתכל על השאלה הבאה. אוקיי אז פה נותנים לנו דוגמה לאחת מהדוגמאות הבודדות של רשימות שהן כאילו ממויינות אבל לא סטנדרטית ועדיין חיפוש בינארי יעבוד עליהן אז תראו. אומרים לנו שרשימה מסובבת בגודל של n זאת רשימה שהיא ממויינת אבל אז עולה.

321
01:55:42,960 --> 01:56:12,920
אסור לה מה שנקרא אסור לרשימה הזאת מה שנקרא הזזה ציקלית זאת אומרת הרשימה היא בדרך כלל מה שאתם חושבים שהיא הייתה. זו הייתה רשימה של 1 2 3 4 5 אבל אסור לה הזזה ציקלית פעמיים ימינה מה זאת אומרת לקחו את כל הרשימה כל האיברים הביאו אותם שני צדים ימינה אז מה קרה ל 4 5 הם עברו שני צדים ימינה יצאו החוצה מהרשימה.

322
01:56:12,920 --> 01:56:42,920
פשוט תפסו את שני המקומות הראשוניםואז 1,2,3 נשארו פה מימין. אז מה הקטע ברשימה הזאת? היא ממויינת בסיבוב. זאת אומרת הרשימה הזאת, 4,5,1,2,3, היא הגרסה מסובבת פעמיים ימינה של הרשימה המקורית 1,2,3,4,5. אז מה הקטע? מבקשים מאיתנו לכתוב פונקציה שתקבל רשימה מסובבת ושהיא תדע להחזיר לנו

323
01:56:42,920 --> 01:57:12,920
את האיבר המינימלי ברשימה כזאת בלא גן, כלומר וריאציה שחיפוש בינאריה. אז מה אתם הייתם עושים? נניח שהיינו מקבלים כזאת רשימה, היינו מסתכלים עליה, היינו הולכים למדל שלה, הנה אני אכתוב את זה אפילו בנוטפלט, סתם, אוקיי, נגדיר כרגיל, נגדיר left, right, בלה בלה בלה, עכשיו נשאל. מי לעשות?יצא מהפכי שלך לעשות? נגדיר לבורקנים שלמה אנחנו צריכים להגיד לפי דרך המדל שלנו. מי שלך? מי שלך? תדרוך אותו בשבילך? מפשע שלך טיפולי במחיר מש

324
01:57:12,920 --> 01:57:28,920
מידל, אז ככה, מידל, האם אתה קטן ממי שנמצא לשמאלך?

325
01:57:28,920 --> 01:57:37,720
אם המידל הוא קטן ממי שנמצא לשמאלו, זאת אומרת, מצאנו את המינימום, נכון?

326
01:57:39,520 --> 01:58:09,020
אם לא, אז אנחנו יכולים לעשות שלא אחרת. אולי מידל, מי שנמצא בלי מנחה, האם הוא קטן ממך? תחשבו על זה. נניח שנחתי על חמש ואני שואל, חמש, האם מי שמעי מנחה קטן ממך? אם כן, אז זה שמי מנחה הוא מי שרצינו. ואם לא, אנחנו יכולים לעשות בדיקה כלשהי שתיתן לנו לבדוק את החצי הרלוונטי בשבילנו.

327
01:58:09,720 --> 01:58:38,920
אז הנה, תראו בעצם, אנחנו יכולים גם לעשות דברים, לעשות בדיקה אחרת. לא בהכרח להסתכל על מי שצמוד אלינו, אלא לעשות משהו אחר. להסתכל על האמצעי ואז להשוות את האמצעי לאחרון שלנו. אז לדוגמה, אנחנו יכולים להגיד שאם המידל שלנו הוא קטן מהאיבר האחרון לדוגמה, אז אנחנו יודעים שאין לנו...

328
01:58:38,920 --> 01:59:07,320
טעם בכלל להסתכל ימינה יותר, נכון? כי כל מה שנמצא ימינה זה רק עולה ואנחנו מפסידים את המינימום. או משהו אחר, אנחנו יכולים להגיד שאם האיבר האמצעי הוא גדול מהאיבר האחרון, זאת אומרת, אנחנו יודעים שבאיזושהי נקודה, אם נלך ימינה, מתישהו נגיע להתחלה של הרשימה המקורית ובעצם ניפול על המינימלי, אז לא נסתכל יותר על מי שנמצא משמאל.

329
01:59:07,320 --> 01:59:37,320
ולפי התובנות האלה, אנחנו נוכל בעצם לחלק את הסיפור הזה לחצי, אתם רואים? יש לנו אופציה ראשונה שאומרת אין טעם להמשיך ימינה, זאת אומרת נסתכל רק על החצי השמאלי, והאופציה השנייה אומרת מה שהיום מחפשים נמצא בחצי ימני, אז לא נלך לחצי השמאלי, ופה מגיע החיפוש בינרי, פה החלוקה לשתיים כל פעם, אז אנחנו נוכל בהתאם לבנות וריאציה חיפוש בינרי כזאת.

330
01:59:37,320 --> 02:00:07,320
אתם רואים? נגדיר left, נגדיר right. כל עוד שה-left ו-right הם שונים ממש, נבנה middle, ואז נעשה את השאלה הזאת, כן? הערך ב-middle לעומת את זה שברight? אם כן, כן, לא, לא, ובסופו של דבר, אנחנו נמצא את מי שאנחנו מחפשים. 01:15.597 והזהו. אז, כל הכבוד שצרכתם לעמוד בתרגול הארוך והמייגע הזה, אנחנו לא ממש התעסקנו פה בקוד פייתון,

331
02:00:07,320 --> 02:00:37,320
סטנדרטי, באמת מה שעניין אותנו כאן, דווקא היה ללמוד קונספטים תכנותיים, את הקונספטים של סיבוכיות, ממש סיבוכיות זמן, סיבוכיות מקום, וגם בסוף דיברנו קצת על חיפוש בינארי, שעד עכשיו לא ממש התעסקתם בהם רשימה ממוינת כן או לא, אבל כדאי שתדעו שזה מסוג הבעיות העקרוניות ביותר שיש בכל התחום הזה של מדעי המחשב. אז תודה רבה לכם!

332
02:00:37,320 --> 02:00:39,920
ונתראה שבוע הבא.

