1
00:00:00,000 --> 00:00:27,000
היי, ברוכים הבאים לתרגול השני של הקורס מבוא למדעי המחשב. הנושא שלנו השבוע מתחיל בהתעסקות קצת עם קלט ופלט בפייתון ואחר כך נמשיך להסתכל קצת יותר מקרוב על אופרטורים, על בוליאנים, על המרות ועל דברים שביניהם. אז בואו נתחיל.

2
00:00:27,000 --> 00:00:56,000
אם אתם אולי זוכרים מהשבוע הראשון, דיברנו קצת על איך שהשימוש שלנו במחשב מתחיל בקלט שלנו ובהרבה מובנים נגמר בפלט שאנחנו המשתמשים מקבלים. אז אילו כל מיני עיסוקים עם קלט ופלט אנחנו יכולים לראות בשפת תכנות כמו פייתון. אז תראו דוגמה קלאסית.

3
00:00:56,000 --> 00:01:15,000
נניח שאנחנו צריכים לכתוב שם בתוכנה פשוט, אז אנחנו יכולים לקבל פקודה כזאת שמשימה לתוך משתנה בשם name דרך הפקודה input את מה שנכתוב. אנחנו אפילו מקבלים פה טקסט פרומפט.

4
00:01:15,000 --> 00:01:38,440
please enter your name אז בערצת פקודה שכזו, אנחנו נקבל באמת את ההדפסה של הסטרינג שנמצא לנו כאן, של המחוזת כאן, ונוכל להתחיל לכתוב. סתם דוגמא נכתוב את השם אור אז נקליד אור גדולה במקלדת, נקליד אחר כך ער קטנה במקלדת.

5
00:01:39,880 --> 00:01:53,140
וסתם שאלה אתם מבינים באמת שמה שיכנס פה למשתנה name זה מחוזת? כי זה בעצם מה שאנחנו מקלידים רצף של תווים שישמר כמחוזת.

6
00:01:55,540 --> 00:02:03,180
עכשיו מן הסתם שבעולם הגדול שלנו אולי נרצה להזין יותר מקלט אחד.

7
00:02:04,000 --> 00:02:13,180
או אולי מה יקרה אם אנחנו נרצה לקחת את הפלט של התוכנית שלנו ולשמור אותו ולשלוח אותו לאנשהו.

8
00:02:13,180 --> 00:02:19,060
אז יש לנו אפשרויות לעשות כאלה דברים בשפות תכנות וגם ב-Python.

9
00:02:19,060 --> 00:02:27,320
אז לדוגמה, אנחנו נוכל לפתוח תוכנה כלשהי, שאני יכול ממש להראות לכם כרגע.

10
00:02:27,320 --> 00:02:33,740
יש לנו כאן סקריפט פייתון קצר מאוד, grid.py, והנה.

11
00:02:33,740 --> 00:02:45,000
הפקודה הראשונה שבדיוק ראיתם אותה כמה שקפים קודם לכן, ובה אנחנו מכניסים למשתננים את מה שזה לא יהיה שאנחנו נכתוב במקלבת.

12
00:02:45,000 --> 00:03:01,900
ואחרי זה אנחנו פשוט נדפיס, היי רווח השם עם סימן קריאה. פשוט מאוד. אז מה הקטע? אנחנו נוכל להריץ את פייתון, להריץ את הקוד הזה שבדיוק הראיתי לכם עכשיו.

13
00:03:01,900 --> 00:03:17,300
אבל במקום שאנחנו נקליט במקלדת, אנחנו ניקח טקסט שקיים בקובץ מסוים, והטקסט הזה הוא זה שייכנס לפקודת האינפוט שראיתם.

14
00:03:17,300 --> 00:03:34,800
כלומר, כאשר אנחנו נריץ את פייתון עם הקוד הזה grid.py אנחנו נכניס כאן בפקודת האינפוט הזאת את מה שזולה שנמצא בקובץ input.txt.

15
00:03:34,800 --> 00:04:04,100
יש שם שורת טקסט אחת וזה מה שייכנס כאן. איך ששורת הטקסט נגמרת שם זה גם מה שיחשב פה ככפתור הenter וזה מה שייכנס לשם. אז בואו באמת נראה שאכן עובדים עלינו input.txt כתוב פה לדוגמה את השם ניר ואנחנו נצפה אחרי הרצאה כזאת שבאמת ההדפסה שלנו תהיה ככה.

16
00:04:04,100 --> 00:04:32,200
אז הנה שלא תחשבו לרגע שמרמים אתכם בואו נריץ את הפקודה הזאת אז הנה אני אפתח כאן את הטרמינל המועדף עליי אפילו נעשה זומין קצת כדי שתוכלו להיות בנוחות. נריץ פייתון. עכשיו נכתוב grid.py חץ שמאלה שזה אומר אנחנו נרצה לעשות הכנסה.

17
00:04:33,000 --> 00:05:00,940
מלכתוב input נקודת טקסט. אממה טעות שלי אני פתחתי את זה בפאורשל לא לדאוג מה שכתבנו עכשיו זה נכון להריץ במשהו כמו קומנט פרומט אבל פאורשל רוצה לחטוף לנו את האופרטור הזה של input נקרא לזה ככה לא נורא.

18
00:05:00,940 --> 00:05:27,240
סתם רציתי להראות לכם את זה עכשיו בהקלטה כדי שלא תלחצו אם אתם מריצים את זה בפאורשל. אז נכתוב את זה בסינטקסט המאוד ספציפי של פאורשל עם get content ואני אומר לו תעסיק את הקונטנט שלך מ input נקודת טקסט. לתוך פייתון grid נקודה פאי. בבקשה.

19
00:05:27,240 --> 00:05:43,940
פליז אנטר יור נאם הייניר ממש ראיתם שאפילו לא היה פה מעבר שורה ורק כדי ממש להדגיש לכם שלא פספסתם דבר אני יכול ללכת פה לאינפוט נקודת טקסט אני אשנה את זה לשמיע פרטי.

20
00:05:43,940 --> 00:06:04,600
והפעם אני דווקא אפתח פה קומנט פרומט אני רוצה להראות לכם שמה שכתוב לכם פה אכן עובד אז אני אכתוב python grid נקודה פאי ורידרקט מהקובץ אינפוט נקודת טקסט בבקשה.

21
00:06:04,600 --> 00:06:19,100
פליז אנטר יור נאם היי אלון אז מה זאת אומרת רידרקשן הכוונה היא שיש לנו דרך בעצם להכווין מחדש קלט וגם פלט.

22
00:06:19,100 --> 00:06:32,040
שזה לא בהכרך לתוך הקומנט ליין אינטרפייס שלנו אז פה אנחנו הראינו דוגמה שבה אנחנו מביאים קלט מחוץ לקומנט ליין אינטרפייס.

23
00:06:32,040 --> 00:07:01,500
ולמעשה אנחנו יכולים גם להגיד שהפלט ילך למקום אחר אז בואו באמת נדגים את זה שוב נפתח כאן טרמינל שלנו בתיקייה ונגיד עכשיו משהו אחר נגיד python grid נקודה פאי את הפלט תוציא לקובץ אאוטפוט נקודת טקסט.

24
00:07:02,240 --> 00:07:31,060
עכשיו לכנסתי על אינטר והוא ממתין. למה הוא ממתין? אני אגיד לכם למה הוא ממתין הוא ממתין לאינפוט שלי. כן? כי הפקודה הזאת היא עדיין רצה זאת פקודת פייתון לכל דבר והיא מחכה שאני אביא לה איזשהו רצף של תווים ושאני אסיים אותו עם התו של מעבר שורה שזה מה שהכפתור אינטר תמיד נותן לנו. אז.

25
00:07:31,060 --> 00:08:01,060
האם יש לי משהו להביא לו? אני אביא לו... אני אכתוב על המקלדת: "אלון123", ועכשיו אני אכתוב אינטר. אוקיי! כשלחצתי על אינטר, הוא קיבל את הסוף שורה שלו, והוא לקח את השם הזה, והדפיס אותו. "פרינט האי נחום קריאה". אבל...

26
00:08:01,060 --> 00:08:17,520
זה לא הודפס לי פה בטרמינל שלי, למה? כי אני עשיתי לזה רידרקט החוצה לקובץ output נקודה טקסט, ושמה יהיו הדפסות מהקוד שזה אתה הרצנו. אז בוא נבדוק את output נקודה טקסט.

27
00:08:17,520 --> 00:08:46,900
פליז אנטר יור ניים, נקודה טיים, היי, אלון123, סימן קריאה, במילים אחרות, זה עבד בדיוק כפי שציפינו. ופה יצא לנו לראות את הרעיון הזה של ה-redirection. אז, וכמו שאתם אולי יכולים להניח, האמת אנחנו יכולים לעשות את זה גם redirection של ה input ואפילו גם redirection של ה output.

28
00:08:47,820 --> 00:09:37,553
תראו ביום יום לא ממש יצא לנו לעשות כזה דבר, אבל כדאי שתכירו יש דרכים באמת לשמור את הקלט לייבא אותו או לשמור על הפלט ולייצא אותו. אז אני מקווה שעכשיו אתם מודעים לזה. טוב בואו נעבור לדבר הבא. ומה עוד יש לנו למה המשתמש לא קיבל בקשת כלט? א...קברת השפעה במידע הזאת באופן קשוב. והמשתמש לא מקוהב להפתח את הלחיים שלו הרי מזמן טעות טובה שתחזיק אותו לגרום ןרגעים ולא לחשוב בטעות של דף בריאות שליזבף להתאים בחורדי הלטפו אופקסט יר

29
00:08:47,820 --> 00:09:09,560
תראו, ביומיום לא ממש יוצא לנו לעשות כזה דבר, אבל כדאי שתכירו, יש דרכים באמת לשמור את הקלט, לייבא אותו, או לשמור על הפלט ולייצא אותו. אז מקווה שעכשיו אתם מודעים לזה. טוב, בואו נעבור לדבר הבא.

30
00:09:11,020 --> 00:09:35,580
ומה עוד יש לנו? למה המשתמש לא קיבל בקשת קלט? כבר עברנו לזה, הבנו שההדפסות עברו לאאוטפוט נקודת טקסט. עכשיו, טיפה לגבי פורמט, אז הנה דוגמה של קוד, אנחנו מגדירים משתנה כלשהו Annual סלרי, דוחפים לו את הערך 100.

31
00:09:36,580 --> 00:09:46,320
נגדיר ש-per month זה אותו Annual סלרי חלקי 12, אז 100 חלקי 12.

32
00:09:46,860 --> 00:09:51,940
עכשיו, 100 חלקי 12 זה לא הולך לצאת לנו מספר שלם, כפי שאנחנו יכולים לדמיין.

33
00:09:52,620 --> 00:10:01,460
ופה יש לנו פקודת פרינט של you earn, ואז התוצאה של החלוקה הזאת, per month.

34
00:10:01,800 --> 00:10:15,700
למעשה, כשאתם רואים שכתוב פה f, זה באמת עניין של פורמט, כדי שנוכל לכלול את ההדפסה של המשתנה הזה, כאן באמצע הסטרינג שלנו.

35
00:10:17,200 --> 00:10:31,660
וכפי שאתם רואים, להריץ את זה, הדפיס לנו ככה, מספר ככה ממשי, עם הרבה הרבה ספרות אחרי הנקודה העשרונית. כי למה בעצם? למה?

36
00:10:31,900 --> 00:11:01,360
למה היינו צריכים עכשיו הדפסה של איזה 15 ספרות, למה שזה לא היה אחרי הנקודה העשרונית? לא קצת הרבה? ושאלת ככה, ספק טריוויאס, ספק משהו אחר, למה יש פה השלמה ל-4? היתם יכולים לקרוא לזה סוג של עיגול, סוג של משהו אחר, אבל אני מקווה שברור לכם שהכוונה היא 8 ושליש. זה הערך כאן. בכל מקרה. אנחנו כנראה נרצה קצת...

37
00:11:01,360 --> 00:11:10,080
לצמצם את הספרות אחרי נקודה עשרונית כשאנחנו מדפיסים לעצמנו מספרים שהם לא שלמים.

38
00:11:10,080 --> 00:11:28,380
אוקיי, איך נוכל באמת לפרמט הדפסה באופן זה? אנחנו נוכל להשתמש בסינטקס הזה, אז תראו, אנחנו עדיין משתמשים פה באות F לפני המחוזת שאותה אנחנו מדפיסים, זאת אומרת עדיין התעסקות עם פורמט.

39
00:11:28,380 --> 00:11:32,900
רק שפה אנחנו לוקחים את ה-per-month הזה,

40
00:11:32,900 --> 00:11:43,280
ואם הסינטקס הזה שאתם רואים כאן, per-month נקודתיים, ואז נקודה שתיים f. מה זאת אומרת הנקודה 2f?

41
00:11:43,280 --> 00:11:58,180
אפשר לחשוב על זה בתור, אכן נקודה עשרונית, רק שתי ספרות. כאשר f, הכוונה היא לפלוט. למה? כי סוג המשתנה שאנחנו אוהבים להשתמש בו במספרים ש...

42
00:11:58,180 --> 00:12:06,180
לא שלמים אלא ממשיים ופלוט אז למעשה אני רוצה אפילו להראות לכם ממש רוצה להראות לכם בזמן אמת.

43
00:12:07,020 --> 00:12:19,260
שהדבר הזה באמת עובד אז הנה בוא אני עכשיו אפתח פייתון פתחנו את פייתון אז בואו נתחיל להקליד משתנה annual salary.

44
00:12:19,900 --> 00:12:24,860
100. נגדיר את per month כמו שאמרנו מקודם.

45
00:12:25,220 --> 00:12:39,600
Annual salary עם אנדרסקור על הדרך ככה חכה שתיים הגדרנו אותו אז קודם כל בואו נראה את ההדפסה המקורית עם הפורמט.

46
00:12:40,480 --> 00:12:53,960
You earn ככה per month per month. אז זאת הייתה ההדפסה של הפלוט הממש ארוך שתורגם לסטרינג ככה.

47
00:12:53,960 --> 00:13:05,620
ועכשיו נדפיס את זה בתצורה השונה אז f עבור פורמט עכשיו you earn עם הסוגריים המסוסלות שלנו נגדיר.

48
00:13:05,620 --> 00:13:35,280
per month שיותפס רק עם שתי ספרות אחרי הנקודה העשרונית בתצורת פלוט. per month נסגור את הסטרינג נסגור את הסוגריים ואכן לא רימינו אתכם. you earn 8.33 per month. וככה באמת הצלחנו קצת לפרמט הדפסה של פלוט בצורה יותר נוחה. דרך אגב.

49
00:13:35,740 --> 00:14:04,020
הנה הוא משהו שאפשר לקרוא לו קצת עובדה טריוויה. האם ידעתם שיש פרמטר לפקודה פרינט שמאפשר לכם להחליט איך היא נגמרת? אז זה משהו שאפילו אני אישית לא ממש ידעתי. מתברר שפרינט לא חייבת לסיים את ההדפסה שלה במעבר שורה כפי שאתם רואים כאן ובאמת בואו נריץ לנו להמחשה.

50
00:14:04,020 --> 00:14:33,260
נריץ python print params.py. תראו מה קרה. יש לנו כאן הדפסה של הלו שורה ב world. ואז יש לנו פה הדפסה של הלו רווח World. אז אולי אתם חושבים ש... רימיתי אתכם, שפשוט עשיתי הדפסה כאן עם מעבר שורה או שתי הדפסות נפרדות וה-hello world כאן זה הדפסה אחת.

51
00:14:34,160 --> 00:15:02,460
למעשה, לא!?! אם אנחנו בפקודת פרינט נכתוב פסיק, ונוסיף כפרמטר אינד שווה משהו, אז מתברר שזה מחליף את התו שמודפס בסוף של פרינט. בדרך כלל, בסוף של פרינט, הדפולט הוא בעצם אינד שווה Backslash n מעבר ל 0.rations.

52
00:15:02,460 --> 00:15:32,460
מעבר שורה. אבל פה החלפנו אותו ברווח. ועל כן כשהרצנו את הפקודה הזאת, זה רק הדפיס רווח. ומיד אחרי זה הדפסנו את הפקודה פרינט וורלד. אז אני לא יודע מתי תמצאו בזה שימוש, אבל עכשיו אתם יודעים, אתם יכולים לפרק פקודות פרינט מבלי בהכרח לעבור שורה. אה, תרצי! איפה זה אנחנו...? אני מבוגר כי אני צריך עוד קונטקציה גרעינית ומשהו דומה לעבוד בפקודה מיוחדת את מלכן ב-

53
00:15:32,460 --> 00:16:02,460
תמיד אפשר ללמוד משהו חדש. אבל עכשיו, בואו דווקא נדבר על דברים יותר ישנים וקלאסיים. אופרטורים, חישובים מתמטיים. ובכן, אני לא חושב שאני בהכרך אפילו חייב להסביר לכם למה אנחנו צריכים אופרטורים מתמטיים בשפת תכנות. זה מתחת לבסיס של הבסיס. אנחנו צריכים את זה. אז אילו אופרטורים אנחנו נעבור כאן? בסדר גמור התקלט, זה בסדר גמור התמחוי עם החירות עשור לצרכים. ולא טוב. ואז אופרטורים אלה שאיננו צריכים מרדי פרסומת האימונים שהם מגיעו מאז המאה שנדי

54
00:16:02,460 --> 00:16:24,720
ה..ים המיידיים ביותר, אופרטור חיבור, חיסור, כפל, חילוק, אופרטור חזקה, שזה כוכבית אחרי כוכבית, לא בכך האופרטור שאתם תקבלו כשאתם תלחצו על שיפט 6, זאת אומרת, לא בכך זה, יש לזה משמעות קצת שונה.

55
00:16:24,720 --> 00:16:53,580
יש לנו גם אופרטור, מה שנקרא, פלור דוויז'ן, חלוקת רצפה, אופרטור שעושה חלוקה ומהגן אותה כלפי מטה, אנחנו יכולים להתייחס אליו בתור אופרטור של חלוקה ומשאיר רק את השלם, אבל עלול להיווצר בלבול קטן בגלל זה, אז זה למה נקרא לאופרטור הזה כפי שהוא, אופרטור חלוקת רצפה.

56
00:16:54,460 --> 00:17:02,260
וכמובן, אופרתור שארית, הרי לכל חלוקה יש שארית, יכולה להיות אפס, יכול להיות גם לא.

57
00:17:03,120 --> 00:17:18,640
מישהו אמר מודולו? אנחנו בנושא? אז בואו נסתכל על זה קצת, ונשים גם לב לטיפוס התוצאה של אופרטור בין שני ערכים.

58
00:17:18,640 --> 00:17:48,400
כי הרי פה זה חמש חלקי שתיים, וזה יחזיר לנו פלוט, כי אופרטור החלוקה זה, הוא יחזיר פלוט. אז בואו נחזור אחורה, וקצת נסתכל על עניין הסלרי, והחלוקה, והפר מונת שלנו, וקצת ננסה להבין את הניואנסים עם טיפוסי משתנים והתוצאה של אופרטורים.

59
00:17:48,400 --> 00:18:18,400
יש לנו כאן פקודה פשוטה, salary שווה תוצאת ה-input של מה שזה לא יהיה שם משתמש יחזירה ואז אנחנו נריץ פקודה, per month שווה salary חלקי 12 כמו שהיה לנו מקודם ולבסוף נפיס עכשיו השאלה, אם אנחנו נזין באמת עבור salary 24 מה היה הפלט? אתם יודעים משהו? יאללה בואו נבדוק, אז נפתח python as we do.

60
00:18:18,400 --> 00:18:48,400
השלרי = input של please enter annual salary. אוקיי, הוא מבקש ממני, אמרנו 24. אחלה. עכשיו אנחנו מריצים שפר מונף הולך להיות באמת השלרי חלקי 12 חודשים בשנה, או או, אנחנו בבעיה, Unsupported Operand Type.

61
00:18:48,400 --> 00:19:18,400
String מצד שמאל & אינט מצד ימין, רגע, סאלרי הוא סטרינג? למה? אה... בגלל שסאלרי זה הערך שקיבלנו מ input, אבל input מביא לנו סטרינג, מחוזת ולא מספר. והאופרטור חלוקה לא מוגדר כאשר אנחנו מביאים לו מחוזת, הוא מבין את הארגון המתואר של השער ולא מספר. והאופרטור חלוקה לא מוגדר כאשר אנחנו מביאים לו מחוזה... את.. את את האיום

62
00:19:18,400 --> 00:19:48,400
מספרים אז מה אנחנו עושים פה בעצם? איך אנחנו נתקן את הבעיה? אנחנו צריכים לעשות המראה. כלומר, אנחנו ניקח ערך מסוים ופשוט נמיר אותו בעזרת פקודת המראה מובנית בשפת התכנות שלנו לסוג משתנה שיעבוד בשבילינו. אז אצלנו,  actually

63
00:19:48,400 --> 00:20:05,400
אנחנו באמת ניקח כאינפוט את המשכורת השנתית שלנו, מספר, אני מקווה, ואז נפעיל עליו המראה, האינטג'ר של מה שזה לא יהיה שנמצא פה במחוזת.

64
00:20:05,400 --> 00:20:17,400
כלומר, עכשיו ראינו שהפר מונת שלנו לא עבד. אז מה שנוכל להגיד, סאלרי שווה...

65
00:20:17,400 --> 00:20:32,400
אינט של סאלרי, עכשיו שהרסתי את הדבר הזה, בואו נריס את הפקודה ממקודם, פר מונת שווה סאלרי חלקי 12. או, עכשיו זה עבד לנו.

66
00:20:32,400 --> 00:21:01,400
ואם עכשיו אני אכתוב באמת את פרינט f, you earn את הפר מונת שלנו בצורה מפורמטת. שוב, למה אנחנו כותבים f לפני המחוזת? כי ככה אנחנו יכולים לפרמט עם סוגריים מסוסלות, איזשהו משתנה, ככה, באמצע של מחוזת. זה סינטקס שכדאי להכיר מפקודה פרינט, יהיה לכם שימושי.

67
00:21:01,400 --> 00:21:30,400
ויאללה, בואו נדפיס מזה, אני מקווה מאוד שיתפיס לנו. היי! הוא התפיס מה שרצינו. חילקנו 24 ב-12 וקיבלנו 2. ואיך הצגנו את זה? על ידי זה שעשינו המרה, מסטרינג לאינטג'ר. ועכשיו אתם שואלים, רגע, אם עשינו המרה לאינטג'ר, אז למה הודפס לנו פה 2.0? אני רוצה להזכיר לכם, אופרטור החלוקה רגיל, ...

68
00:21:30,400 --> 00:21:43,060
ה dev

69
00:21:43,060 --> 00:21:48,240
אייתא מלמדה.

70
00:21:48,320 --> 00:21:52,880
הוא לא מספר שלם, אפילו שהערך הוא שלם.

71
00:21:54,560 --> 00:22:03,920
זה המצב שלנו. אז אנחנו יכולים לנצל את היכולת הזאת לעשות המראה על ידי לעשות כל מיני חישובים,

72
00:22:04,920 --> 00:22:33,840
שדרך אגב, החישובים האלה גם יכולים להפך, אנחנו יכולים להתעלם מהאלמנט הלא שלם של מספר שהוא פלוט, ובאמת להוציא ממנו רק את השלם. ממש דרך לעגל. לדוגמה, הנה חישוב ציון שאתם אולי כבר מכירים, או שתכירו במהלך הזמן שלכם בלימודים. ככה, סטודנט קיבל 90 בתרגילי בית, והם מהווים 10% מהציון הסופי שלו.

73
00:22:33,840 --> 00:23:02,920
ו-85 במבחן, שמאווה 90% מהציון שלו. ועכשיו הוא אומר לנו לחשב את הציון הסופי של הסטודנט, והוא צריך להיות מספר שלם. אוקיי, אז אנחנו יכולים באמת לעשות חישוב כזה. אז תראו, אנחנו ניקח את ה-90 שהסטודנט קיבל, בתרגילי בית, וניתן לזה משקל של 10%, כלומר עשירית, ואתם יודעים משהו, דיבור זה זול.

74
00:23:02,920 --> 00:23:32,680
אבל קוד, קוד זה משהו שעובד, אז בואו נכתוב את זה. 90 בתרגילי בית, כפול 10%, כלומר עשירית, ועוד 85 במבחן הסופי, כפול 0.9, זה 90%. עכשיו, מי שאחד, ומהר מאוד יודע לעשות את החשבון הזה, התוצאה של זה, היא למעשה הולכת להיות 85 וחצי. כן?

75
00:23:33,680 --> 00:24:02,320
אבל ציונים סופיים לצערנו, הם במספרים שלמים. אז אם אנחנו נרצה לראות את תצורת האינטג'ר של זה, את תצורת המספר השלם של זה, מה פייתון יעשה? הוא הולך לעגל את זה כלפי מעלה, לעגל את זה כלפי מתה? בואו נראה. אנחנו הולכים להדפיס, The Final Grade is, אנחנו נדפיס את גרסת האינט של גרייד.

76
00:24:02,320 --> 00:24:21,520
שמונים וחמש, אנלאקי, אין עיגול כלפי מעלה, מסכן, בכל מקרה קיבלנו את התשובה שלנו, אז ככה בעצם הצלחנו להוציא מספר שלם מתוך חישוב שהוא בפירוש מספר שאינו שלם.

77
00:24:23,500 --> 00:24:39,480
עכשיו, אנחנו לא באמת הולכים כל הזמן לעשות את האמרות שלנו בצורה ידנית, הרי תראו פקודה שכזאת, פרינט של 10 ועוד חמש וחצי, אז זה מספר שלם.

78
00:24:39,480 --> 00:24:52,640
וזה בפירוש לא מספר שלם, זה מספר שהוא פלוט, מה נקבל? אני אומר, בוא נחבר את זה. בתכנות, אנחנו עושים את זה בחיים, 10 ועוד חמש וחצי, מה נקבל?

79
00:24:52,720 --> 00:25:04,720
מה נקבל? אוקיי, זה לא היה מאוד מפתיע. 15 וחצי. אז זאת אומרת שהייתה לנו פה המראה אוטומטית לפלוט.

80
00:25:04,720 --> 00:25:22,340
וזאת אומרת, וזה יותר חשוב, מה שקורה לנו בהמרות אוטומטיות זה שאם אנחנו עושים פעולות, מחשבים ביטויים, כאשר חלק מזה, זה מה שנקרא משתנה.

81
00:25:22,340 --> 00:25:52,280
לא מאוד מייצג טווח מאוד רחב. אבל מצד אחר יש לנו משתנה שהוא כן, ב... נקרא לזה טווח רחב יותר של ערכים, משתנה כזה יותר כבד, אם תרצו לקרוא לזה. אז כל הסיפור הזה הופך להיות המראה, לסוג המשתנה הכי הכי כבד הכי דורשני. אז אינט ועוד פלוט, אז כל הסיפור חייב להיות פלוט, וזה מה שקראנו.

82
00:25:53,280 --> 00:26:21,880
אגב, אם כבר מדברים על טיפוסי משתנים מספרים, מה קשור בוליאן? בוליאן זה מספר? אז תראו, אתם זוכרים אולי בתרגול הראשון כשאמרתי לכם משהו לגבי מספרים מינאריים, ביטים, 0 ו-1, אחת מההקבלות שנתתי הייתה גם טרו או פולס. כי בתכנות, פולס זה בעצם מקביל ל-0.

83
00:26:21,880 --> 00:26:51,860
וטרו מקביל ל-1, ואפשר לעשות עם זה דברים. אבל לפני שנדגים באמת את הסיפור הזה, הנה הדפסה מעניינת, פרינט של 10 ועוד סטרינג של 5.5. מה אתם אומרים? האם אנחנו נקבל המראה אוטומטית פה? האם זה יתאפשר? בואו נבדוק. לא, כי איכשהו סטרינג קצת פחות משתף פעולה עם מספרים.

84
00:26:52,120 --> 00:26:54,000
ואנחנו גם ראינו את זה מקודם.

85
00:26:55,280 --> 00:26:59,040
אז בואו נהפס פה את העניינים ונמשיך הלאה.

86
00:26:59,440 --> 00:27:05,980
תזכרו, סטרינג לא משחק יפי עם מספרים, סטרינג זה סטרינג, זה תבעים.

87
00:27:07,180 --> 00:27:18,060
אה, עכשיו יש לנו קצת רגע של לראות אם אנחנו מבינים איך האופרטורים עובדים ביחד עם משתנים מסוגים שונים.

88
00:27:18,720 --> 00:27:21,700
טוב, פה אנחנו מדברים משתנים, לא.

89
00:27:21,700 --> 00:27:26,660
על קבועים, אבל עדיין, העניין הוא אופרטורים וטיפוסים.

90
00:27:27,940 --> 00:27:35,940
יש לנו פה כמה ביטויים, יש לנו פה שבע חלוקת רצפה שתיים, או True ועוד True.

91
00:27:37,460 --> 00:27:44,860
עכשיו השאלה היא, האם אתם מצליחים לנחש? מה יהיה טיפוס תוצאת הביטוי וגם הערך?

92
00:27:46,360 --> 00:27:50,860
בואו נראה אם אנחנו מצליחים לנחש את זה. אז הנה מה שאני אעשה.

93
00:27:51,620 --> 00:28:19,860
ניקח פה איזה נוטפד קטן. נסגור פה את הקודמים ונתחיל לחשב. אז יש לנו פה שבע פלור דיוויז'ן שתיים. בואו נראה. אנחנו יכולים לחשוב על זה ככה. שש חלקי שתיים נותן לנו שלוש. שבע חלקי שתיים. אז מה? היינו רוצים לכתוב פה...

94
00:28:19,860 --> 00:28:49,860
שלוש יש איזה שלוש להגיד שזה אינטגר. אז זה לא צריך להפתיע אותנו כן? זה פשוט חלוקה בלי שיירית אחלה. אנחנו יודעים מה אנחנו עושים מה עוד יש לנו שתיים חכי שתיים אז מספר חכי עצמו אמור לתת לנו אחד. נכון? כל אחד יודע. רגע, אופרטור חלוקה מפייתון. הדרך הזו היא שאתה צריך לחלוק אוקטור חלוקה בפייתון את זה אתה צריך להשוב שזה לא רק לאכוף בו אתה צריך לחלוק גם בו אתה צריך לגרום עצמך של איש שאתה ימלך של איש ...

95
00:28:49,860 --> 00:29:19,860
Float, אז אם כבר נכתוב 1.0 ונשים לב שזה  floating. הבא בתור. עכשיו 1 חלקי חלקי 2. אמרנו על זה שאופרטור חלקי חלקי זה 4Division, זאת אומרת חלוקה שלא בדיוק משמעיתה את השארית, אלא בפרט מעגלת את זה כלפי השלם 1 פחות.

96
00:29:19,860 --> 00:29:42,400
אז במקרה שלנו היינו אומרים שזה פשוט ייתן 0, זה צריך לתת לנו 0, ובפרט מגדירים לנו ה-float של זה, אז ה-float של זה פשוט יהיה לדעתי 0.0, ככה זה, אוקיי.

97
00:29:42,400 --> 00:30:11,620
עכשיו הנה משהו משעשע, מה זה true ועוד true? מה זה אמת ועוד אמת? יש רק אמת אחת בחיים, לא? טוב, זה כבר נושא פילוסופי, אני לא יודע כמה הוא מתאים למדעי המחשב, אבל מבחינתנו, נתייחס לאמת בתור משהו מספרי, אחד. ועכשיו מה? זוכרים שאמרנו משהו לגבי איך שעבודה עם ביטויים,

98
00:30:11,620 --> 00:30:31,160
ואופרטורים יכולה להגדיל מה שנקרא את התחום של הטיפוס של התוצאה. יש לנו כאן בוליין מצד אחד, יש לנו כאן בוליין מצד שני, אבל באמצע יש לנו אופרטור שמחזיר לכל הפחות אינטג'ר.

99
00:30:31,160 --> 00:30:45,060
במקרה שלנו אולי אני סתם מחרטט וזה פשוט 1 ועוד 1 שווה 2 זאת גם אופציה אבל היי, זה טוב לגשת לדברים האלו מכל הכיוונים האפשריים.

100
00:30:46,460 --> 00:31:00,220
פה יש לנו 7 כפול false. תראו אני יכול לנסות להגיד לכם בדיוק מה שאמרתי פה על true ועוד true או שאנחנו יכולים כבר להסיק שזה בעצם 7 כפול false.

101
00:31:00,220 --> 00:31:29,580
כי זה מה שאמרנו ש false, false זה 0 ועל כן התוצאה תהיה אינטג'ר של 0. ומכאן זה כבר משהו שאנחנו יכולים להסיק מסקנות לגביו, כן? אם true זה כביכול 1 ואנחנו מחברים אותו עם float אין לנו ברירה אלא לעשות 3.1 ועוד 1 שזה 4.1, float לחלוטין. יש לנו פה שלוש וחצי ועוד.

102
00:31:29,860 --> 00:31:58,620
האינטג'ר של ארבע וחצי ראינו מה קורה כאשר אנחנו עושים המראה ידנית של מספר ככה, float וחצי. אז אין לנו שום ספק אינט של ארבע וחצי הולך להיות ארבע. אז ארבע ועוד שלוש וחצי. התוצאה פה היא עדיין תהיה float. זה צריך להיות פשוט שבע וחצי אין ברירה. ופה אינט של אחד וחצי ועוד אינט של אחד וחצי.

103
00:31:59,380 --> 00:32:29,380
רבותיי אנחנו מחברים פה שני אינטים, אחד ועוד אחד שווה שתיים, אבולה, ודרך אגב, נניח שאתם לא מאמינים בכך, למה שאתם חושבים שהוא נכון, נניח שאתם רוצים לדעת רגע, אבל האם זה באמת ככה? טוב. בשביל זה, בדיוק עכשיו, כתבתי קוד פייתון טיפש לחלוטין, יש לנו כאן רשימה של הביטוחים שלנו ‫ליבוא בהסיבות שלנו בהשפעין לנו להקשק מתישהו.

104
00:32:29,380 --> 00:32:59,380
הביטויים כפי שהם כתובים במצגת, פה יש לנו העתק של הרשימה שזה פשוט הביטויים אבל בתור סטרינגים, למה? כי פה יש לנו כאן לולאת four, ואל תדאגו, אנחנו נדבר על לולאות טיפה יותר בהמשך אבל אני פשוט אומר לכם את זה עכשיו כי אתם ילדים גדולים ואני סומך עלכם שאתם מבינים, יש לנו פה פשוט לולאת four שעוברת במקביל על שתי הרשימות הללו, כל זה...

105
00:32:59,380 --> 00:33:18,380
נוכל להדפיס מחוזת נחמדה שהיא אומרת הביטוי ואז אנחנו בוחרים פשוט את הביטוי המתאים מהסוג ואז פה אנחנו ממש מדפיסים כמחוזת את הסוג של הביטוי של התוצאה שלו.

106
00:33:18,380 --> 00:33:28,700
וזה התוצאה עצמה סטרינג של התוצאה. טוב אם הקוד שראיתם כאן היה לכם קצת מוגזם זה בסרך דמור.

107
00:33:28,700 --> 00:33:44,880
בואו פשוט נריץ את הקוד עצמו, q1.5, אז הנה הביטוי 7 floor division 2 זה בעצם ביטוי שהוא מסוג של אינטג'ר והוא יחזיר לנו 3.

108
00:33:45,280 --> 00:33:54,880
או אולי אם אתם ראיתם את true ועוד 3.1, זה הולך להיות float וזה הולך להיות 4.1 וכן הלאה.

109
00:33:55,460 --> 00:34:25,140
אז יש לנו פה פשוט קוד שמחשב את זה ומראה לנו שאנחנו אכן לא התבלבלנו. מגניב, מגניב. ועכשיו יש לנו פה תרגיל שני שהוא מראה לנו דברים דומים וקצת שונים. אז בואו נסתכל על זה, נתחיל מהביטוי הראשון. יש לנו כאן 13.2, floor division עם מינוס 2. עכשיו אוקיי.

110
00:34:26,080 --> 00:34:55,060
זה קצת קשוח, זה קצת קשוח. תראו, בואו ננסה להסתכל על זה בצורה של מספר חיובי לרגע. אנחנו יודעים ש-13.2, פשוט חלקי ה-2, זה אמור לתת לנו אם אנחנו לא מבולבלים, 6.6. עד כאן סבבה? נניח. אז תכניסו פה מינוס איפשהו. יש לנו מינוס 6.6. עד כאן הכל טוב? נניח.

111
00:34:55,060 --> 00:35:24,200
אז יש לנו floor division. עכשיו תראו, זה float, ואני יודע שזה מבלבל למעשה, נוצר בלבול קטן בקרב המתרגלים, זמן קצר לפני הקלטה של התרגול הזה, אבל למעשה אופרטור floor division מבלבל ככל שהוא יהיה. אם יש לנו פה float באחד מהאופרנטים, התוצאה הולכת להיות float.

112
00:35:25,080 --> 00:35:38,020
אפילו שאנחנו כביכול עושים עיגול כלפי השלם כלפי מטה, למעשה התוצאה הולכת להיות בדיוק מינוס שבע נקודה אפס, פלואוט.

113
00:35:39,520 --> 00:35:50,460
זה פלואוט דיוויז'ין של פייתון, נעים להכיר, כמה תשתמשו בו? אין לי מושג, אבל הכרתם אותו, יאללה בואו נמשיך.

114
00:35:51,160 --> 00:36:19,760
אתם יודעים משהו? אם אני כבר כתבתי בקוד גם את q2, אותו דבר עם הביטויים האלה, אני רוצה להריץ את זה, ואני רוצה שפייתון יגיד לי מה התוצאות של כל אחד. אז בואו ננקה, נעשה כזה זום-אין ככה בגדול, ונקווה שנצליח להסתיר. q2, רגע רגע רגע רגע. אוקיי.

115
00:36:19,760 --> 00:36:29,420
עכשיו נרחיב את זה טיפה, סבבה, כן? אפשר לזרום על זה, נכון? אני מאמין.

116
00:36:29,420 --> 00:36:45,220
אז אמרנו שה- expression 13.2  flow division מינוס 2 יחזיר float מהצורה מינוס 7.0. עכשיו יש לנו את ה-expression הבא בתור ה-integer של 7 חלקי 2.

117
00:36:45,220 --> 00:37:08,120
עכשיו אנחנו יודעים ש-7 חלקי 2 הולך להחזיר 3.5 float, אבל אמרנו אינטגר של זה, אז האינטגר של 3.5 יהיה חייב להיות 3 אינטגר. ככה, פשוט, לא יודע אם זה עיגול כלפי מטה, לא יודע אם זה סתם אובדן של נקודה עשרונית, אנחנו לא ראינו את זה, אנחנו ראינו פה רק דוגמאות של נקודה 5.

118
00:37:08,120 --> 00:37:13,860
אתם רוצים לדעת מה קורה כשיש לכם נקודה 4 או נקודה שיש? אתם מוזמנים לבדוק ולהריץ.

119
00:37:14,860 --> 00:37:42,200
מה הדוגמא הבאה? בואו נראה. יש לנו כאן, הופה, טוב, ראיתם את זה כבר, אז האינטגר של מינוס 7 חלקי 2, אין פה יותר מדי מה להסתיר מכם. אז מה, מינוס 3.5? ועכשיו אנחנו עושים את האינטגר של זה? אז בואו נראה מה הוא מחליט לעשות. טוב, הוא פשוט מחליט לאבד את מה שנקודה עשרונית והלאה, אז זה הולך להיות מינוס 3.

120
00:37:42,200 --> 00:38:10,120
דרך אגב, sanity-check, מה שכתוב בשקופית, לפחות עוקב אחרי מה שפייתון אומר שזה נכון, כן? וגם הקוד בפייתון, שלא חס וחלילה תתבלבלו. מה הקוד בפייתון, פה ברשימה, יש פשוט את הביטוי האלה, As is, ומה שמודפס פה, בנקודת הפרינט, זה פשוט הריזולף עצמו, זה פשוט מה שיש פה, פייתון כבר עושה לזה ריזולף לתוך מה שזה שווה.

121
00:38:10,120 --> 00:38:32,880
ואני רק מדפיס את הסטרינג של זה כדי שאפשר להדפיס את זה. דרך אגב, אם השורת פרינט הזאת נראית לכם קצת מסורבלת, אתם כנראה צודקים. שורת פרינט הזאת נכתבה על ידי מישהו שלא בא לו בטבעי לכתוב בצורה מפורמטת כמו שצריך עם F לפני המערכות, ואז הסוגיה מסוסלות.

122
00:38:32,880 --> 00:38:41,180
אז כדאי מאוד שאתם תהיו תכנתים יותר טובים בפייתון מאשר מי שכתב את הקוד הזה במהירות.

123
00:38:42,380 --> 00:38:45,580
טוב, נעבור לדוגמה הבאה.

124
00:38:45,580 --> 00:38:58,740
או, ראונד. אז בסדר, לעגל, מה אנחנו הולכים לעגל? 8 חלקי 3. למה זה התעגל? אנחנו תוהים.

125
00:38:58,740 --> 00:39:22,740
מישהו קודם כל זוכר בעל פה מה זה 8 חלקי 3? אנחנו יודעים ש-8 חלקי 4 זה 2. 8 חלקי 2 זה 4. אז 8 חלקי 3 צריך לנוע איפשהו בדרך. ואם אנחנו נשאלת פייתון, מה זה שווה? פייתון הולך להגיל את זה לשלוש. מי היה מאמין?

126
00:39:22,740 --> 00:39:38,740
זה עיגול, אם אני לא טועה, כלפי מעלה. כי הרי אנחנו יודעים בתכלס של 3 כפול 3 זה 9. כן, אנחנו בחשבון של בית ספר יסודי, אבל זה טוב, זה טוב.

127
00:39:38,740 --> 00:39:52,240
מן הסתם שזה יוצא לנו 2 נקודה משהו, בואו נראה. 2 כפול 3 זה 6. אז אם אנחנו עושים 2 ו2 שליש, ואת כל זה נחפיל.

128
00:39:52,240 --> 00:40:22,240
בשלוש, סביר, נאח שנגיע לשמונה. בקיצור, ראונד אפ. ככה זה. עכשיו מה יש לנו פה? אנחנו אומרים, float של הסטרינג חמש וחצי, כלומר, בכך אנחנו הפכנו את הסטרינג הזה, לבאמת חמש וחצי, ופה אנחנו עושים ראונד. אז אם הניחוש שלנו שראונד, זה בעצם ראונד אפ, לדעתי זה אמור לתת לנו שש.אותה אינטג'ר שש. שש.האינטג'ר שש..

129
00:40:22,240 --> 00:40:46,340
יפה, אנחנו יודעים חשבון בסיסי, זה טוב. מה עוד יש לנו? רגע, בואו ננסה להסתיר את זה, אז ככה, 7 מודולו 2, מה שריט החלוקה של 7 ב-2? טוב, 7 זה מספר אזוגי, אז אנחנו פשוט הולכים לקבל אינטגר שהוא 1, אני לא יכול להסתיר את זה, סורי.

130
00:40:46,340 --> 00:41:15,240
נשאר לנו עוד משהו? כן, כן, שריט החלוקה של 9.9 ב-2, איך זה הולך? מה אנחנו מצפים למצוא פה? אני הייתי אומר, זה יכול לתת לנו בעצם אולי 1.9? אז אם אנחנו ניתן את זה לפייתון, פייתון יגיד לנו, כן, זה 1.9?

131
00:41:15,240 --> 00:41:24,620
הרבה מאוד אפסים ועוד 4 איפשהו על הדרך למה טוב פה אנחנו כבר לחלוטין נכנסים לאיך שפייתון מחשב.

132
00:41:24,620 --> 00:41:30,440
מספרים ממשיים וכמה שפחות שיאמר יותר טוב.

133
00:41:31,060 --> 00:41:37,080
מה עוד יש לנו להסתכל כאן או תראו ביטוי מעניין.

134
00:41:37,080 --> 00:41:43,540
הביטוי הסטרינג py כפול 3.

135
00:41:44,020 --> 00:41:57,840
אז מתברר שפייתון יודע להבין את זה הוא יודע לחשב את זה בתור סטרינג ולמעשה הוא יודע לחשב את זה בתור שירשור של הסטרינג עם עצמו שלוש פעמים.

136
00:41:57,840 --> 00:42:07,340
זה קטע חביב. טוב ופה אנחנו בעצם פתרנו את שאלה 2. אז מה שאתם רואים פה זה מה שראינו בפייתון.

137
00:42:07,340 --> 00:42:12,820
אז כן אנחנו יכולים לשרשר מחוזות.

138
00:42:12,820 --> 00:42:42,200
למעשה אולי אתם כבר ראיתם את זה כשניסינו לעשות פקודות פרינט ממש פשוטות עם מחוזת ועוד ערך של משתנה ועוד מחוזת. אז בעצם מה שאנחנו עשינו שם לקחנו מחוזת עשינו פשוט פלוס עוד משהו. זאת אומרת עוד מחוזת. יכול לשרשר מחוזות ועכשיו אתם רואים שאם האופרטור כפול אנחנו יכולים לקחת מחוזת מסוימת ולשרשר אותך עם עצמה מספר מסוים של פעמים.

139
00:42:42,200 --> 00:43:11,860
אז אפשר לחשוב על זה בתור טריוויה או שאולי אפשר למצוא לזה שימוש. עכשיו בואו קצת נעזר בידע שלנו של לפרמט טקסט וננסה קצת לשחק עם זה. אז פה אנחנו מתבקשים לכתוב תוכנית שקולטת מהמשתמש את האורך של שתי צלעות במשולש ישר זווית, כלומר לקלוט פרפנדק'ק'ק'ואלר אחד ואת הפרפנדק'ק'ק'ואלר השני.

140
00:43:12,280 --> 00:43:41,120
ומה שהתוכנית תעשה, היא פשוט תעזר במשפט פיתגורס והיא תחשב את אורך היתר עד כדי שתי ספרות אחרי הנקודה העשרונית. אוקיי, אז מה אנחנו נעשה פה? מה נוכל להעסיק? פשוט נכתוב קוד. אז בגלל שזה תרגול מוקלט מראש, אני פשוט אלך.

141
00:43:41,120 --> 00:44:10,240
להסתכל על ההקלדה מראש של הקוד הזה. אז בואו נסתכל, זה לא אמור להיות יותר מני מסובך. אנחנו פשוט נשים לתוך שני משתנים A ו-B את מה שאנחנו מתבקשים. יש לנו פה אינפוט, Enter first perpendicular, Enter second perpendicular, ופה אנחנו הופכים אותם לגרסת הפלוט שלהם. ובסוף אנחנו מפעילים את משפט פיתגורס.

142
00:44:10,240 --> 00:44:39,700
A בריבוע ועוד B בריבוע, שורש שלהם זה בעצם אורך היתר. ואז אנחנו נדפיס בצורה מפורמטת של עד שתי נקודות אחרי, זאת אומרת שתי ספרות אחרי הנקודה העשרונית וזה מה שייצא לנו. עכשיו תראו, אנחנו פה עשינו את ההמרה אחר כך. אבל מה אם סניקי סניקי?

143
00:44:39,700 --> 00:45:08,420
אני פשוט אקיף את כל הסיפור הזה בסוגריים. פלוט של כל מה שהיה פה. וגם פה, פלוט של כל מה שהיה פה. מי יגיד לי לא? נע, בואו נעריץ את זה. אני ממש רוצה לדעת מה נקבל. פייתון, אני רואה שקצת פאו שנאבק לפעמים כשעושים פה זומים כבדים.

144
00:45:08,420 --> 00:45:37,140
סבבה. פייתון, q3 נקודה פייפ. אינטרפוס פמפדקילר, אתם זוכרים את 3, 4 ו-5? בואו נעריץ אותם. 3, והצלע השנייה, 4. וההיפוטניוסיס 5, יפה. בואו נעריץ את זה שוב. הפעם נגיד לו כזה אורכי צלעות קשוחים. 8.

145
00:45:37,140 --> 00:45:53,740
10, 12.81, האם אתם משוכנעים שזה עבד, אני משוכנע שזה עבד, יפה. אז ראינו דוגמה, מגניב, והפתרון הוא מה שראינו עכשיו.

146
00:45:55,540 --> 00:46:06,240
אז בואו נחזור רחוק קצת ונסתכל קצת על הבוליינים שהתעסקנו איתם מקודם, אתם זוכרים? כל הטרו והפוסט למיניהם?

147
00:46:06,240 --> 00:46:36,240
אז בואו נראה אילו עיסוקים אנחנו יכולים לעשות איתם. אז, כמו שכבר אמרתי לכם יותר מפעם אחת. תחוז זה 1 ופולס זה 0, אז מה קורה כשאנחנו מנסים להמיר ערך כלשהו שהוא לא 0 או 1 לבוליין? אז, אנחנו יכולים לנחש, או שאנחנו יכולים ישירות לעשות, נפתח את זה חזירה וא׶בחאזב לעבודה. כמעיין, הקשרים שלו יש לי שנקודה על נפתח הגעת הרכבת כשר הוחבא, על שכלשהו שתהיה חזיר בשלך. fcx היעקב זמן כי שארת לאצלם בשטר הם פשעה שצר יתאהב. פשעם את זה לגמרי השעבר

148
00:46:36,240 --> 00:47:06,240
ונריץ בוליין, המראה בוליינית לעשר. טרו, אז כן, זה מחזיר לנו טרו. ולמעשה, איך זה עובד בבוליינים? הערך הבוליאני, שכל דבר שהוא לא ריק, זה פשוט טרו. אז אנחנו יכולים לקחת חמש, שלוש, נקודה אחת. היה, למה אני מדבר? בוא נראה לכם! מה הבוליין של חתוך? שהוא פשוט כל רך וכל מרחק. או מעשהם המהירים של בפרשת בבוליינים. אסור לחשוב ממה חתוך בבוליינים. בגלל הרעיונות זה הזמן לשבת לפרנסה, בגלל גרעינו לא לצטורף ובהפחד לחיפה

149
00:47:06,240 --> 00:47:21,620
זה true, מה הבוליאן של float כלשהו, true, כל שהו לא אפס, מה הבוליאן של please stop rambling we beg you, זה גם true.

150
00:47:24,600 --> 00:47:53,880
טוב, הבוליאן של מחוז הטריקה מצד שני זה כבר false, הבוליאן של אפס, אתם כבר יודעים שזה false. ובכן, עכשיו, הייתי רוצה שתכירו, וזה משהו שכן יהיה לכם שימושי בעתיד כמתכנתים, שערך כלשהו שהוא לא רק, זה true, וערך שהוא רק, או אפס לחלוטין, זה false.

151
00:47:53,880 --> 00:48:22,800
מתישהו, אני מבטיח לכם, זה יהיה לכם שימושי בתכנות שלכם, אולי אפילו כבר בקורס הזה. עכשיו, בואו באמת נראה שאנחנו יודעים איך הבוליאניות של דברים עובדים. עכשיו, לפי מה שאמרתי לכם עכשיו, זה לא אמור להיות לכם קשה להעסיק, אז בואו ניקח את הנאות פדר הגיל שלנו, ונענה על זה. מה זה הבוליאן של אחד? זה קלאסית true.

152
00:48:23,600 --> 00:48:53,600
מה זה הבוליינט של -14? אתה לא ריק אדוני, לכן אתה גם טרו. עכשיו, הפלואוט של הסטרינג של 0, זה באמת 0.0. והבוליינט של ערך שהוא שווה ל-0, זה פולס. זה באמת ההגדרה של פולס. בוליינט של תבריק, פולס. בוליינט של מכרוזת ריקה, פולס. עכשיו, הבוליינט של 1 זה טרו.

153
00:48:53,600 --> 00:49:05,340
סטרינג של זה זה המחוזת True. אוקיי, בוליאנט של 0 זה False, האינט של False זה פשוט 0 באינטג'ר.

154
00:49:05,340 --> 00:49:23,360
ואני באמת רוצה להראות לכם שכל מה שנאמר כרגע הוא נכון, להללן q4.pi שזה כמו שראיתם מקודם הקלדה מאוד מטופשת לרשימות של מה שעברנו עליהם בגרסת סטרינג ובגרסה האמיתית.

155
00:49:23,360 --> 00:49:36,960
ואז הדפסה מסודרת שורות שורה, אז בואו נריץ את זה. אוקיי, Ctrl+Z נסגור את פייתון, CLS לנקות פה, פייתון q4.pi, let's go.

156
00:49:36,960 --> 00:49:52,700
ומה אנחנו רואים כאן גבירותיי ורבותיי? בדיוק את מה שראינו שם בטבלה. יש לנו כאן את הביטויים למה הם מתורגמים, והנה את פה אתם רואים ממש בסוף, str של בוליאן, לא מפתיע זה סטרינג.

157
00:49:52,700 --> 00:50:22,700
או אינטג'ר של בוליין, זה אינטג'ר, ראינו ונוכחנו זה נכון. עכשיו יש דברים שאנחנו יכולים לעשות עם אופרטורים, שמשק העיריון השימושיים, אני חייב להגיד, סוף סוף משהו שהוא טיפה שימושי, תנאים אבל באופרטורים. לדוגמה סטודנט צריך לגבל לפחות...

158
00:50:22,700 --> 00:50:52,700
כדי לעבור במבחן. אז איך אנחנו נבדוק האם הוא עבר? לפני שאנחנו נשתמש בביטויים של f וכולי, זה שמור לשבועות טיפה יותר מתקדמים. פה אנחנו יכולים לראות שכבר באופרטורים, כביכול מתמטיים לחלוטין, יש לנו דרך למצוא את זה. אז לדוגמה, נניח שהציון הוא 56 ואנחנו מגדירים במשתנה, הבן אדם עבר?

159
00:50:52,700 --> 00:51:15,720
כן או לא, וזה נקבע לפי אם הציון שלו גדול שווה ל-55. זאת אומרת, אופרטור השוואה והתוצאה שלו היא תחזיר ערך בוליאני, אז בואו באמת נכתוב את הקוד הזה, העימו עבר, אז יאללה.

160
00:51:15,720 --> 00:51:27,100
אני לא יודע מאתכם, אני עכשיו מתרגש לפתוח פייתון בפעם הלא יודע כמה ולגלות האם הבן אדם עבר עם הציון 56.

161
00:51:27,100 --> 00:51:44,880
לצגו, פייתון. עכשיו נזין את מה שצריך, x שווה 56, בסדר? עכשיו נגדיר למשתנה פסט את הערך הבוליאני, x,

162
00:51:44,880 --> 00:51:50,020
האם הוא גדול שווה ל 55? OK.

163
00:51:50,020 --> 00:51:55,480
Did he pass? בתשובה הית True, אכן עבר.

164
00:51:55,480 --> 00:52:01,780
ועכשיו כמובן, אני יכול להגיד ש-x שווה ל-40.

165
00:52:01,780 --> 00:52:06,780
סתם שאלה, בואו נעשה ניסוי. שינינו פה את x, לא שינינו את paste.

166
00:52:06,780 --> 00:52:12,640
איך paste מסתכל? האם הוא פשוט קיבל את הערך ממקודם? כן.

167
00:52:12,640 --> 00:52:41,780
אבל עכשיו אני אעדכן, paste שווה ל-x גדול שווה ל-55, ועכשיו paste יהיה False. טוב לדעת? טוב לדעת? אז בבקשה, אופרטור השוואה, נותן לנו איך בוליאני. ובאמת בואו נסתכל על אופרטורים השוואתיים כאלה. עכשיו, אלו דברים שאתם תשתמשו בהם בתכנות כל הזמן. דבר ראשון, אתם רוצים להשוות פשוט. א' שווה לב' כן או לא?

168
00:52:41,780 --> 00:53:06,000
אז מה שאנחנו עושים, זה לכתוב פעמיים שווה, וזה חשוב. פעמיים שווה. למה? כי פעם אחת שווה, בכמעט כל שפת תכנות מודרנית שאתם יכולים לדמיין, לכתוב פעם אחת שווה, זה להגיד: המשתנה שנמצא משמאל, מקבל ערך חדש, והוא, מה שזה לא יהיה שנמצא מימין.

169
00:53:06,000 --> 00:53:35,900
אבל לכתוב פעמיים שווה, זה באמת האופרטור בוליאני קלאסי שמשווה את הערכים שלהם. ועכשיו, אתם יכולים לראות גם את האופרטורים המתבקשים. כמו שיש שאלה, האם A שווה ל-B, יש לנו גם האם A שונה מ-B, האם A גדול ממש מ-B, קטן ממש מ-B, גדול שווה ל-B, או קטן שווה ל-B. אז אלו אופרטורים שצריכים להיות לכם הגיוניים.

170
00:53:35,900 --> 00:53:39,880
ודי מובנים, בלי יותר מדי סימני שאלה בראש.

171
00:53:41,680 --> 00:53:48,780
אז סתם דוגמא, בואו ניקח באמת x שווה 56.

172
00:53:49,640 --> 00:54:02,200
ועכשיו אנחנו רוצים להדפיס האם x שווה 55, כלומר זה אמור לתת לנו true או false, אז אנחנו נכתוב print x שווה 50, רק רגע.

173
00:54:03,220 --> 00:54:09,580
לא אמרנו בדיוק שאופרטור השוואה זה שני שווה רבותיי אנחנו נקבע פה שגיאה זה לא ילך.

174
00:54:10,480 --> 00:54:30,960
עכשיו פרינט מתלונן got an unexpected keyword argument x כי הוא קיבל את x והוא זה לא פרמטר מה הוא אמור לעשות עם זה אוקיי אז בואו נקיף את זה בסוגריים אולי זה יעזור לנו עכשיו אנחנו בהכרח אומרים לו חביבי זה הולך להיות ביטוי תחשב אותו.

175
00:54:32,140 --> 00:54:42,580
לא כי עכשיו יש לנו בעיה בסינטקס עכשיו סוף סוף פייתון יכול להתפנות להגיד לנו אתה לא משווה עם שווה אתה משווה עם שווה שווה.

176
00:54:44,080 --> 00:54:47,060
יש אני משווה עם שווה שווה.

177
00:54:48,180 --> 00:55:01,940
ועכשיו התשובה היא false כי הגדרנו את x שווה 56 מקודם. by the way האם אני יכול להגיד x שווה שווה 55 בלי להיות זוג של סוגריים? כן עכשיו הוא הבין אותי.

178
00:55:02,520 --> 00:55:31,080
קוו. אז מה אם אנחנו נרצה לקחת את האופרטום בוליאנים האלה ופשוט ככה לשרשר אותם ולקבל תנאים מתקדמים נניח יותר מתנאי אחד כלומר נרצה לבדוק אם התלמיד עבר שזאת אומרת גדול שווה 55 אבל גם קיבל קטן מ-80. או אולי האם הוא קיבל יותר מ-90 או פחות מ-20.

179
00:55:31,080 --> 00:56:01,080
אנחנו רוצים עכשיו יותר מתנאי אחד ואנחנו רוצים לנצל את זה. כי תשמעו אני לא יודע אם אתם יודעים אבל עולם התכנות הוא בהרבה מקרים רצף של תנאים ותנאים ספציפיים ותנאים על גבי תנאים, ואת תנאי אחד לא נפגש אז אולי תנאי אחר. באמת יהיה לנו לפחות שבוע שיהיה מוקדש לתנאים ושם, יצא לך להרים את האור שלך להראות דעת הכללי חוץ שלך להכיר אותך לא רק בהתמודדי מזמן. אתה צריך להכיר אותך בזמן אתה צריך להתמודדי בגדרך יכול להיות באור כי אתה צריך להכיר אותך כי אתה צריך להכיר אותך בג

180
00:56:01,080 --> 00:56:31,080
יתראו Iouting וכל מיני. אבל היי, אנחנו יכולים לעשות תנאים כרגע, פשוט גם עם אופרטורים בוליאניים, וזה עובד. אז בואו נבדוק את זה. כמובן, עם היכולת לשרשר אותם, עם And ו-or. ככה דברים לוגיים כאלה. מה זה בעצם אופרטורים הלוגיים האלה של or, And ו-not? זה לא אמור להיות יותר מדי קשה להבין, גם אם זו הפעם הראשונה שלכם.
אזבר את זה לך, אתה מצריך לבוא איפה אנחנו רוצים לטפל וזה לא הופיט מישהו מצריך בטפלי וגם לא בלעוזרת שלנו על החוק! שו ערך אליו, שתמשיך לעבוד

181
00:56:31,080 --> 00:57:01,080
בעיקרון, אנחנו יכולים לקחת ביטוי כלשהו שהוא אמת או שקר ולהגיד א' או ב' והתוצאה היא כל עוד שלפחות א' או ב' הוא נכון, אז התוצאה בסך הכל תהיה נכון. צריך ששניהם יהיו לא נכון, כדי שהתוצאה תהיה גם לא נכון. עכשיו מנגד, למרשה של מה שקרה, המנהיג של מרובים שיקרה גם קצת שיחודית וניגד אותו מרובים של מה שהוא אתה וצפון. מלכתחילה להירת קטט בססמכם פשר גרועים שאינם שתעשה לפי מיום בדעתו שאלה תתמוך את זה כשאתה ואתה רוצה

182
00:57:01,080 --> 00:57:14,480
את and שזה וגם וגם דורש ששני הצדדים יהיו נכונים כדי לקבל נכון. אם מישהו מהם לא נכון, אז לחלוטין לא נכון.

183
00:57:15,440 --> 00:57:29,760
IDות זה אופרטור עבור רק דבר אחד. NOT לוקח את מה שזה לא יהיה שבא אחריו והופך את הנכונות שלו. כלומר, ניקח ביטוי שהוא true,

184
00:57:30,640 --> 00:57:43,200
אסלונוט, הפכנו אותו לפולס ולהפך. אוקיי, עם המשמעויות המיידיות האלו אנחנו יכולים להסתכל כאן על דוגמאות.

185
00:57:43,200 --> 00:57:59,560
והדרך הכי טובה ללמוד, לדעתי, זה פשוט לראות את זה. אז ככה, הנה אני אצא בפה מפייתון, ננקה ונפתח פייתון שוב. נגדיר x שווה 5, כי אנחנו יכולים. innov3x

186
00:57:59,560 --> 00:58:28,800
בואו נבנה פה ביטוי בולייני, x גדול מ-5 או x קטן מ-10. עכשיו זה שx שווה 5 אומר x קטן מ-10, וזה true, בגלל שזה or, כל הor הזה יתרו, לכן זה ביטוי שהוא true. אין בעיות, נשאל משהו אחר. האם x שווה ל-5 וגם x גדול מ-6? מן הסתם שזה בלתי אפשרי.

187
00:58:28,800 --> 00:58:38,200
x שווה ל 5, yes, אבל הוא לא גדול מ-6 ולכן אנחנו שוברים את ה-and על כן false.

188
00:58:38,200 --> 00:58:57,700
ולבסוף, שאלה אחרת, האם זה נכון שx לא גדול מ-6? x גדול מ-6? לא. כלומר, האם x לא גדול מ-6? נכון, x לא גדול מ-6.

189
00:58:57,700 --> 00:59:26,700
אוקיי, אם כל האופרטורים האלה ביחד, אנחנו יכולים לבנות תנאים. ולפני זה, בואו נתרגיל אותם טיפה. בואו נתרגיל אותם טיפה. הוא אומר, הוא פשוט רוצה תירוץ, להריץ את הקוד שהוא בנה לזה. אז שוב, רשימה, רשימה, גרסת סטרינג, גרסה אמיתית והדפסה מסודרת. למה לא?

190
00:59:27,460 --> 01:00:12,593
בואו נריץ את זה, אך כמה טרמינלים פתוחים, נפתח עוד אחד, יאללה, פייתון, רגע, נעשה קצת זומין, כ-5.5, בואו נסתיר דברים, טוב, רגע, ונצמצם פה כאן, טוב נתחיל מהביטוי הראשון, האם 4 שווה לעצמו, 4 שווה ל 4? אז זה ביטוי שהוא בוליאני והוא הכי טוב שאתה יכול להבטיח בחוץ שלי שאיך אתה יכול להחזיק ion? למה יש לך לחץ? ולמה לא לגמור לעקוץ שלי בכלל שמקוספוט לצורה חופת מלחץ? למה אכפת אותך? בוא עושה מחנאים מזג

191
00:59:27,460 --> 00:59:56,440
בוא נרץ את זה, אך כמה טרמינלים פתוחים נפתח עוד אחד יאללה פייתון יסק קצת זומן קצת חומה של נקודה פיים בוא נסתיר דברים טוב ונצמצם פה כאן לטעים מהביטוי הראשון האם 4 שווה לעצמו 4 שווה לארבע אז זה ביטוי שהוא בוליאני והותרו.

192
00:59:56,440 --> 01:00:11,660
זה לא יפתיע אותנו, אוקיי, מה הביטוי הבא? אוקיי, לא נכון או לא נכון. עכשיו בואו נחשוב על זה רגע.

193
01:00:11,660 --> 01:00:26,340
פולס זה באמת 0, זה לא נכון, פולס זה עדיין 0 וזה לא נכון. כלומר שני הצדדים, שני האופרנטים של or כאן.

194
01:00:26,340 --> 01:00:55,440
ורבותיי, זה התרחיש היחיד שבו התוצאה של or היא הולכת להיות פולס, זה בוליאן שמחזיר פולס, הריזולף הוא פולס. ככה זה, אנחנו כבר ברמת ההגדרה. אוקיי, so far so good. הנה ביטוי, אמת או חמש? מזכיר לכם, מה שאמרנו בביטויים בוליאניים, זה ש...

195
01:00:55,440 --> 01:01:03,720
ערך כלשהו שהוא לא רק והוא לא אפס, יחזיר למעשה true.

196
01:01:05,040 --> 01:01:23,240
עכשיו מה שאמרתי לכם כרגע לא רלוונטי לאקספרשן (expression) הזה, בגלל שיש לנו כבר true משמאל להור, ואנחנו יודעים ש-or צריך רק true אחד לפחות כדי שיחזיר true, ועל כן זה ביטוי בוליאני שערכוside true.

197
01:01:23,240 --> 01:01:53,240
לא פספסנו כלום עד עכשיו. מה הביטוי הבא בתור? חמש או נכון? טוב. מעניין. מאוד מעניין מה שקרה כאן. ראיתם? או מסתכל שמאל הקודם. ופה אתם ראיתם, תראו את זה. פה יש לנו פה רגע של פייתון מה..

198
01:01:53,240 --> 01:02:23,240
המצגת לבד לא יכולה להמחיש לכם את זה. בדיוק הקודם אמרתי לכם שאור הסתכל על האופראנט השמאלי קודם, אני אמרתי את זה בתום לב, אני אומר לכם את האמת, אמרתי את זה בתום לב, לא קלטתי למה אנחנו הולכים להיפול, אז תראו. אור בדק את האופראנט טרו, ומצא שזה בוליאן שהוא אמת. ועכשיו תראו משהו. כאן יש לך קליפת טבעיק הזה שהצליח להבטיח את זה לשלולם של מצד. שמחה בקומדיה העולם חה קולם והחמן וחו מצפה דוי לגעתזעקס בווענון מרבע רצוע בתוצ

199
01:02:23,240 --> 01:02:36,240
שראה את 5 קודם,והוא לא הולך להחזיר בוליאן יותר, הוא הולך להחזיר אינט, מי היה מאמין, הוא יחזיר אינט, הוא יחזיר 5.

200
01:02:36,240 --> 01:02:52,220
להגיד לכם את האמת, אני לא ראיתי את זה בא. וואו, אני חייב לפתוח פה פייתון שוב, אני חייב לראות את זה, אני רוצה גם להראות לכם את זה, 5 או true?

201
01:02:52,220 --> 01:03:19,660
חמש רבותיי זה המצב כדאי לנו לדעת, הייתם חושבים אופרטור לוגי, הייתם חושבים חמש פשוטית הוא גם לטרו, אבל אני רוצה להזכיר לכם יש לנו את הנושא הזה של הרחבת הטייפ של תוצאה.

202
01:03:19,660 --> 01:03:43,520
לדבר הרחב יותר שהוא מזהה אז למה זה לא קרה פה בטרו אור פייב כי כאן הוא הסתפק בטרו בתור אופרנט לאור הוא באמת הסתפק בטרו אבל פה הוא ראה את חמש קודם וחמש זה כבר אינטגר ואמרנו אנחנו בעולם של אינטגר אבל אל תדאגו.

203
01:03:43,520 --> 01:04:08,300
בגלל שחמש הוא לא אפס אז אפילו אם היינו מזינים את הביטוי הזה לאיזשהו חלק בקוד שמצפה לבוליאן הוא היה יודע להמיר את חמש לבוליאן טרו לפי מה שאמרנו מקודם שבאמת ערך כלשהו שהוא לא אפס שהוא לא ריק יתורגם לבוליאן שהוא טרו.

204
01:04:08,300 --> 01:04:17,640
ואני באמת לא צחקתי כשאמרתי לכם שהתכונה הזאת של בוליאניות של כל דבר.

205
01:04:17,640 --> 01:04:26,400
היא באמת תהיה שימושית היא תהיה שימושית אז פה ראינו ממש מול העיניים את העובדה שאכן יש הבדל.

206
01:04:26,400 --> 01:04:30,560
בסדר של אופרנטים וגם את העניין הזה של טיפוס.

207
01:04:30,560 --> 01:04:35,820
אה כן נוט פייב ניקח חמש.

208
01:04:36,820 --> 01:04:49,480
ונגיד לו not, מה זאת אומרת not 5? 5 מתרגם אותך לבוליאן אתה כאילו true כי אתה לא rate, אבל not תקבל כבר false אז יפ.

209
01:04:49,480 --> 01:04:57,980
גט בוליאנד מה שנקרא ולבסוף יש לנו פה ביטוי קודם כל מחוזת high.

210
01:04:57,980 --> 01:05:06,180
אז אמרנו שלא רק על כן אתה true אם אנחנו הופכים אותך לבוליין ואנחנו הופכים אותו לבוליין.

211
01:05:06,180 --> 01:05:13,380
Not של true זה false אבל אז not של false זה true again.

212
01:05:14,120 --> 01:05:22,600
ואני חושב שלמדנו קצת דברים פה על בוליינים מה מה הייתם אומרים אני חושב שלמדנו.

213
01:05:24,060 --> 01:05:53,580
ולבסוף תרגיל אחרון ככה אפשר לקרוא לו מסכם אם תרצו לתרגול הזה. מבקשים איתנו לכתוב תוכנית שהיא קולטת מהמשתמש טמפרטורה של מים. כלומר אנחנו הולכים לעשות input פה לסטרינג ולתרגם אותו למספר. ואנחנו צריכים להדפיס האם המים אלו זה קרח נוזל או גז. כלומר אנחנו נקבל טמפרטורה ואנחנו נצטרך.

214
01:05:53,580 --> 01:06:22,940
לבנות ביטוי לוגי, בוליאני, אופרטורי, כן? שיקבע לנו האם הדבר הזה קרח, נוזל, או גז. עכשיו, תזכורת, מים. מים הם קרח, כאשר הטמפרטורה היא 0 או פחות. מים רותחים לגז בטמפרטורה של 100 מעלות או יותר. ואז הם נוזלים בין לבין. אז, שוב.

215
01:06:23,180 --> 01:06:27,800
זה תרגול מוקלט, אני לא הולך להתעכב אתכם דווקא על החלק הזה.

216
01:06:28,340 --> 01:07:10,606
ובואו נסתכל על הקוד שעושה את זה. אז ככה, מה יש לנו? אנחנו מקבלים K input את הטמפרטורה, ושוב פה, אני מציע, במקום לפצל את זה לשתי שורות, זה בסדר גמור להקיף את כל הסיפור פה באינט, ואז להיפטר מהשורה הזאת. תודה רבה. בסדר. Clean ו לישיבה. גלו של מע זקן. טעים ו מטוח. personal ו אינט אחששעונג שהתקשורת. היחידות של חברה אין כל מה שחושבת גם בצדק להפוך להחזמר. משהו שזה חשוב לך, אלא

217
01:06:28,340 --> 01:06:57,860
ובואו נסתכל על הקוד שעושה את זה. אז ככה, מה יש לנו? אנחנו מקבלים כאינפוט את הטמפרטורה, ושוב פה, אני מציע, במקום לפצל את זה לשתי שורות, זה בסדר גמור להקיף את כל הסיפור פה באינט, ואז להיפטר מהשורה הזאת, תודה רבה. בסדר, קלטנו לטמפרטורה מספר, הקלטנו אותו באינפוט.

218
01:06:57,860 --> 01:07:27,300
עכשיו, אנחנו נבנה לעצמנו בוליינים. האם זה קרח? הבוליין הזה מחליט את עצמו לפי, האם הערך של הטמפרטורה קטן שווה לאפס. מובן? בוליין ששואל האם זה קרח, פשוט לפי ההשוואה הזאת, באותה מידה. האם זה גז? האם זה עדים? האם זה קיטור? אני לא יודע איזה עוד מילה אתם רוצים. לפי האם הטמפרטורה הגדולה שווה עליה.

219
01:07:27,300 --> 01:07:57,300
ואז פשוט נסיק שזה מים נוזלים אם זה לא קרח וגם לא גז. עכשיו רק שתדעו, ביטוי שנראה ככה Not בוליין מסוים And Not בוליין אחר אפשר לכתוב את זה בשפות תכנות אחרות בצורה דומה אבל זה נראה כמעט כמו אם היה התפקיד

220
01:07:57,300 --> 01:08:27,300
רגילה, באמת, זה נראה כמו שפה טבעית. אוקיי, אז יש לנו כאן, הגדרנו, בצורה, הייתי אומר אפילו חד משמעית, כן? שלושה בוריאנים, קרח? כן או לא? גז? כן או לא? נוזל? אם לא קרח ואם לא גז. וכמובן, זה שקרח וגז הם mutually inclusive לפי הטמפרטורה, כן? טוב, הם גם mutually exclusive לפי הטמפרטורה, כן? טוב, הם גם mutually exclusive לפי הטמפרטורה, כן? טוב, הם גם mutually exclusive לפי הטמפרטורה, כן? טוב, הם גם mutually exclusive לפי הטמפרטורה, כן? זה לא פשוט, זה חוץ מהגרון שלנו ,מלא שאפשר להראות שלם

221
01:08:27,300 --> 01:08:57,300
וגם יש את כל הן טמפרטורות האפשרות שבן זה נוסע לו. בקיצור, בעזרת שלושה בוליאנים קיסינו את התחומים האלה. ועכשיו, איך אנחנו מקבלים את התוצאה של מה זה... אז תראו את השירשור הנחמד הזה, אנחנו אומרים שהתוצאה או מצב הצבירה, אם אנחנו מסתכלים לפי ההקשר, אנחנו אומרים, אנחנו בעצם לא אומרים אתה נראה פשוט רע שאתה צריך לי עזרה לך אני אעשה להם דבר שאתה מפטר.dt

222
01:08:57,300 --> 01:09:27,300
משרשרים מחוזות, אבל בתנאי, אנחנו אומרים שהתוצאה זו מחוזת, כן? יש לנו פה מחוזת שהיא לקווד, מחוזת שהיא אייס, ומחוזת שהיא גז. עכשיו מן הסתם יודעים שאמציו הצבירה יכול להיות רק אחד מהשלושה, ועל פי הבוליאנים האלו, אנחנו מגדירים, ככה, בשירשור, השירשור הוא או אפס או אחד.

223
01:09:27,300 --> 01:09:45,180
כלומר, אם הטמפרטורה שלנו היא של נוזל, אז איס ליקוויד הולך להיות טרו, כלומר, 1, ואז יהיה לנו שירשור פעם אחת של המילה ליקוויד, ו-0 שירשורים של אייס ו-0 שירשורים של גז.

224
01:09:45,180 --> 01:09:56,500
וכמובן, בהתאם לגבי קרח, אם הטמפרטורה קטנה מ-0 או גדולה מ-100 עבור גז. ואז אנחנו פשוט עושים פרינט ב-water is.

225
01:09:56,500 --> 01:10:26,500
רווח בלתי, וסטינגר תוצאה, לא מאמינים לי? אין בעיות, בואו נריץ את זה, יאללה, python q6.py , Enter temperature, בואו נתחיל ממים, מה נגיד, פושרים, חמים? אם כבר 40 מעלות, The water is liquid, I mean , כן,

226
01:10:26,500 --> 01:10:38,900
כי איז ליקוויד היה full, אז ליקוויד כפול אחד, ועוד כלום ועוד כלום. אין בעיות בוא נראה את זה שוב. טמפרטורה 0 מעלות בדיוק זה קרח.

227
01:10:39,460 --> 01:11:02,380
The water is ice, נראה את זה שוב, זה רתח 100. The water is gas, נראה את זה שוב, מינוס 40, שתדעו שהוא יודע להבין מספר שלילי. The water is ice, ונראה את זה שוב פעם אחרונה, 200 מעלות, שזה, לא יודע כבר מה נשאר מזה. The water is gas.

228
01:11:03,780 --> 01:11:32,900
אז קטע כזה, לא היינו צריכים לכתוב פה אי פעם אחת, ביטויים לחלוטין בעזרת אופרטורים ובוליינים, איזה קטע. וכמובן במצגת מופיע לכם הקוד. ולבסוף, לבסוף ממש, בתור סוג של קינוח. בכל זאת הקורס הזה, בנוי על השלד, של הקורס המקביל בשפת התכנות C.

229
01:11:32,900 --> 01:12:02,900
שאותה אולי אתם תלמדו בצורה אחת או אחרת בקורסים מתקדמים יותר ככה כדרך אגב. איך היינו בונים את זה בשפצי, האמת לא מסובך יותר משמעותית. היינו עדיין מגדירים משתנה בתור טמפרטורה שימו לב, בשי. מגדירים את המשתנה הזה מלכתחילה בתור אינטגר ועל כן לא היינו חייבים לתת לו ערך כי הקצינו כבר מקום בזיכרון שמתאים בדיוק לאינטגר. הערך שלו בינתיים?

230
01:12:02,900 --> 01:12:14,040
לא מעניין אף אחד, כי לא ניסינו להשתמש בטמפרטורה כשרק הגדרנו אותה. זה כזה ניוא�נס כזה של שפת התכנות C, כדי להכיר.

231
01:12:14,040 --> 01:12:31,200
מדפיסים לו מסך להכניס טמפרטורה בפקודת פרינט, ואז בשפת C יש לנו סקן F, סקן, זה מה שמחכה קלט מהמקלדת, אז פה אנחנו כותבים כזה אחוז D,

232
01:12:31,200 --> 01:12:59,060
שבשפת C הכוונה היא, אתה הולך בעצם לקלוט מספר, כאשר פה כתוב לנו ampercent טמפ, אוקיי, בואו נדבר על כזה דבר פעם אחרת, למה אמפרסנט, בסדר? תבינו שאנחנו פשוט נקלוט פה מספר, והמספר הזה הולך להיכנס למשתנת טמפרטורה, אז זה מה שקורה פה.

233
01:12:59,060 --> 01:13:28,520
מגדירים פה שלושה אינטג'רים, is ice, is liquid, is gas, אינטג'רים, למה ככה בא לנו לעבוד עם זה? הרי בסופו של תכנות יודעות לעבוד בצורה בוליאנית עם מספרים, יודעות. וכאן אתם רואים פשוט קוד שהוא כמו שראיתם מקודם, האם זה אייס? תוצאה של הבוליאן, לפי האם טמפרטורה קטנה שווה לאפס, האם זה גז, לפי אם הטמפרטורה גדולה שווה למאה?

234
01:13:28,520 --> 01:13:41,680
is liquid, אז כמו שראינו מקודם, זוכרים את ה-not דבר אחד וגם-not דבר אחר? האמת זה בדיוק אותו דבר פה. not is ice, כשכותבים.

235
01:13:41,680 --> 01:13:57,880
ב-c, n%% זה בעצם end, אז. אם זה לא קרח וגם זה לא גז, בדיוק אותה משמעות. ופה כתוב פה. קר כוכב.

236
01:13:57,880 --> 01:14:27,880
עובדה שכדי לכם להכיר, מכרוזת, סטרינג, זה בעצם מערך של תווים. פה אנחנו בעצם מגדירים מערך של תווים, שזה סטרינג, תוצאה, ואנחנו אומרים, אם זה נוזל, אז המערכי, כאילו, המערך של תווים זה לא תווים, הוא תצטרך להרוס לח ברורה של בעצם בערך. אם זה נוזל, אז המערכי...ףחום תצטרך להרוס או לא נוכל להרוס חשוב שהיית צריך להרוס חשוב לצרכי איזה צריך לחיות אי אפשר לך להשתמש בשום חוץ אגרוב ולא להצטרך בשום חוץ באמת מייצוע אחד זורק...אין נורמלא

237
01:14:27,880 --> 01:14:57,880
מחוזת תהיה נוזל. ופה, אוקיי, זה ביטוי לוגי קצת מתקדם, ועוד בשיגם, זה כאילו דרך בעצם לכתוב שוב, שתנאי של אי� בלי לכתוב איף, אנחנו אומרים, אם זה נוזל, האם זה נוזל, אם כן, אז הערך שלך יהיה מחוזת ליקוויד, אם לא כן. זה... ופשוט לא באופן ללכת לדעת לעשות מערכת מושפכת, אתה עושה זאת לא רק בשביל שאתה חוזק, לאטרות שאטרור שוב בגוחות החולים שלך, לצדך מפתי הודעה משחוזה שהופסה לך לעשות הקרדה שלך צריך להשוב לך אז אתה צריך

238
01:14:57,880 --> 01:15:11,880
אז אנחנו שמים פה בסוגריים עוד שאלה כזאת בדיוק, מה שנקרא ביטוי טרנארי אם אני לא טועה, תקנו אותי אם אני טועה, אז כזה אם לא, אז אנחנו שואלים של אחרת.

239
01:15:11,880 --> 01:15:42,746
האם אתה קרח, אם true, אז הערך שלך יהיה אייס, אחרת הערך שלך יהיה גיאס. ובסופו של דבר פקודת פרינט אף, שתיקח את התוצאה מריזות ותדפיס אותה. אל תלעגו.. ...אתזמור להפסיק את דבר האכהרונית גיונור "ובספוק אגרונכם אוהבת גזועה ומחבורה דואגת חסוכות המיוח" של יורי יורי. שלי יש

240
01:15:11,880 --> 01:15:25,880
האם אתה קרח? אם true, אז הערך שלך יהיה אייס, אחרת הערך שלך יהיה גא�ס. ובסופו של דבר, פקודת פרינט F שתיקח את התוצאה מריזות ותדפיס אותה.

241
01:15:25,880 --> 01:15:50,880
אל תדאגו, אנחנו לא מכריחים אתכם כרגע לזכור קוד ב c בעל פה, אבידנטלי, זה קורס בפייתון. ואנחנו פחות או יותר סיימנו את התרגול השני במבוא למדעי המחשב מגרסת פייתון. תודה רבה על ההקשבה שלכם, ואני שמח מאוד שהצלחתם לשרוד את הראמבלינג שלי. המשך יבוא.

