1
00:00:00,000 --> 00:00:14,120
היי, ברוכים הבאים לתרגול ה-11 של הקורס מבוא למדעי המחשב. נושא התרגול היום יהיה בעיקר על עצים בינאריים ולקראת סוף התרגול נדבר גם קצת על backtracking.

2
00:00:16,120 --> 00:00:29,680
אז מה זה בכלל עץ בינארי? אם אתם זוכרים, אנחנו הגדרנו את הרעיון של רשימה מקושרת, את הרעיון של node או צומת, בתור כזה...

3
00:00:29,680 --> 00:00:59,640
אובייקט שיש לו לפחות שני שדות. אמרנו, יש לו כזה שדה ראשון, בתצורה של dictionary אמרנו, יש לו כזה מפתח value, והערך של זה הוא פשוט איזשהו ערך משתנה כלשהו, בצורה הכי פשוטה, חשבנו על זה כמו אינטג'ר, אבל זה יכול להיות כל דבר. ואז היה לזה עוד שדה, שהוא בעצם היה מצביע לאובייקט אחר מאותו סוג, node.

4
00:01:00,420 --> 00:01:10,280
ואז הרעיון היה ברשימה המקושרת שהיה לנו Node וה-Next שלו היה Node אחר וה-Next של ה-Next שלו היה Node אחר וכן הלאה וכן הלאה.

5
00:01:10,280 --> 00:01:29,440
אז בעץ בינארי אנחנו לא מסבכים את הרעיון יותר מדי, פשוט תחשבו על זה ככה: יש לנו צומת Node, יש לו את הvalue שלו, και בנוסף לכך יש לו שני מצביעים, אבל זה לא בדיוק מצביע של...

6
00:01:29,440 --> 00:01:59,440
previous ו-next, אלא יותר כמו מצביע של left sign וright sign. כלומר, תחשבו באמת על עץ שהשורש שלו הוא נמצא למעלה והבנים שלו הם משמאל ומימין למטה. אז למעשה יש לזה ממש שמות כשאנחנו מדברים על הרעיון של עצים, אז אנחנו יכולים להגיד שצומת כלשהו הוא אבא של הבן השמאלי שלו והבן השמאלי שלו ומצד

7
00:01:59,440 --> 00:02:29,440
המני שלו. אז בואו נראה לזה דוגמאות, אנחנו יכולים לראות כאן דוגמא לעץ מאוד מאוד פשוט, שיש לנו צומת כלשהו, יש לו צומת שהוא בן שמאלי, יש לו צומת שהוא בן ימני, ולבנים שלו בעצמם אתם רואים שכבר להם אין בנים, כי אתם רואים פה הלפט והרייט שלהם הוא פשוט נאן. בדיוק כמו שראיתם כשהגדרנו את הרעיון של רשימה מקושרת ולרשימה כלשהיה, אצלנו ראינו שצד כולם מכינה מיcareנו יודעים שהוא הקשיש בעצם רומט אחרת ומדובר בהקשרת הישמעון של מכוננו. שמדובר בזה בש

8
00:02:29,440 --> 00:02:51,940
אין יותר נקסט, זה בעצם הרעיון, אז אם אתם מסתכלים על עץ פשוט כמו זה, אתם יכולים לשים לב שהצומת הראשון הוא למעשה שורש העץ, באנגלית רוט, אין לו צומת אב� משל עצמו, הוא מתחיל את העץ ממנו והלאה.

9
00:02:53,200 --> 00:03:10,880
אתם גם יכולים לשים לב שצומתים שאין להם בכלל בנים הם מה שנקרא עלים, כלומר זה קצה כלשהו של עץ, זה עלה, הוא הכי למטה באותו ענף אם אתם כבר רוצים להסתמש במינוח של עצים.

10
00:03:12,880 --> 00:03:42,620
בעיקרון לכל עץ יש שורש אחד בלבד, אז אם אנחנו מסתכלים על העץ כולו, השורש שלו זה פשוט השורש של העץ, אבל כמו שאתם ראיתם בהרצאה, ופה אני קצת אגניב מבט קצר מההרצאה, כל צומת בעץ הוא למעשה תת עץ משל עצמו, והוא בעצם השורש של תת העץ שמתחיל אצלו.

11
00:03:42,620 --> 00:04:11,020
אז אתם ראיתם את הסיפור הזה בהרצאה, ואכן זה נכון, אז למעשה כשאתם ראיתם בהרצאה פה דוגמה לאיזשהו עץ שהוא אפילו לא בינארי, כן, עץ עם שלושה בנים, עדיין כל אחד מהבנים שלו היה סוג של שורש לתת העץ של עצמו. זה כולה היה רעיון של המשולשים האלה שמכסים כל אחד מהבנים, אבל זה סתם מבט אל ההרצאה.

12
00:04:12,020 --> 00:04:25,020
בכל מקרה, אנחנו נתעסק הרבה מאוד בעצים בינאריים, זה מבנה נתונים מאוד בסיסי, מאוד נפוץ בעולם מדעי המחשב, ובמשכת רגול אנחנו נראה כמה דברים שאפשר לעשות עם זה.

13
00:04:26,020 --> 00:04:48,020
אז כמו שבאמת ראיתם מקודם, אנחנו יכולים לממש עץ בינארי בצורה טריוויאלית של דיקצ'נרי, מילון בפייתון, זאת אומרת נגדיר אובייקט של צומת בעזרת שלושה שדות, מפתח ואליו, מפתח left, מפתח right.

14
00:04:48,020 --> 00:05:14,020
אתם רואים שבהתחלה אנחנו הגדרנו פה דווקא node 1 ו- node 2, מי שהולכים להיות אלים, כי אתם רואים ה- left וה- right שלהם זה נאן, ואז בגלל שיש לנו node 1 ו- 2 מוגדרים פה, אז אנחנו יכולים להגדיר פה איזשהו node אחר, נקרא לו root, תראו מה, יש לו שדה value עם ערך כלשהו, וה- left שלו שווה בעצם node 1, וה- right שלו node 2.

15
00:05:14,020 --> 00:05:36,020
אני יכול גם להראות לכם את זה בקוד פייתון לדוגמה, אתם רואים פה בדיוק הגדרנו את הדיקצ'ונריז האלה עם value, value בהתחלה, אלה הולכים להיות האלים, ואז ה- root, ה- left שלו הולך להיות ממש node 1 שהגדרנו וה- right שלו הולך להיות node 2 שהגדרנו.

16
00:05:36,020 --> 00:06:05,000
אז אם אני רוצה להדפיס את הדיקשונרי רוט מה נראה אנחנו ממש נראה איך שהגדרנו אותו תראו אנחנו מדפיסים את הדיקשונרי של רוט אז value שלו זה באמת שלוש ואז left שלו אתם רואים שהוא פותח בעצמו דיקשונרי שזה בדיוק node 1 dict עם value של תשע ואז אין לו בנים?

17
00:06:05,560 --> 00:06:35,560
פסיק write של הרוט דיקט, אתם רואים? רייט! הוא באמת הולך להיות הדיקצ'נרי שהגדרנו note 2 דיקט, אז אם הvalue 10 וה-left ו-right שלו הם none. זאת אומרת, זה לא מאוד מסובך אם אתם הבנתם את הרעיון של רשימה מקושרת ופה אנחנו רואים שכן, כמו שיכולנו להגדיר רשימה מקושרת בעזרת דיקצ'נרי, בטח שאפשר להגדיר אץ בינארי.

18
00:06:35,560 --> 00:07:05,560
עזרת dictionary פשוט נגדיר שדה עבור הבן האחר פשוט וכמובן שזה יעבוד דברים שראינו עד עכשיו יעבדו, אבל אני רוצה שתדעו יותר מסתם עץ בינארי רגיל מבני נתונים שימושי אי לא פחות אולי אפילו יותר מעץ בינארי רגיל זה מה שקוראים לו עץ חיפוש בינארי, או אפילו איך

19
00:07:05,560 --> 00:07:35,560
איך שאנחנו נכיר אותו באנגלית, Binary Search Tree. מה הפואנטה בBinary Search Tree? זה עץ בינארי אבל עם תכונה מאוד מאוד קריטית. לכל צומת, לכל Node, לכל קודקוד, כל שלוש המילים האלה דרך אגב הן אומרות אותו דבר. לכל צומת בעץ חיפוש בינארי מתקיים שהעץ שלו יהיה ראיון בבינארי. Natural? מי היה פועל לך לפעמים כאלה? איך אתה לא שואל אותה בינארי אז אתה צריך להבין מעטפחי בבינארי וצריך לאטפקטר שלום ומאטפקטר של מעטפקטר של מבינאי? הצעמת הרבה ביצועים של

20
00:07:35,560 --> 00:07:51,140
הערך של כל הצמתים בתת העץ השמאלי שלו קטנים שווים, והערך של כל הצמתים בתת העץ הימני גדולים שווים.

21
00:07:52,180 --> 00:08:05,500
ואז מה זה אומר? שאם אתם תסתכלו על איזשהו עץ חיפוש בינארי שמודפס בצורה טובה, מה שנקרא, אז הם תראו שבעצם אם תסתכלו עליו משמאל לימין,

22
00:08:05,500 --> 00:08:35,440
אתם ממש תראו סדר עולה של הערכים של הצמתים. פה כתוב בשקופית שכאילו אנחנו אומרים שצומת הוא גדול שווה לכל מה שנמצא משמאלו, וקטן שווה לכל מה שנמצא מימינו. וזה אכן מתקיים בעץ חיפוש בינארי. למעשה יש לנו פה אפילו תרגיל שממש מבקש מאיתנו.

23
00:08:35,440 --> 00:09:05,220
להשתמש בתכונה הזאת מבקשים איתנו לקבל כזה בינארי סאצ' טרי ולבנות ממנו רשימה ממויינת של הוואליוס שיש בו. אז לדוגמה פה אם יש לנו בינארי סאצ' טרי שהרוט יש לו וואליו של שתיים, הוואליו של הלפט שלו זה אחד, הוואליו של הרייט שלו זה שלוש, אז הפונקציה הזאת באמת תבנה רשימה עם שלושה איברים.

24
00:09:05,220 --> 00:09:35,220
1, 2, 3. אז איך היינו ניגשים לעשות כזה דבר? הצורה הכי אינטואיטיבית, ואני חושב שגם הצורה שאם אתם תבינו אותה, אתם תבינו את הרעיון פה, היא הצורה הרקורסיבית. אז אנחנו יכולים באמת להגדיר לעצמנו את הפונקציה הזאת. bst, to list, בצורה רקורסיבית, מה נעשה? נקבל, פה אנחנו קוראים לזה root, אבל שתדעו,

25
00:09:35,220 --> 00:09:46,540
זו פונקציה ריקוסיבית היא תקבל צומת מה נעשה? נקבל צומת ונגיד if not צומת כלומר אם.

26
00:09:46,540 --> 00:10:02,420
אנחנו מדברים פה על ריקוסי כן? תנאי הצירה, אם בריקוסי ירדנו עד לכלום אז פשוט נחזיר רשימה ריקה, אחרת יש לנו איזשהו עבר אנחנו נמצאים באחד מהעברים.

27
00:10:02,420 --> 00:10:19,540
אז תניחו שאנחנו קוראים לפונקציה הזאת על השורש של העץ מה אנחנו מחזירים? תראו אנחנו נגדיר list שווה מה שהפונקציה הזאת תחזיר אחרי שנקרא לפונקציה הזאת עם הבן השמאלי.

28
00:10:19,540 --> 00:10:30,040
אחר כך נוסיף ל list את הvalue של השורש שאנחנו נמצאים בו עכשיו ואז נוסיף ל list.

29
00:10:30,040 --> 00:10:59,280
את מה שנקבל מהפונקציה הזאת כשנקרא לה עם הבן הימני ובסוף נעשה ריטרן. למעשה, ספוילר, מה שאתם ראיתם כאן זה פשוט לבנות רשימה של values על ידי לעשות מה שנקרא in-order traversal. זה משהו שאתם ראיתם אני רוצה לקוות בהרצאה אם אני אלך פה עכשיו להרצאה בוא נראה רק שנייה.

30
00:10:59,660 --> 00:11:29,000
כל שדילגתי על זה הנה לא טיול in-order בבקשה זה טיול שיש לו משמעות מאוד מאוד ספציפית וישירה כשאנחנו מדברים על binary search tree. כשיש לנו באמת עץ שהוא מסודר כמו שצריך זאת אומרת עץ חיפוש שבו יש לנו איבר כל תת עץ השמאלי שלו קטן ממנו כל תת העץ הימני שלו גדול ממנו וזה תקף דרך אגב.

31
00:11:29,000 --> 00:11:58,740
לכל איבר בעץ אז הטיול הזה המעבר הזה שבו אנחנו לכל צומת קודם מסתכלים על התת עץ השמאלי שלו אחר כך על הצומת עצמו ואז על התת העץ הימני שלו בעץ חיפוש בינארי זה באמת יבנה לנו ממש טיול מסודר על הערכים של העץ זאת אומרת.

32
00:11:58,740 --> 00:12:28,740
תסתכלו, נניח, לא יודע, אני רוצה להביא אותנו חזרה למצגת של התרגול שלנו, אז פה אתם כבר ראיתם את זה נכון? אם יש לנו עץ פשוט כזה, אז אני מתחיל מהשורש, דבר ראשון, בן שמאלי, וזה ימשיך אקורסיבית, אז באמת דווקא בהרצאה היה לנו משהו נחמד, נניח, נתחיל מהשורש, אבל אני לא מתחיל לספור פה, אני הולך לבן שמאלי, הולך לבן שמאלי, ואני אעשה אותו במצגת של תרגול. פתאום אני יצא לעצמי בגישה שבר זמן שמאיום יכול לתקן אותייות, מרשים אינט

33
00:12:28,740 --> 00:12:58,740
בן שמאלי ומוסיף. אז אני אסיף פה את אחד. אחר כך חוזר חזרה לבחור הזה כאן18 מוסיף אותו. אז יש לי אחד פסיק שלוש ואז מסתכל על הבן ימני וזה קודם הסתכל בן שמאלי שמה. וזה אני אוסיף ארבע אר

34
00:12:58,740 --> 00:13:10,100
את 8, אשור שאנקורי, הולך ימינה, אין ברירה, אני מוסיף את 10 ואז הבן הימני שלו, אבל לא מוסיף את 14, קודם מוסיף את הבן השמאלי של זה, 13 ואז 14.

35
00:13:10,100 --> 00:13:39,460
בקיצור אתם מבינים, לכל צומת בעץ בינארי, קודם מוסיף את תת העץ השמאלי שלו, אז תת צומת, ואז תת עץ ימני. ואני אומר בכוונה תת עץ, לא אומר בן, כי אנחנו ספציפית מסתכלים על תת עץ שמאלי לכל צומת, זה רקורסיבי, וכן, זה יעשה את המעבר הזה ככה, כמו שצריך, ממש ככה.

36
00:13:39,460 --> 00:14:09,460
אז המימוש הרקורסיבי של זה הוא די מובן כשאנחנו מסתכנים על זה ככה. יש איזה גם מימוש איטרטיבי שאפשר להגיד ספק קצת יותר מסובך להבין, אפשר לנסות להציץ בו ולראות אם אנחנו אולי בכל זאת מסתדרים איתו. הרעיון במימוש איטרטיבי בגדול, פה אתם רואים אנחנו נעזרים במחסידים, אין להכיר על זה שזה בשביל הפכח הזאת העיוון של הסטטנס סטטרטסטר הזה הייתה)end על הח לסטטטרו של מימוש איטרטיבי (במרכז שנצא לפרצות)ובאילו הייתה לפרוץ איטרטיב. מה הע

37
00:14:09,460 --> 00:14:39,460
מחסנית, זה כאילו לטפל באמת בדת עץ שמאלי כל פעם, על ידי זה שאנחנו כאילו מוסיפים למחסנית את הצמתים שאנחנו נרצה אחר כך בסדר הפוך להוסיף אותם. בוא נראה אם אנחנו מצליחים להבין את זה. נתחיל מחסנית רקע כלשהי, נגדיר לעצמנו קרנט כלשהו, נתחיל מהשורש, ונבנה את הרשימה שלנו מכלום.

38
00:14:39,460 --> 00:15:09,460
שימו לב זה איטרטיבי אין פה רכורסיה. אז יש לנו פה שני וואלים. קודם כל וואל הראשון אומר וואל קרנט הוא עדיין צומת כלשהו או שעדיין יש משהו בסטק אבל כרגע התחלנו להסתכרך אז קררנט שלנו כרגע רוט יש משהו. אוקיי, אז עכשיו נכנסים לוואל פנימי וואל קרנט הוא עדיין צומת כלשהו. בסדר? נעשה כזה דבר

39
00:15:09,460 --> 00:15:38,120
נוסיף לה סטייק, סטייק.אפנד, אנחנו מתעסקים עם רשימה רגילה בתור סטייק, אבל כבר ראיתם את זה. כל עוד שאנחנו נעשה אפנד בסוף, ואז פופ מהסוף, זה התנהגות של מחסנית לחלוטין. אז זה בסדר גמור. לא חייבים מבנה נתונים אולטרה מתקדם בשביל מחסנית. לא חייבים. אז, שימו לב, התחלנו עם השורש שלנו בתור קארנט, מחסנית ריקה.

40
00:15:38,120 --> 00:16:08,080
נכנסים לו ווייל הפנימי, ווייל קארנט, אז נתחיל כרגע שורש. סטייק נקודה אפנד קארנט, אז הוספנו כרגע את השורש של המחסנית, ואז נגיד קארנט שווה קארנט left, אוקיי? אז הנה, אני אפילו רוצה לעשות לכם את המעקב הקצר הזה בנוטפד, אני מנצל את העובדה שזה תרגול מוקלט מראש, אם אתם לא רוצים את זה, דלגו קדימה. אז עכשיו אני אומר, סטייק, כרגע שווה, נתחיל מרוט, אוקיי?

41
00:16:08,080 --> 00:16:36,840
טוב, נו, אנחנו מדברים פה על עץ פשוט, נכון? 1, 2, 3, יאללה, נכתוב את זה ישר. ואז אנחנו אומרים currnt שווה currnt left, אוקיי, נלך לאחד, חזרה, currnt הוא עדיין צומת, אז נעשה stack append currnt, זאת אומרת, הוספנו עכשיו את הבן השמאלי הזה, ואז זה שוב, זה עושה לנו currnt left, אבל הפעם זה מביא אותנו לנאן, אז currnt יתרוקן, בסדר.

42
00:16:36,840 --> 00:17:06,820
זאת אומרת, הוספנו למחסנית עכשיו צומת ואת כל הבנים השמאליים, שזה לא רע, כי זאת אומרת, שמימין לשמאל, מהטופ של המחסנית עד לבוטום שלה, יש לנו דברים בסדר עולה, שזה טוב, אנחנו רוצים לבנות ראשים, הנה, אל תשכחו על להסשרים כרגע ריקה. אוקיי, סיימנו.

43
00:17:06,820 --> 00:17:36,820
קרמנו תלולה פנימית שבעצם דוחפת לסטק ממש עברים מבחינת ערכים הם יורדים עכשיו אנחנו אומרים קרנט=סטק 5 אוקיי אין בעיות נעשה את זה, אני עושה מ5 פופ, מ5 זה מהסוף של ליסט, עכשיו שהיא קרנט שהוא 1 ועכשיו אני עושה מ0 ליסט.אפנד את הvalue

44
00:17:36,820 --> 00:18:06,240
אני מביא את זה לפה, ואז current שווה current right. אוקיי, אבל כמו שאנחנו יודעים אין פה בסדר? אין current, נכון? עשינו list append לאחד, אחרי שעשינו pop מ- stack ל- current, אז אי אפשר להוסיף.

45
00:18:06,240 --> 00:18:36,140
אי אפשר להוסיף right של אחד, נכון? כאילו אין לו כלום. אני אעשה current שווה זה, current שווה current right, אבל זה יהיה פשוט עכשיו none. אז מה קורה? אנחנו מסיימים פה, הולכים חזרה לו while הזה. while current, אבל current הוא none. stack, כן יש מישהו להוסיף, אז אנחנו נכנסים לפה. while current, אבל current הוא none, אז כל הלולאה הזאת לא קורית יותר, אתם יודעים למה? כי בעצם סיימנו לטפל בטאטץ השמאלי, כמו שאמרתי לכם.

46
00:18:36,140 --> 00:19:06,080
איזה כיף זה כשהיה מתרגל לברמרו של הקוד. ועכשיו, current שווה stack pop, אוקיי, נרוקן אותך, אתה עכשיו שווה, אתה עכשיו ה-node 2, כן? זאת אומרת הרוט. עכשיו list append current נקודה value, בכיף, וcurrent שווה current right. היי, מעניין מי ה- right של השורש, זה שלוש. מגניב. יאללה, עושים את זה.

47
00:19:06,080 --> 00:19:35,960
סיימנו כאן. עכשיו, חוזרים חזרה להתחלת ה-while, הסטק שלנו ריק, אבל current לא ריק. אז הנה, עכשיו נכנסים ל-current, stack append current, שלוש, ואז current שווה current left, אבל אז כבר יהיה כלום, אין בעיות, ואז נכנס לפה, אתם רואים איך זה הולך, ואז current שווה stack נקודה pop, אוקיי, ושוב, חזרנו לזה, node שלוש, list append, פסיק שלוש, current שווה, זה.

48
00:19:35,960 --> 00:20:05,960
גמרנו. בקיצור ריק ריק. זהו סיימנו. וכן זה גם יעבוד בדברים יותר מתוסבכים, אבל אני לפחות מקווה שהשתכנעתם ששיטה אחת יותר מובנת אינטואיטיבית מאשר השיטה האחרת, אבל בכל זאת אם רציתם לדעת, ה firewall הפנימי הזה מטפל בתת עץ שמאלי, בסדר. שאלה קטנה.מה יקרה לך?

49
00:20:05,960 --> 00:20:35,960
מה קורה אם היינו מתחילים את הסטייק שלנו בתור  None, במקום רשימה ריקה. בוא נגיד זה ככה, הייתה גרסה קודמת של הקוד הזה שהיא קצת פספסה את זה. אז אם היינו בטעות מתחילים סטייק בתור  None. אז בוא נגיד את זה ככה. אין פונקציה שקוראים לה  Append שעובדת על משתנה שהוא  None אז אל תעשו טעויות כאלה אם במקרה קרה לכם משהו. אה ואל תדאגו כמובן, כמובן.

50
00:20:36,460 --> 00:20:39,420
יש לנו קוד שעושה את זה, הקוד נמצא פה.

51
00:20:43,160 --> 00:20:46,860
בואו נראה, האם זה זמן להראות את זה?

52
00:20:47,240 --> 00:20:52,660
עוד מעט, עוד מעט נראה לכם, בינתיים בואו נמשיך, מקווה שהשתכנעתם.

53
00:20:53,220 --> 00:21:05,260
עכשיו, סוגי ריצות. אתם ראיתם מקודם בשאלה הראשונה, שאנחנו בעצם עשינו In-Order Traverse, כלומר, תת-את שמאלי.

54
00:21:05,260 --> 00:21:35,180
שורש, אני אפילו לא אגיד שורש, נגיד את זה ככה, תת-את שמאלי, צומת, תת-את ימני, זה ה-In-Order Traverse. וב-Binary Search Tree, זה בכלל מושלם. אז הנה ה-In-Order שדיברנו עליו. אבל תשמעו, יש עוד סוגים של לבקר בעצם, ולכל סוג יש את השימוש שלו. יש גם ריצת Pre-Order, לדוגמה, שהיא קודם מסתכלת.

55
00:21:35,180 --> 00:22:04,480
על צומת, ואז על בן שמאלי, ואז על בן ימני שלו. כמו שאתם רואים פה, דוגמה למה קורה עם אין נושאים טרברס כזה על העץ. יש גם ריצה שהיא Post-Order, שזה דווקא קודם בן שמאלי, אחר כך בן ימני, ואז הצומת הנוכחי. או יש אפילו, מה שראיתי בהרצאה, שזו ריצת Level-Order. זאת אומרת, שאנחנו מחשבים את הגובה.

56
00:22:04,480 --> 00:22:34,240
של כל צומת, לא גובה, סליחה, יותר הייתי קורא לזה עומק, אנחנו חשבים את העומק, אם אתם רוצים, של כל צומת, ואז כאילו אנחנו מדפיסים מהשורש ויורדים בעומקים. עומק או גובה זה תלוי, אתם יכולים לחשב את זה בצורות, קצת, הפוכו קצת מתחלפות. כן, יש את הקטע הזה. בואו נראה, אני רוצה לראות מתי.

57
00:22:34,240 --> 00:23:04,240
אה, דחפתי את זה קדימה. טוב, בסדר בואו נראה האם אני יכול בשלב זה להראות לכם קוד מעניין או שעוד לא. האמת היא שאני יכול לפחות להראות לכם לקוד רץ אבל לפני שאני עושה את זה. אני כאן ועכשיו אקח את הרגע לעשות פאוז. ולהראות לכם שיטה להגדיר צומת. אתם אולי זוכרים את תרגולים קודמים. אנחנו הראינו לכם לדוגמאים

58
00:23:04,240 --> 00:23:34,240
איך שהגדרנו רכיבה מקושרת, אמרנו, אה, יש לנו דיקצ'ונרי או שיש לנו, בואו נראה, אני אביא אתכם לה, הנה טוטוריאל 10, הראינו דאטה קלאס, אתם זוכרים את הדאטה קלאס? כן, אמרנו עם נוד והשדות שלו, כן, תראו, בעולם האמיתי, אנשים לא באמת משתמשים בדאטה קלאס, אנשים פשוט משתמשים ב...

59
00:23:34,240 --> 00:24:04,240
קלאס, שזה בילט אין לפייתון לא צריך לעשות שום אימפורטים, פשוט לא הראינו לכם את זה מקודם בגלל שזה כבר חומר שאתם אמורים להתעסק או רק בתכנות מונחי עצמים אבל אני פשוט אומר לכם בתכלס בטכלס בפייתון כשאתם רוצים להגדיר איזשהו משתנה מיוחד או אובייקט מיוחד אתם פשוט מגדירים קלאס אתם תלמדו לקלאס בתכונות מונחי עצמים אבל בגלל שאתם נדלמדו

60
00:24:04,240 --> 00:24:34,240
שכבר ראיתם data class וזה, זה כבר מובן לכם, פשוט קלאס זה מישהו שעובד, בלי שטויות, אז תראו איך אנחנו מגדירים צומת של עץ בינארי, האמת זה לא מסובך, אני מגדיר קלאס node עם n גדולה, זאת אומרת מבחינתי זה הולך להיות כביכול משתנה מסוג node, n גדול, זה קלאס, איך אני מגדיר אותו? אז ככה, יש דבר אחד שהוא כן קריטי לי כדי להגדיר את זה,

61
00:24:34,320 --> 00:25:04,320
אני עושה פה בתוך הקלאס נקודתיים הזה, אני עושה define, פה יש לי כב תחתון, כב תחתון, init, כב תחתון, כב תחתון, מה שזה אומר, אני מגדיר פה איך אני מאתחל אובייקט מסוג Node. אז אני עושה define לאינית, זאת אומרת, אם אי פעם אתם תרצו לכתוב קלאסים בפייתון, המינימום שאתם חייבים לעשות, זה להגדיר את זה גרסאיים כסף, פגיש מסגרת מפייתון למצטע. תרצו רק להגיד לו להעביר את זה בככל שלך, בקיצור בפייתון, בטראומה שמגיע להגיד לך, זה שהחשיב

62
00:25:04,320 --> 00:25:34,320
את ההתחול של אובייקט מסוג כזה, זה המינימום שאתם חייבים, מוכרחים. ואז יש פה מילה אחת שאולי לא ראיתם מקודם, שהיא המילה self. אני לא רוצה לסבך אתכם, שתדעו, self הכוונה היא האינסטנס הנוכחי של אובייקט. אז מה הכוונה? אני רוצה להגדיר אובייקט מסוג node, אני עושה לו initialization...עכשיו פשוט אחרת כל מה שאתה יודע  אם אתה לא יודע

63
00:25:34,320 --> 00:26:04,320
ו הפרמטר הראשון לאיתכול הזה הוא פשוט אותו אינסטנט, עכשיו זה לא חייב להגיד לכם הרבה, בסך הכל שתדעו נניח כשאני רוצה לבנות נניח Node, תסתכלו איך איך אני מונה את זה,אני מגדיר פה Node 1 שווה מה? Node ממש Class Node ואני שולח כפרמטר, רק פרמטר אחד Value. אז מה קורה?

64
00:26:04,320 --> 00:26:34,320
זה בעצם קורא לפונקציה העינית הזאת של הקלאסט נוד, זה שולח לסלף את הנוד 1 הזה אבל זה לא אומר לו כלום כרגע, נכון? כי זה קלאס פשוט. כרגע אל תתעסקו עם זה, שולח לו, פרמטר תשע, זאת אומרת, הינה הפרמטר הזה, זה הולך להיות value, כן? יש לו גם עוד שני פרמטרים שהגדרתי, left ו right, אבל נתתי להם ערך דפולטיבי של none, אז זה למה הקריאה הזאת תעבוד.

65
00:26:34,320 --> 00:27:04,320
ובפנים, להגיף לכם את האמת, זה לא ממש יותר שונה ממה שאתם ראיתם, האמת, אתם ראיתם בדאטה קלאס, אתם זוכרים? היה לנו, הגדרנו נניח שם, היה לנו נוד, לא יודע, היה פה איי-די-אקס-וואי, נקסט, נניח לנקסט, נתנו אף דפולטיבי, אבל אתם רואים, אין פה הבדל משמעותי, אתם מבינים את הרעיון, נכון? בסך הכל פה, ספציפית, אנחנו כותבים ישירות, סלף נקודה. יהיה טוב,

66
00:27:04,320 --> 00:27:14,680
זאת אומרת האינסטנס הזה שאנחנו מהתחילים נקודה, זאת אומרת שדה, איזה שדה, ואליו שווה הפרמטר ואליו שקיבלנו.

67
00:27:14,680 --> 00:27:26,700
ה-self נקודה left, זאת אומרת האינסטנס הזה, left שלו שווה ה-left שאני מביא לו, ואם זה none, אז שיהיה none, אותו דבר לגבי ה-write.

68
00:27:26,700 --> 00:27:41,200
וזהו, להגיד לכם את האמת, אני עד עכשיו לא מבין למה לא הראינו לכם פשוט את הצורה הזאת של קלאס. אייסט לבאכנו עם דאטה קלאס וזה, אבל היי, נו, לפחות למדתם על דיקשונריז.

69
00:27:41,200 --> 00:27:56,460
אבל רק שתדעו, אני לא יודע אם זה בדיוק נחשב חלק מהחומר של הקורס, כן? לא ראיתם את זה בהרצאות, אבל מבחינתי, בתרגול האחרון, סמי האחרון, לפחות שתכירו, ככה באמת כותבים קלאסים בפייתון, ככה.

70
00:27:56,460 --> 00:28:26,460
לא בצורות אחרת. בקיצור, למה עשיתי את כל הסיפור הזה? כי אני רוצה מכאן והלאה בתרגול לא להתעסק יותר עם עצים בינאריים בצורה של מילון, אלא אני רוצה להיאזר כן במימוש הסופר פשוט הזה של צומת, ומשם והלאה אנחנו נעשה את העבודה שלנו. וכמו שאתם רואים, בדיוק כמו שכאן הגדרנו צמתים בצורה של דקשונרי,

71
00:28:26,460 --> 00:28:56,460
אני יכול פשוט להגדיר אותם פה בתצורה של קלאס נוד, תראו נוד 1 תצור לי נוד עם value שווה 9, נוד 2 תצור לי נוד עם value 10. שורש תצור לי נוד עם value 3 ואז אני אומר שורש נקודה left שווה נוד 1 שורש נקודה right שווה נוד 2. אני אפילו מוסיף אותם פה לרשימה, רנטו את הvalues, וזהו. ואני עושה לזה

72
00:28:56,860 --> 00:28:58,560
יכול לעשות לזה Run Cell

73
00:28:59,800 --> 00:29:05,520
וכן, הוא פשוט מדפיס את הרשימה הזאת כמו שראיתם עכשיו, כן?

74
00:29:06,160 --> 00:29:13,360
הנה ה-Value של Root ואז ה-Root.Left.Value, אה כן, תראו, אתם ממש יכולים לכתוב את זה.

75
00:29:14,120 --> 00:29:26,140
ראיתם קלאס  נקודה שדה שלו, נקודה כי השדה בעצמו הוא Node  נקודה ואליו וזה עובד, רצף שנקודות, זה עובד לחלוטין.

76
00:29:26,140 --> 00:29:56,120
אחרי זה, אני גם הגדרתי פה עץ חדש, שזה למעשה עץ שאנחנו רואים כאן, אתם רואים כאן? עץ שהשור שלו זה 10 ואז יש לו 2, 5, 7, 12, 15, 17. אז כן, זה בדיוק מה שהגדרתי כאן. זה עץ שאני ארצה להיעזר בו כדי להראות לכם שפונקציות נוספות רצות כאן. אז עכשיו אני יכול סוף סוף להראות לכם את המימושים של מה שראיתם עד עכשיו. אני ארשה לך.

77
00:29:56,120 --> 00:30:26,120
לקחת עץ חיפוש בינארי ולהפוך אותו לרשימה אז הנה בואו תראו את זה לדוגמא, הנה הפונקציה הרקורסיבית שעושה את זה, אני מבקש להדפיס את הרשימה שאני אקבל בחזרה ואני שולח עץ לדוגמא העץ הזה, נכון? העץ שאנחנו רואים פה לגבי סוגי הריצות ה-Ordered traversals אז יאללה אז קודם כל אני אריץ את הסל הזה שמגדיר לי את ה...

78
00:30:26,120 --> 00:30:56,120
זה עובד. ואני דווקא רוצה להגיד גם סדר רמטי חוץ יותר, מהסדר, ממה לא שאתה רוצה מדי grace ומהשמח אין ממך אינני אתה יעשה דבר חוסר בריא. אין לך חוסר בריא האישי הזה לפחות כי אל תעשה אותו אותך אתה אחזור לרובה של מדען אגור. לא היום קונים להפך למדהו חשוב

79
00:30:56,120 --> 00:31:02,060
אני יכול גם להריץ את הקוד האיטרטיבי המאוד מטוסבך שראינו עכשיו.

80
00:31:02,060 --> 00:31:08,500
והיי, גם הוא עבד איזה כיף לא עבדנו לכם.

81
00:31:08,640 --> 00:31:25,540
אפשר גם להריץ אם יש לכם כוח. את הפוסט אורדר תראו את ההבדל בסך הכל. מה קורה בפוסט אורדר? בפוסט אורדר אתם רואים.

82
00:31:25,540 --> 00:31:55,480
אנחנו מביאים את ה-Left, מביאים את ה-Right ואז מביאים את ה-Value של Root. הנה פוסט אורדר, רואים? בנים ואז האף. אז זאת אומרת, זה יהיה חיות בין הזה...האם הסדר יהיה באמת ככה? בואו נגלה עכשיו. יאללה, איפה אתה? פוסט אורדר. נכון? פוסט אורדר אקרוסיב, 1, 7. 2.

83
00:31:55,480 --> 00:32:02,180
שתיים, שבע, חמש, זאת אומרת בנים, אב.

84
00:32:02,180 --> 00:32:11,560
אז זו דוגמה,אתם ראיתם, לפי המימוש הזה אנחנו יכולים עכשיו לגלות שלמעשה יש פה קצת טעות, כי זה בנים ואז צומת.

85
00:32:11,560 --> 00:32:40,280
אז תסתכלו, נניח מתחיל עם הערות, אב קודם כל הבנים שלך, הגענו לזה, קודם הבנים שלך, אז זה חייב להיות שתיים, שבע, ואז חמש, ואז כמו שאתם רואים, השורש היא האחרון, אז בכלל הסדר שאתם רואים כאן הוא לא הסדר הנכון, ואין כמו קוד כדי לראות ולתפוס את הטעות, אז שימו לב לדברים האלה.

86
00:32:40,280 --> 00:33:01,460
ראיתם? הנה הקוד שרצנו עכשיו, רק שנייה אני רוצה להראות לכם שוב. מה זה post order? זה כשאתם קודם כל מדפיסים מהתת עץ השמאלי, תת עץ ימני, ואז את הצומת הנוכחי. וככה עושים את זה.

87
00:33:01,460 --> 00:33:31,240
יש לנו גם את הקוד שאולי אתם ראיתם בהרצאה עצמה. אתם זוכרים בהרצאה היה לכם, בוא נראה איפה הקוד שחיפשנו, אהה, כן. הנה התרגיל, כתבו פונקציה שמקבלת עץ ומדפיסה את עברי העץ לפי רמות, אוקיי? זאת אומרת, זה מדפיס ממש פר רמה. אז באמת,

88
00:33:31,240 --> 00:34:01,240
איך זה עבד, אנחנו לקחנו עץ, ודבר ראשון חישבנו את הגובה של העץ, נניח אתם זוכרים איך זה היה נכון? זה כאילו, זה החישוב של ממש כאילו מרחק עד לעלה, הכי הכי למטה, כדי שיהיה לנו בעצם תחום של גבהים, אז זה מה שזה באמת עשה, עשינו גט הייט שלנו לכל אחד מתתי העצים, חישבנו את המדרגות, עשינו גט העץ שלנו לכל אחד מטטא העצים, חישבנו את הורים שאינם מושומים לראות לך בעצם הדרך שאתה צריך להיות לפנות מביא את זה,למדבר את זה לדעת להבטיח את זה, וחשבנו שהצ

89
00:34:01,240 --> 00:34:31,240
מרסק מפריט לפריט איפה ממדבר מהממשק כמוגבד

90
00:34:31,240 --> 00:35:01,240
מדפיסים את הצומת שאחרי שחיסרנו כל פעם מינוס 1 מהלבל הנוכחי עד שהגענו לאפס. הרעיון הוא שכאילו אנחנו תמיד נדפיס ככה נניח אני מחשב את ההייט של העץ הזה ההייט הוא כמה? בוא נראה. יוצא לי פה 0, 1, 2, 3. כן? 1 2 3. אז ואז אני קורא לה פרינט לבל אורדר עם הייט

91
00:35:01,240 --> 00:35:30,040
כן? ואז נעשה 4 level in range מ-0 עד להייט המלא. אז קודם כל נתחיל מ-0, שולח אותו ל-print level, נכנס ל-print level עם level 0, אני בשורש, if level שווה 0. אני באמת מדפיס את הvalue של השורש. ואז זה כבר קרה, אז אני יוצא מפה, print. ואז ה-level עולה ל-1, אני קורא ל-print level, print level.

92
00:35:30,040 --> 00:35:59,840
האם level הוא 0? לא, אז אני עושה print level ל-3 left ו-3 right עם level שאני מחסיר מהם 1. אז עכשיו יורד לכאן 3, יודפס קודם ואז 10 יודפס קודם ואז הם יצאו החוצה ופה חוזר חלילה, עכשיו ה-level שלי צריך להיות 2. וזה כן, ועכשיו ירד למטה לבנים שמאל וימין, ידפיס את המשמאל ימין עד שלה-level הדרוש. אז הנה, אני רוצה באמת להראות לכם.

93
00:35:59,840 --> 00:36:29,640
אני אריץ את הסל הזה, עם העץ, להזכיר לכם, אנחנו מדברים על העץ הזה. העץ שיודפס לנו כאן, זאת אומרת מה שהוא ידפיס לנו לפי גובה, הוא ידפיס את 10, אז 5, 15 ואז 2, 7, 12 ו-17. אז הנה, בואו נריץ באמת את הפונקציה הזאת מההרצאה. הנה, level order traversal.

94
00:36:29,640 --> 00:36:57,900
10, 15, 10 ואז 2, 7, 12, 17. זה עובד, וראינו עכשיו גם למה זה עובד. נפלא. אז בואו ננסה לחזור חזרה לתרגול, יצירת עץ חיפוש בינארי מרשימה, בואו נראה, list of three, היי, לא ראינו את זה, אוקיי, אז בואו נדבר על זה עכשיו.

95
00:36:58,880 --> 00:37:28,560
אז נניח שיש לנו פונקציה שהיא נקבלת רשימה שהיא ממויינת, אוקיי, רשימה ממויינת, נניח שאנחנו נקבלים את הרשימה הזאת, ואנחנו רוצים לבנות ממנה את העץ הזה, נכון? אז איך אנחנו נעשה את זה? בואו ננסה לחשוב על זה שנייה. אפשר לחשוב על זה קצת לפי הרעיון שראינו בחיפושים ומיונים, אם אתם חושבים על זה.

96
00:37:29,400 --> 00:37:59,400
כי תראו מה בעצם אנחנו עושים, זה כאילו קצת מרגיש כאילו שאנחנו עושים פה חלוקות. נכון? תראו מה שאנחנו יכולים לעשות, אנחנו יכולים לכתוב פונקציה רקורסיבית. זה יכול להיות מאוד נוח.  כשתקבלת רשימה הזאת ונגיד רקורסייה קודם כל תנאי יצירה. אם הרשימה שלנו רקע, אוקיי אז כלום. אחרת אנחנו נחשב אמצע, זאת אומרת...רים

97
00:37:59,400 --> 00:38:29,400
הולך להיות באמת האינדקס של אמצע הרשימה, ניקח את הרשימה ערך לה היא, אורך שלה, נחלק בשתיים. ועכשיו נגיד שהצומת שאנחנו עכשיו נגדיר בעץ, הוא פשוט נבנה node מהעיוור שהוא נמצא באמצע של הרשימה כרגע. ואז מה נגיד? נגיד שהצומת הבן השמאלי שלנו הולך להיות ה...

98
00:38:29,840 --> 00:38:59,840
של הריקורסיה הזאת כשנשלח לה רק את הבאמת החצי השמאלי של הרשימה והבין הימני היא התוצאה של הריקורסיה כשנשלח לה רק את החצי הימני של הרשימה. אתם רואים למה? תסתכלו על הסלייסים. חצי שמאלי של הרשימה הוא חצי שנגמר במידל - לא כולל - כי מידל זה כבר הרות עכשיו והחצי הימני של הרשימה זה חצי שמתחיל החל ממידל פלוס אחד עד הסוף הרשימה. מאוד

99
00:38:59,840 --> 00:39:29,840
אז נזכיר קצת את הרעיון של מרצוט. פשוט, זה הקטע בבינארי או עץ חיפוש בינארי. כן? אתם ראיתם בהרצאה איך שעץ חיפוש בינארי, האמת, מתפקד מאוד, מאוד דומה, לחיפוש בינארי, שלמרתם. זה בעצם אותו רעיון. אז אנחנו יכולים לקחת רשימה ממויינת, ולבנות ממנה עץ חיפוש בינארי. די מאוזן, אפילו הייתי אומר. ממש בצורה הזאת. והנה, אתם יכולים גם לראות דוגמה על איזה רץ.

100
00:39:29,840 --> 00:39:50,840
בואו נראה, list of tree, נקבל sorted list, אה, לא בניתי את זה, אין בעיות, בואו נבנה את זה. הנה, יש לנו פה, קודם כל, נעריץ את ההגדרה של Node, ואז, הנה, איפה השאלה שלנו,

101
00:39:50,840 --> 00:40:19,840
לפרום, אז אני אגיד עכשיו, LST שווה, נביא מכאן את זה, ויאללה, בואו נקבל מזה. עכשיו נעשה, אה, זה ייתן לנו באמת העץ, נכון. אז אם אני אעשה, אם אני אנסה לעשות עכשיו, פרינט של, אה, list of tree עם ה-LST שלנו, משהו יתפקח.

102
00:40:19,840 --> 00:40:48,840
משהו ידפיס, לא בטוח שזה יהיה כל כך ידידותי למשתמש, כן, הוא פשוט יבנה לי Node, אז, מה שאני יכול לעשות, אני כן רוצה לשכנע אתכם, במקום לעשות פרינט לזה, דווקא אני אעשה את ה-LST הזה, עכשיו, היה לנו, את הפונקציה הקודמת משאלה אחת, convert BST to List, אוי, זה הולך להיות ממש מצחיק, תראו מה אני אעשה.

103
00:40:48,840 --> 00:41:18,840
מה שמצחיק תראו מה אני עושה, עכשיו תראו תראו את הסדר פעולות כאן. נריץ את הסל הראשון שמגדיר node הגדרנו node. עכשיו אני אריץ את listto-tree. lst שווה זה. עכשיו אני אגיד tree שווה ליסטו-tree.

104
00:41:20,280 --> 00:41:50,280
עם lst, רגע לא עשינו. אני על הדרך, אני ארצה להריץ את השאלה ראשונה. פשוט אריץ אותה כדי שהפונקציה bst-to-list.recursive תהיה לי קיימת, אתם תראו למה, אני רנצל, הגדרנו את הפונקציה הזאת, הרצנו את זה, אנחנו עכשיו עושים פה פייתון מתקדם.בנאם אנתחמים קובעים. עכשיו! ...אני מגדיר

105
00:41:50,280 --> 00:42:19,080
את הליסט כאן, בונה את ה-TREE מהליסט הזה, ואז עכשיו אני אעשה rebuilt lst שווה ל-BST-TO-LIST-RECURCIVE מה-TREE הזה, ואז אני רוצה לעשות פרינט ל-rebuilt lst. זה אמור לעבוד, זה עבד. וראיתם מה עשינו, הקדמנו את הרשימה הזאת.

106
00:42:19,080 --> 00:42:48,880
בנינו ממנה TREE, בנינו מחדש את הרשימה בעזרת הפונקציה BST-TO-LIST-RECURCIVE שהייתה לנו משאלה אחת, ואת ה-rebuilt lst הזאת, זה מה שהתפסנו עכשיו בפרינט. אז אתם רואים? הפונקציה הזאת, list-TO-TREE, שהיא, מה היא עושה? היא בסך הכל לוקחת רשימה ממויינת ובונה עץ חיפוש בינארי, לפי אותה לוגיקה של חיפוש בינארי, אפילו מופשטת, כי כבר יש לכם משהו ממויין, אז הנה.

107
00:42:48,880 --> 00:43:18,880
זה באמת זה, זה עובד. הצלחנו כנגד כל הסיכויים לעשות את מה שרצינו. עכשיו אז הנה. הנה אני יכול גם לקחת את הפרינט הזה, להחזיר אותו חזרה. אוקיי, אז ראיתם רשימה קושרת. לא רשימה קושרת איזה ... רשימה ממויינת. הגדרנו מידל, בנינו צומת מהמידל ולפט שלחנו לו...

108
00:43:18,880 --> 00:43:48,880
תת רשימה, תת רשימה, אתם רואים, הכל מתערבב, החצי השמאלי של הרשימה הממויינת והתחצי הימני, מקדירים אותו לפי החצי הימני של הרשימה הממויינת. וזה עד כדי כך פשוט. כיף! ...אז זה אט עיגול. אז נכון, הגדרנו עץ בינארי עד עכשיו, עץ חיפוש בינארי, ראינו לבנות רשימה ממויינת מיעץ חיפוש בינארי, ראינו איפה צריכים לבנות יותר טוב

109
00:43:48,880 --> 00:43:56,520
סוגי ריצות עכשיו, עשינו את ההפך, קיבלנו רשימה ממוענת ובנינו מזה עץ חיפוש בינארי, הוא אפילו היה מאוזן.

110
00:43:59,000 --> 00:44:18,600
ועכשיו, בואו נעבור לשאלה הבאה בתור. מרחק בין צמתים. אוקיי, נניח שבאמת יש לנו כזה עץ חיפוש בינארי, והיינו רוצים למצוא את המרחק המינימלי בין שני צמתים, זאת אומרת, תחשבו על זה. נניח שאני...

111
00:44:18,600 --> 00:44:48,360
מסתכל על הצומת הזה, שיש לו ערך 5, והצומת הזה, שיש לו ערך 12. ואני רוצה למצוא, תקשיבו, המרחק המינימלי ביניהם. מה זאת אומרת? זאת אומרת, אני צריך את המינימום מעבר צמתים שצריך, כדי להגיע לצומת השני מהצומת הראשון. איך הייתי עושה כזה דבר? או נניח, לא יודע, הצומת...

112
00:44:48,360 --> 00:45:18,280
שתיים לשבע, מה שאני צריך לעשות, זה בסך הכל מי שתיים, לעלות לאבא, ואז לרדת לשבע. אז איך אני הייתי עושה כזה דבר? איך היינו מחשבים את המרחק הזה? אז אם נחשוב על זה, דבר ראשון, אפילו כשזה היה בין 5 ל-12, או בין 2 לשבע, הדבר שתמיד נכון, הוא שאנחנו חייבים להגיע לליסט קומון אן.

113
00:45:18,280 --> 00:45:29,600
אנסטר ביניהם, זאת אומרת, צריך למצוא את הצומת הכי נמוך שהוא אב משותף איפשהו בדרך לשניהם.

114
00:45:29,600 --> 00:46:08,933
ואז מה שקורה, המסלול המינימלי הזה עובר דרכו, זאת אומרת, נניח מחמש לשתים עשרה מה אני עושה? אני עובר את הדרך מחמש אל הלליאיסט קומונט אנסטר ואז נשאר לי לחשב את הדרך ששתיים נפגעים באזור מכך נסייפת אותך. הזמן להחזיק את הזמן שלך להטיל לדעת אחד אוהבת ממשיך באזור שאתה לא רואה שלא חושב עם מישהו עוד אצלהם בטוח שלך ורגיש שאתה לא צריך לזה ו

115
00:45:29,600 --> 00:45:59,420
ואז מה שקורה, המסלול המינימלי הזה עובר דרכו. זאת אומרת, נניח מ-5 ל-12 מה אני עושה? אני עובר את הדרך מ-5 אל ה-least common ancestor, ואז נשאר לי לחשב את הדרך ש-12 עושה עד ל-least common ancestor. תחברו את זה, ואתם בעצם תקבלו את המסלול המינימלי. זאת אומרת, אני צריך לעשות פה בדיוק שני דברים. לחשב.

116
00:45:59,420 --> 00:46:29,100
ל-least common ancestor לשני הצמתים, ואז לחשב את החיבור של המרחק בין 5 ל-LCA ו-12 ל-LCA. כשאני אעשה את זה, הסכום הזה הוא בדיוק המרחק המינימלי. אז אתם ממש יכולים למצוא את זה כאן. פונקציית המרחק הדרושה בשבילנו, קודם כל דורשת שנחשב את ה-LCA, ל-least common ancestor. עכשיו בגלל שזה...

117
00:46:29,100 --> 00:46:59,100
עץ חיפוש בינארי מציעת ה-LCA היא הרבה יותר קלה ממה שאתם ראיתם בהרצאה. אני לא יודע אם אתם זוכרים אבל בהרצאה היה לכם חישוב LCA בעץ שהוא אפילו לא בהכרך חיפוש בינארי, נכון, ואז מה שהייתם צריכים לעשות שמה זה איזושהי פונקציה שאני לא בטוח אם אתם הבנתם אותה אבל בעקרון הפונקציית חיפוש

118
00:46:59,100 --> 00:47:12,020
איפוס אב קדום משותף, הייתה כזה דבר, אתם רקורסיבית, קודם כל בדקתם, האם יצאתם מהעץ, אז כלום.

119
00:47:12,740 --> 00:47:24,260
אם הרקורסיה נפלה על אחד משני הצמתים הנכונים, אז רקורסיה אמרה, אוקיי, תחזיר את אותו צומת, ואז מה הפואנטה?

120
00:47:24,780 --> 00:47:54,780
הפואנטה היא, שאם מתישהו ברקורסיה, כשאתם עולים חזרה למעלה, מתקפלים ברקורסיה, הגעת למצב שבו LCA left, זאת אומרת LCA על תת עץ שמאלי, מצא צומת, פה, וגם LCA ימני, מצא צומת, זאת אומרת, במקום הכי נמוך בעץ שבו, גם LCA left, מצא צומת וגם LCA right מצא צומת, המקום הכי נמוך,

121
00:47:54,780 --> 00:48:24,780
אתם רואים? If LCA left and LCA right, אז הוא הוא הולך להיות ה... הוא ממש הולך להיות ה-least common ancestor, ה-lowest common ancestor, זה זה. ברגע שמצאתם גם בטאטא צמני וגם בטאטא צמני את שני הvalues האלה גמרנו, זה LCA. ומכן ועלה זה פשוט לעשות ריטרן ב-recurse-יה up up up את אותו צומת LCA

122
00:48:24,780 --> 00:48:53,800
על זה, כשהיה מדובר בעץ בינארי ולא ידעתם אם הוא עץ חיפוש בינארי או לא, זה היה ברצה, אבל כשזה עץ חיפוש בינארי, אז פתאום למצוא את ה-LCA זה קצת פחות מסובך. אתם רוצים לדעת איך? תסתכלו. נניח באמת שאנחנו רוצים למצוא את ה-LCA, אבל בעץ חיפוש בינארי, ששני values, אז הנה מה אנחנו עושים.

123
00:48:53,800 --> 00:49:23,500
אם הערך המקסימלי בין שני צמתים נמצא בתת העץ השמאלי שלנו, אז זה בדיוק מה שאנחנו נעשה. אנחנו נעשה ריטרן רקורסיבי, נחפש בתת העץ השמאלי. כי ברור לנו שהאב הקדום הכי נמוך לשני ערכים, הוא יהיה חייב להיות בתת העץ השמאלי, כי שני הערכים עצמם הם קטנים ממש.

124
00:49:23,540 --> 00:49:53,460
מהערך של הצומת הנוכחי. או להפך, נגיד שאם הערך הקטן בין שני הצמתים נמצא מימין, אז שולחים את זה לתת עץ ימני. אחרת? אנחנו כבר הגענו. זהו, הגענו. נכון? תסתכלו. נניח רציתם, סתם דוגמא. שתיים.

125
00:49:53,780 --> 00:50:23,440
ושבע. אז הנה איך שאנחנו מסתכלים על עשר. עשר גדול יותר משתיים ושבע. אז נוריד את עשר למטה. עכשיו אנחנו מסתכלים ב-LCA BST שלנו, אנחנו נמצאים על חמש. חמש, לא גדול מהמקסימום בין שניהם, והוא גם לא קטן מהמינימום בין שניהם. זהו, מצאנו. זאת אומרת ה-LCA נמצא כאן. נכון? זה לא היה קשה.

126
00:50:23,440 --> 00:50:53,440
עכשיו זה לגבי ה-CA מה לגבי החיפוש מרחק העומק אז מה אנחנו עושים פה אנחנו באמת צריכים כבר לעשות חישוב כזה ככל שאנחנו יורדים למטה אל העלה הדרוש לא העלה דרוש האמת צומת דרוש אנחנו צריכים להוסיף אחד פלוס ואז בחישוב רקורסיבי אז מה נעשה? אנחנו רוצים למצוא את העומק מ צומת כלשהו

127
00:50:53,440 --> 00:51:23,440
לצומת שיש לו את הvalue שאנחנו מחפשים. אז מה נעשה? קודם כל, אם אנחנו ירדנו לכלום, לפנות root, אז מינוס 1, זאת אומרת, אין פה אפילו מרחק לחשב, זה חישוב טעות תעלה למעלה. אוקיי, נניח שהשאלה יכולה להיות באצטרך נמצא שהוא כן אמיתי, הנה השאלה. מה אנחנו אומרים? איף הvalue שאנחנו מחפשים הוא קטן מהvalue של הצומת הנוכחי.

128
00:51:23,440 --> 00:51:53,440
אז זה נמצא בתת העץ השמאלי שלנו, זאת אומרת, נוסיף אחד לדרך לשם, פלוס תוצאת הריקורסיה בתת העץ שמאלי. אחרת, אם הvalue הוא גדול, אז נלך לתת העץ ימני. אחרת, אם הvalue הוא לא קטן ולא גדול, מצאנו. ונחזיר 0, כי זהו. אין עוד לאן ללכת. ואז מה הפתרון בסך הכל? פתרון היה קודם כל למצוא את ה-LCA שלהם,

129
00:51:53,440 --> 00:51:59,600
ועשינו את זה, ולבסוף התוצאה היא סכום של מה?

130
00:51:59,600 --> 00:52:10,520
המרחק בין, אתם רואים? הקומונ נוד LCA ובין value 1 ועוד המרחק הפיין דפט בין הקומונ נוד value 2.

131
00:52:10,520 --> 00:52:23,380
זה בעצם תרגיל 3. אז הנה אני יכול עכשיו להביא לכם את הקוד של תרגיל 3 אתם רואים? יש לנו את הקוד של LCABSD את ה-Fine Depth.

132
00:52:24,060 --> 00:52:41,320
distance, ופה באמת יש לנו את הדוגמת שאתם ראיתם בשקופית, הנה אני עכשיו אריץ ואגדיר את התרי המדובר, התרי שראיתם בתרגול, עכשיו נלך לשאלה שלוש.

133
00:52:41,720 --> 00:53:07,180
מה הוא כתב לי שלוש ושתיים? אני ביקשתי ממנו שהדפיס לי את הדיסטנס בין צומת חמש ושתים עשרה, קיבלנו מרחק שלוש, חמש, שתים עשרה, וגם בין הצומת שתיים ושבע, קיבלנו את המרחק שתיים. אז עד כאן, זה עובד כפי שציפינו, איזה כיף?

134
00:53:07,180 --> 00:53:37,040
אוקיי, שאלה ארבע, הפעם יש פה קוד ו התפקיד שלנו להבין מה לזזל הוא עושה, מה הפואנטה שלו. שאלה אגב, זו כבר שאלה מהסוג שאתם יכולים להיתקל בה במבחן של הנה קוד, תגידו מה הוא עושה, האם יש בו בעיות, תקנו, כאלה שטויות, בואו נראה, מוגדרת לנו פה פונקציה. אגב,

135
00:53:37,100 --> 00:54:06,940
פונקציה עם עץ בינארי, מבנה של עץ בינארי, כן? כן? אוקיי. אז פונקציה אקרוסיבית, אם הצומת הוא כלום, אז ריטרן טרו, אוקיי? זאת אומרת, יש פה איזשהו תנאי שהוא מתקיים בצורה ריקה, זאת אומרת, יש יותר סיכוי שיהיה פה תנאי שאנחנו נשבור אותו, עם משהו לא בסדר, אוקיי? מה קורה? אז פה, זה אם...

136
00:54:06,940 --> 00:54:36,940
רוצע. משום שהקומטודה טובה. בטח. מן הסבר גרוע. וממה...APISED. מבוא...נים. הפרוץ נקודה  לבט,  מן הדברים הבאים. משום ש"איפה שאתה מרגיש...

137
00:54:37,600 --> 00:55:06,560
true, if, if, true if zero. שימו לב, אם אנחנו עלה, אז נחזיר true רק אם הערך שלנו הוא 0. אוקיי. ואז שאלה אחרת. אם אנחנו לא עלה, אז יש לנו לפחות בן אחד, אז פה שאלה, אם יש לנו רק בן ימני, למה? כי if root left is non, אבל עברנו את האנד הזה.

138
00:55:06,560 --> 00:55:26,560
שרדנו אותו, אז יש בן ימני, השאלה, אז מה אנחנו נחזיר? ריטרן עם root value שווה שווה ל root right value פלוס אחד, וגם אם התנאי אכן מתקיים עבור root right.

139
00:55:28,880 --> 00:55:58,860
אהה, זאת אומרת, משהו כזה, if only one sun, אז root value has to be sun פלוס אחד, and sun must also, must also, you know, meet requirement.

140
00:55:58,860 --> 00:56:25,440
לא יודע, אנחנו מנסים להבין פה את הפונקציה, אני מנסה לסמלץ פה מבחן, כאילו, אני, זה משהו שאולי אתם הייתם כותבים בעברית או בערבית, לא משנה, אבל מנסים ככה לחשוב, אוקיי. התנאי פה הוא אותו דבר פשוט הפוך, בסדר? ונניח אם יש שני בנים, אז מה קורה? left value, right value, ואז if valid צריך להיות.

141
00:56:25,440 --> 00:56:54,180
אם root value שווה שווה אחד, root המינימום שבין ה-left value וה-right value, זאת אומרת, if two suns, root value שווה שווה אחד פלוס min between suns, מעניין.

142
00:56:55,080 --> 00:57:21,920
אז מה זה יכול להיות? בואו נראה אם אנחנו יכולים להבין ממה שאנחנו קוראים פה. כאילו, אנחנו כן מבינים ש-על׳ה, 0, כלום, true. אם יש בן אחד, אם יש בן אחד, אז אנחנו צריכים את פלוס אחד ממה שיש לבן.

143
00:57:22,620 --> 00:57:52,520
אז זאת אומרת, אולי יש פה מרחק לעל? אולי יש פה מרחק לעל? זאת אומרת, הערך של צומת צריך להיות מרחק לעל, וכשכתוב פה שני בנים, זה חייב להיות מינימום, אז יש מצב שהפונקציה הזאת באה לבדוק בעץ, עם הערך של כל צומת, כי אתם רואים, עבור כל צומת יש פה דרישה.

144
00:57:52,520 --> 00:58:22,520
וזה גם מתקיים עבור צומת וגם עבור הבנים שלו. אז זאת אומרת, יש פה דרישה עבור עץ, שכל צומת בעץ, הvalue שלה יהיה לדעתי, המרחק המינימלי אל עלי. זה חייב להיות, כי תראו, הדרישה הייתה שעבור כל עלי יהיה אפס,

145
00:58:22,520 --> 00:58:33,880
ואבו, לא יודע, אבו נניח צומצ'שרוק בין אחד אז הוא חייב להיות, אבל יש לו חייב להיות אחד פלוס מה שיש בתאט היחיד שיש לו.

146
00:58:33,880 --> 00:58:47,640
וגם תאט היחיד שלו, שלו חייב להנות לתנאים, והתנאים אומרים בין היתר אם אתה עלה אתה חייב להיות אפס, אם כבר כלום אז בסדר. אז לדעתי זה מה שזה אומר.

147
00:58:47,640 --> 00:59:16,640
ודרך אגב, פונקציה הזאת, אנחנו יכולים כמובן להריץ אותה ולבדוק אותה. אז הנה, אני הריץ את ההגדרה של Node, עכשיו נלך ל-Question 4. הנה הפונקציה שקראנו עכשיו. אז בואו נבדוק אותה לשני סוגים של עצים. קודם כל נבדוק אותה על העץ, נבדוק אותה על העץ הזה, שדרך אגב, כמובן שהוא לא עונה לתנאים. וחוץ מזה...

148
00:59:16,640 --> 00:59:46,640
אנחנו נבדוק אותה גם על העץ הזה, שזה, יש לי תחושה, זה עץ טוב שהוא עונה על התנאים. זה גם העץ שאנחנו Atlas מגדירים פה בתור Good Tree, תראו, הנה הגדרה של Node שנראית דומה קצת למה שראיתם בדקסיונריז, כי אני אומר פה Node, צומת, שזה בעצם השורש, וה-key אחד, הבין השמאלי שלו, זה Node עם גם value אחד.

149
00:59:46,640 --> 01:00:16,640
ואז יש לו שני בנים שהם 0, והבן הימני שלו הוא רק 0 וכלום. זאת אומרת מה שאתם רואים כאן. אז זאת אומרת לדעתי על העץ הקודם שראינו הוא יחזיר false והעץ הטוב הוא יחזיר true. אגב הפונקציה שוב פה זה פשוט copy paste מהתירגול run. אוקי, הוא יחזיר false, יחזיר true.

150
01:00:16,640 --> 01:00:27,680
יפה, כמובן שאם יש לכם ספק אתם יכולים לקחת עץ אחר, תביאו עץ אחר פה, תריצו על זה, ותראו אם זה עובד או לא עובד.

151
01:00:29,680 --> 01:00:44,260
מעניין. טוב, מקווה ששרדתם את כל הדיבור על עצים, בואו עכשיו נחליף קצת דיסקט, ונדבר על בקטרקינג. אוקי.

152
01:00:44,260 --> 01:01:12,000
בקטרקינג בעיקרון זה נושא קצת כבד, במובן למדעי המחשב, כי בבקטרקינג מה שקורה, אנחנו לוקחים את הקונספט הזה של ריקורסיה, ואנחנו קצת מסבכים אותו. מה זאת אומרת מסבכים אותו? אנחנו בבקטרקינג, יש שני סוגים גדולים של בעיות שאנחנו פותרים בבקטרקינג. בעיה ראשונה, זה...

153
01:01:12,000 --> 01:01:41,800
לחפש כמה פתרונות תקינים יש לבעיה כלשהיא ודבר אחר שאנחנו עושים בבק צ'קינג זה גם לבדוק האם פתרון כלשהו שאנחנו בונים תוך כדי יעבוד ואם בנקודה מסוימת הוא לא יעבוד אנחנו חוזרים אחור רקורסיבית. נשנים.

154
01:01:41,800 --> 01:02:11,800
פרמטר ואז ממשיכים קדימה ברקורסיה שוב. זה קצת משהו יותר מסובך, כי זה בעצם לכתוב פונקציה שהיא רקורסיבית, אבל היא קוראת לרקורסיה שלה בתנאים וגם בלולאות, וזה יכול להיות מבלבל אם אנחנו לא בדיוק מבינים איך לגשת לזה. אז פה בתרגול אנחנו נראה שתי דוגמאות מאוד קלאסיות לרקורסיה, אפילו לפני זה אני...

155
01:02:11,900 --> 01:02:21,160
אז נראה עוד דוגמא, אנחנו נראה דוגמא ושני תרגילים ואני רק מקווה שאני אצליח לגרום לכם להבין את זה. אז לאט לאט.

156
01:02:22,500 --> 01:02:41,060
בקצ'קינג זה באמת החלק המרכאות הקשה בתכנות, לפחות כשמתחילים ללמוד תכנות, אז לאט לאט. אוקיי בואו נתחיל באמת מנייזר בעץ כי ראינו את העץ הזה כל כך הרבה פעמים בתרגום. או עץ עם מרכים שונים סוף סוף. אוקיי.

157
01:02:41,060 --> 01:03:10,920
דמינו שיש לכם עץ, יש לו ערכים חיוביים ואנחנו רוצים לכתוב פונקציה שהיא סופרת כמה מסלולים יש משורש עד לעלה כלשהו, ככה שסכום הערכים מאותו שורש עד לעלה שווים בדיוק לאיזשהו סאם שאנחנו מקבלים, איזשהו סכום. אז לדוגמא אומרים לנו קחו את העץ הזה.

158
01:03:11,000 --> 01:03:40,620
וקחו סכום 14. תספרו כמה מסלולים יש מהשורש לאיזשהו עלה שסכום הערכים הוא בדיוק 14. אז תראו, פה ספציפית, יש רק 4 מסלולים אפשריים בעץ הזה להעלה נקודה, נכון? יש לנו את 532, 536, 584, 581, זה עץ פשוט.

159
01:03:40,620 --> 01:04:10,620
הקוד שאנחנו צריכים לכתוב הוא קוד שיעבוד בלי קשר, אבל זה לא בגדיל, כי מה אנחנו יודעים מעץ בינארי? בעץ בינארי יש צומת, בן שמאל, בן ימין, זהו... אז, בואו נראה, כמה בין מסלולים עונים על סכום 14? 5 ועוד 3, זה 8, 8 ועוד 6, 14, יופי, זה בתוך מסלול, זה לא ילך...

160
01:04:10,860 --> 01:04:20,440
חמש ועוד שמונה, שזה שלוש עשרה, ועוד אחד ארבע עשרה, זאת אומרת שני מסלולים, אתם רואים?

161
01:04:21,440 --> 01:04:26,820
ואנחנו צריכים לכתוב קוד שידע לעשות את זה, אז בואו תראו דוגמא לפתרון.

162
01:04:27,660 --> 01:04:40,440
אנחנו יכולים לכתוב פונקציה רקורסיבית, שלא, היא לא כזאת בגדיל, האמת, אני אפילו לא יודע אם יישווה לקרוא לזה Backtracking, תראו מה, אנחנו נגדיר פונקציה.

163
01:04:40,440 --> 01:05:09,620
נסכום דרכים, יש לנו את הרות ויש לנו את הסכום הדרוש, אז ככה, אם אנחנו ירדנו ברקורסיה לצומת שהוא כלום, אין בעיות, אז נניח שירדנו עד הסוף, ואנחנו נחזיר, האם ירדנו גם לסאם, כי אנחנו נחזיר מהסאם כל פעם שנרדת ברקורסיה, נחזיר אם סאם שווה שווה לאפס, זאת אומרת אם סיימנו לרדת עד הסוף,

164
01:05:09,620 --> 01:05:39,540
ואם סאם שלנו הוא אפס, זאת אומרת, חישבנו, מסלול בדיוק מתאים, אז זה יכול להיות True או False, זה יכול להיות כאילו אחד או אפס, נכון? כאילו, אתם יודעים, בוליאן, True זה כמו אחד, ו-False זה כמו אפס, אפשר אולי להגיד משהו אחר, אם בטעות הקטננו את סאם יותר מדי, וירדנו מתחת לאפס, אז נחזיר אפס, זה לא מסלול, אז מה אנחנו יכולים לעשות?

165
01:05:39,540 --> 01:06:09,520
נגדיר קאונטר מסלולים לתת עץ השמאלי, ואז אנחנו גם כשנרד לתת עץ שמאלי, נפחית מהסאם שקיבלנו את הvalue של הצומת הנוכחי, כן? נחשב גם קאונטר עבור תת עץ ימני, שוב, נחסיר את הvalue מהצומת הנוכחי, זאת אומרת, נחסיר value של הצומת הנוכחי מהסאם, ונבדוק עבור תתי עץ הימני, ובסך הכל, נחשב את הסכום.

166
01:06:09,520 --> 01:06:39,500
של שני הדברים האלה, באמת, אני אפילו לא יודע אם אפשר לקרוא לזה בקטרקינג, עכשיו יש לי שאלה אחת בשבילכם, בין אם זה בקטרקינג ובין אם לא, האם אתם מצליחים לראות, האם אולי במקרה, יש פה קצת תקלה קטנה בפונקציה הזאת, האם אתם מצליחים להבחין במשהו שהפונקציה אולי עושה...

167
01:06:39,500 --> 01:07:09,500
זה יותר מדי. יכול להיות? בואו נעשה סימולציה. נניח שאני באמת רוצה לספור עבור סם שווה 14. בואו נתחיל. ניכנס ל root,  root וסם 14. אזRIS הוא לא none, סם לא קטן מאפס. אז נלך ל-Left Pаствed Counter ו- Right Pav istemודעת, אין בעיות  נקרא אקורסיבית עבור root left ו root right

168
01:07:09,580 --> 01:07:32,020
ונחסיר מסם את רוט ואליו זאת אומרת בואו נסתכל תת עץ השמאלי בסדר? אני יורד לתת עץ שמאל רוט שלי עכשיו זה הצומת הזה סם זה 14 פחות 5 9.  אוקיי. 9. אז מן הסתם, שגם פה אני צריך ללכת לתת עץ שמאל תת עץ ימין

169
01:07:32,020 --> 01:07:42,680
אם אני אלך פה עכשיו בתת את שמאל, אני ארד מתשע לשש, פה, כן? root נקודה לבצעמ מינוס root value.

170
01:07:42,680 --> 01:08:00,760
ובשתיים הזה, לא משנה מה אני אעשה, גם אם אני ארד משש פה לארבע, כשאני אסתכל על הנן שמאל שלו והנן ימין שלו, התשובה תהיה לא, Sam שווה שווה 0 היא תהיה לא נכונה, וזה יעשה לי return false משניהם, שזה 0.

171
01:08:00,760 --> 01:08:14,920
אוקיי, אז אפשר להתעלם מזה, לא אלך. אבל מה יהיה כשאני ארד לפה? אוקיי, אז בואו נראה, 14, פחות 5, 9, פחות 3, 6, עכשיו הגעתי לשש.

172
01:08:14,920 --> 01:08:30,660
הרוט שלי עכשיו הוא 6, Sam בעצמו הוא 6, ואני קורא left part counter ו right part counter, זאת אומרת, אני קורא אקרוסיבית גם לנן שמאל שלו ונן ימין שלו, אני עושה Sam פחות root value.

173
01:08:30,660 --> 01:09:00,020
6, פחות 6, 0, אז אתם יודעים מה קרה? יש לי פה שתי קריאות רקורסיביות שהורדתי בהן את Sam ל-0 בדיוק, ו-root הופך להיות נן, אתם יודעים מה זה אומר? ריטרן, אם Sam שווה שווה 0. יהיה לי פה true, ויהיה לי פה true, כלומר יהיה לי פה אחד ופה אחד. הקוד הזה יספור לי כפול כל מסלול תקין.

174
01:09:00,020 --> 01:09:30,020
למה? כי אחרי שאני פה ב-6, אני פה ב-6, הרוט הוא 6,כאילו רוט value שלי הוא 6, והסאם שלי הוא כרגע 6 בדיוק, ואני עושה את הקריאה הקורסיבית הזאת ל-6.לפט וה-6.רייט הזה, אז סאם פחות רוט value ירד לאפס, והתנאים מתקיימים פה, רוט יהיה nan, כי 6 left הוא  round ו6 right שהוא nan, וסאם... 5 אני מצליח להראינו פה את המס מונט, בדרך כלל זה משהו רציני, שאולי צפוי להפגוף את הזה שהאתה רוצה, להבדיק אתיו שהאני צריך שאתה רוצה להופך. לם בדרך כלל הוריד אותך בחג המוח לטבעות

175
01:09:30,020 --> 01:10:00,020
יהיה אפס, זה שתי קריאות שיחזירו אחד ואתם רואים מה אנחנו עושים ריטרן סכום בין לפט ורייט. אז אם הייתם חדים אתם הייתם רואים את זה די מהר ואז הקוד שכן פותר את זה הוא רק שינוי כליל על הלוגיקה, שינוי שמתחשב בזה. אז פה אנחנו דווקא נגיד משהו אחר, אנחנו נגיד קודם כל אם ירדנו למישהו שהוא

176
01:10:00,020 --> 01:10:12,280
אז פשוט נחזיר 0. ובמקום זה אנחנו נגיד כזה דבר, ניקח את הסכום הנוכחי, נחסיר ממנו את ה-value של ה-node הנוכחי, ואז מה אנחנו נגיד?

177
01:10:12,280 --> 01:10:47,546
אם אין בן שמאלי ואין בן ימני, זאת אומרת, אנחנו הגענו לעלה, אז אנחנו נגיד נעשה ריטרן 1, אם באמת הקרן שם אחרי שהחסרנו ממנו את ה-value הוא באמת 0, אחרת פשוט נחזיר 0. זאת אומרת, הרי אם כן יהיה 0 נצלים אליו מתיוחד כדי לו להחזיק את זה בבן שמאלי או בשתהה ושלמי. להחזיק את זה בטקס האירונטואירית והפועלים אותו מהב

178
01:10:12,280 --> 01:10:42,280
אם אין בן שמאלי ואין בן ימני, זאת אומרת אנחנו הגענו לאלה, אז אנחנו נגיד, נעשה ריטרן אחד, אם באמת ה-curn-sum, אחרי שאיחסם ממנו אותו value, הוא באמת 0? אחרת, פשוט נחזיר 0, זאת אומרת, האלה שאנחנו נמצאים בו, לא רלוונטי. ואז אנחנו נשים את הקריאות הריקרוסיביות עבור בן שמאלי בן ימני. עכשיו, תשמעו, חייב להגיד לכם, זה לא

179
01:10:42,280 --> 01:11:03,360
ממש מרגיש לי כמו backtracking, אני לא מרגיש את הקושי, אני לא מרגיש את העצבים פה, אז כן, אני יכול להראות לכם את הקוד, ואני יכול להראות לכם שהוא רץ פה בפייתון, אבל אני לא חושב שאתם באמת הרגשתם את ה-backtracking פה, אז עוד מעט אתם כן תראו למה אני מתכוון כשאני אומר backtracking, אז רק שנייה.

180
01:11:04,060 --> 01:11:34,040
קודם כל בואו נריץ את הדוגמה הזאת, רק שתראו אותה, בסדר? פה אני מריץ את זה על העץ שאתם ראיתם פה בתרגול, זה בדיוק העץ שמוגדר כאן, אז אני אריץ את הסל הזה, מוספר 2, נניח, יש עוד דוגמה? אה, בואו לחשב את המספר המקסימלי, 17, נכון? 5 ועוד 8, 13, ועוד 4, 17.

181
01:11:34,580 --> 01:12:03,940
אז עבור 17, מה הוא ימצא? run, 1, יפה, אם אני אכתוב לו, לא יודע, 18 הוא ימצא משהו? כלום, עד כאן יפה, אם אני אכתוב לו, בואו נראה, 5 ועוד 3 זה 8 ועוד 2 זה 10, בואו נראה כמה סלולים ל-10 יש לנו.

182
01:12:03,940 --> 01:12:33,940
עשר. אחד, היחיד שראינו. טוב, מקווה שהשתכנעתם. חזרה ל-14. בעשר גמור. מקווה שהשתכנעתם שהפונקציה הזאת עובדת. טוב, אבל עכשיו, בא לי להראות לכם backtracking אמיתי. ובשביל זה, אני צריך להציג לכם את בעיית N המלכות. אחת מבעיות

183
01:12:33,940 --> 01:12:50,120
הבקצ'קינג הכי קלאסיות שיש בעולם. אז בואו נחשוב על זה. אני מקווה שאתם מכירים איך הכלי מלכה עובד בשחמט. ואם לא, אני אסביר לכם בקצרה.

184
01:12:51,120 --> 01:13:03,120
יש את הקטע הזה, שטוב, אולי האמת דווקא יעזור. בואו נראה. צ'ס אנק קווינס, אני כן רוצה להראות לכם את הבעיה הזאת.

185
01:13:03,120 --> 01:13:10,640
אוקיי, עבור לא יודע, אולי במקרה שאולי מישהו לא יודע את זה בעל פה, אז תראו.

186
01:13:10,700 --> 01:13:30,400
בשחמט יש לכם כלי שקוראים לו מלכה. על גבי לוח, הרי בשחמט זה בדרך כלל לוח שהוא 8 על 8, שיש משבצות שהן כל הזמן באלטרנציה, לבן, שחור, לבן, שחור, לבן, שחור, אתם רואים איך זה עובד.

187
01:13:30,400 --> 01:13:59,920
המלכה זה כלי שיש לו תחום תנועה לכל תור, כי זה משחק שעובד בתורות, מאוד מאוד מאוד גבוה. מה מלכה יכולה לעשות? מלכה יכולה בכל משבצת שהיא נמצאת, יכולה לזוז לכל משבצת בשורה שהיא נמצאת בה, יכולה לזוז לכל משבצת בעמודה שהיא נמצאת בה,

188
01:13:59,920 --> 01:14:29,880
והיא גם יכולה לזוז לכל משבצת באלכסון שהיא נמצאת בה, אלכסון שמאל למעלה ימינה למטה, וגם אלכסון ימינה למעלה שמאלה למטה. אתם רואים כאן את החצים הירוקים האלה? זה בעצם תחום התנועה האפשרי עבור המלכה שנמצאת כאן. מה זה בעיית אין מלכות? הבעיה הזאת היא...

189
01:14:30,320 --> 01:14:58,640
בהינתן לוח בגודל אין עליהן, אנחנו רוצים לדעת כמה אפשרויות יש לנו לשים כלי מלכה על הלוח, כך שאף מלכה לא תוכל במהלך אחד לפגוש מלכה אחרת. אז פה מצד שמאל אתם רואים איך...

190
01:14:58,640 --> 01:15:28,200
שיש לנו כאן מלקות, אבל למעשה כל המלקות האלה לא יכולות לפגוש אחת את השנייה במהלך אחד, כי הן לא נמצאות, הן כולן בשירות שונות, עמודות שונות ואלכסונים שונים. פה מימין, מצד שני, אתם רואים פתרונות לא תקינים, כי יש פה מלקות שכן יכולות לפגוש אחת את השנייה בתור אחד.

191
01:15:28,460 --> 01:15:57,660
וזה שובר את הפתרון. אז בעיית n המלקות, אנחנו בכלל אומרים, עבור לוח בגודל n על n, נרצה לנסות להציב בדיוק n מלקות. אז שאלת ה-back-tracking פה, היא שאנחנו נצטרך לכתוב קוד שינסה להציב n מלקות על הלוח,

192
01:15:58,380 --> 01:16:27,640
וכל הזמן, תוך כדי ניסיונות ההצבעה, הקוד יהיה חייב לבדוק האם ניסיון ההצבעה הנוכחי שלו תקין, כי אם לא, הוא יצטרך לחזור אחורה, לצאת רקורסיבית, עד לנקודה שבה הוא יוכל לנסות הצבעה אחרת. זה הבסיס של ה-back-tracking פה. אז סתם...

193
01:16:27,640 --> 01:16:57,200
דוגמא. עבור n שווה 1, תחשבו על זה. איפה n שווה 1, אז פשוט שימו מלכה אחת במשבצת היחילה, וגמרנו. עבור n שווה 2, תחשבו על זה, יש לנו, לא יודע, משבצת, משבצת, משבצת, משבצת. שימו פה מלכה, והיא יכולה לגשת לכל שאר המשבצות.

194
01:16:57,860 --> 01:16:59,900
אז עבור N שווה 2 אין פתרונות.

195
01:17:01,600 --> 01:17:16,440
עבור N שווה 3, נניח תשע משבצות, מה יקרה אם נשים פה מלכה, היא תוכל לראות את כל השורה, כל העמודה, וגם את האלכסון הזה.

196
01:17:17,520 --> 01:17:27,100
אז אתם אומרים, אין בעיות, נשים פה מלכה, זאת אומרת, פה מלכה ופה מלכה. אוקיי.

197
01:17:27,100 --> 01:17:56,920
יופי, I guess, אבל יש בעיה. מה הבעיה? איפה תשים מלכה שלישית? כי זו בעיית אל מלכות. אי אפשר בעמודה הזאת. אי אפשר כאן, אי אפשר כאן, כי זה באלכסון. אי אפשר פה, אי אפשר פה, אי אפשר כאן, אי אפשר כאן, אי אפשר כאן, זהו. בN שווה 3 אין פתרונות. עבור N שווה 4 לדוגמה, יש שני פתרונות אפשריים.

198
01:17:56,920 --> 01:18:17,520
באמת לשים 4 מלכות בלוח של 4 על 4, ואתם רואים כאן, ויזואלית, את הפתרונות האפשריים האלה. תראו, כל שורה יש מלכה, כל עמודה יש מלכה, אבל יותר חשוב מזה, אין אף אלכסון שבו יש 2 מלכות, או יותר, אין, כל אלכסון הוא סייף.

199
01:18:17,520 --> 01:18:47,520
ואנחנו צריכים לכתוב קוד שבונה כאלה פתרונות ויודע לסיים פתרון כזה ובסוף כשהוא מוצא פתרון מוצלח עד הסוף סופר את זה. זה תרחיש קלאסי של backtracking.  זה לבנות פתרונות, לדעת מתי לוותר ללכת אחורה ולבנות משהו אחר ובסוף כשהגענו עד הסוף נגיע לתנאי הצעירה של סיימנו את הלוח

200
01:18:48,240 --> 01:19:16,080
נעשה פשוט נעשה ריטרן פלוס אחד, זה הבקטרקינג שלנו, איך נוכל לגשת לזה? אז קודם כל נשים לב למה דרישות שלנו עבור פתרון נכון, אז באמת, מה זה פתרון נכון כאן? בכל שורה יש מלכה אחת, כל עמודה יש מלכה אחת, אז רגע, קודם כל איך אנחנו נבנה את הפתרון שלנו?

201
01:19:16,080 --> 01:19:46,040
שימו לב, לוא חן עליהן, זה בעצם רשימה דו-ממדית, נכון? זאת אומרת, שורה, שורה, שורה, שורה, אתם כבר למדתם איך אנחנו מתייחסים למדריצות דו-ממדיות וזה, פשוט רשימה של רשימות. אוקיי. אז, כמובן, בכל שורה חייבת להיות רק מלכה אחת, אז אנחנו יכולים להתחיל את הפתרון שלנו, נתחיל לבדוק, נשים מלכה.

202
01:19:46,040 --> 01:20:16,040
באינדקס 0,0, נעבור לשורה הבאה בתור ונבדוק אם אנחנו יכולים לשים באיזושהי עמודה מלכה. אנחנו יכולים להניח לנסות עמודה 0, נראה שזה לא תקין, נעבור הלאה לעמודה הבאה בתור והלאה והלאה. נשים מלכה, וככל שנעבור הלאה בשורות אם אנחנו רואים שאין לנו שום מקום תקין לשים מלכה, אנחנו נצטרך לחזור אחורה רקורסיבית עד לפעם הקודמת ששמנו מלכה. לשמה שי

203
01:20:16,040 --> 01:20:46,040
את דעתנו ולשים מלכה במקום אחר. וזה בעצם הרעיון שלנו. אז אני רוצה שתראו, קודם כל איך תראה הפונקציה הראשית. אז ככה, פה באמת אתם כמו מתחילים לראות בקטצ'קה. אז תראו, נגדיר את הפונקציה שלנו לפתור בעיית n מלכות, פרמטר נשלח לתלוח, n על n שלנו, זה מטריציה n על n, נניח שנהתחיל אותה בהתחלה עלינו,

204
01:20:46,400 --> 01:20:57,940
לצערי לתקן על המאמציה של... אתם יודעים, איבר לא יודע ערך שם יהיה לא יודע פולס או... בואו נראה.

205
01:20:57,940 --> 01:21:36,140
פולס או טרו כאילו נגדיר ערך שיגדיר מה זה שאין שם המלכה. בסדר יכול להיות פולס בסדר. הנה. איך... איך להגדיר? בורד במקום רו קולום if-safe אז נגדיר שמן שוות רו זאת אומרת שיש... אי אפשר להגיד איפה שאתה רוצה להסבל אתה צריכה להספיק את מישהו שצריך להספיק את רפתם באפלה הביא אותו מהפכנוע שלך למטרה שאתה חייב ואתה מתעודב בליחד עם מישראל

206
01:20:57,940 --> 01:21:26,520
פולס או טרו, כאילו נגדיר ערך שיגדיר מה זה שאין שם מלכה, בסדר? יכול להיות פולס, בסדר? הנה, איך נגדיר? בורד במקום row, קולום, if safe, אז נגדיר שם שווי טרו, זאת אומרת יש מלכה, נפתור עבור row פלוס 1, ואז אין בעיות, אוקיי, זה מה שאנחנו נעשה, בסדר? אז תהיו איתי, אנחנו נגדיר.

207
01:21:26,520 --> 01:21:56,480
ככה, נגדיר איזושהי רשימה כזה בורד שווה, לא יודע, רשימה של... אין בריבוע, טוב, אתם יודעים משהו, בואו אני ארמה קצת, אני פשוט רוצה לראות איך אנחנו הגדרנו את זה, אה, 0, אוקיי, יאללה, 0 זה גם פולס, נכון? 0 זה פולס, אז בואו תראו. תראו איך לאן אני מגדיר את זה.

208
01:21:56,480 --> 01:22:26,440
הבורד שלנו יהיה כזה דבר, אגב, אנחנו נעשה את זה בליסט קומפיינשן בצורה כזאת שתבנה רוז שם שונים, אני לא רוצה שבטעות תעשו פה כזה דבר, ואז עוד פעם כפול n, כן? כי יש מצב שאתם תבנו אה, לעצמכם משהו שהוא אותו דבר, זאת אומרת, זה כן טוב, ומה לא טוב, מה bad, זה אם הייתם עושים, תראו, תראו מה, תראו מה היה, מה היה ממש רעים.

209
01:22:26,440 --> 01:22:28,860
אם הייתם עושים איזה, תראו.

210
01:22:31,660 --> 01:22:32,160
רגע.

211
01:22:34,880 --> 01:22:37,180
אוקיי, הנה, מה קורה?

212
01:22:38,920 --> 01:22:42,500
אנחנו בונים לעצמנו עכשיו שורה.

213
01:22:44,380 --> 01:22:47,040
בכל זה, הייתם בונים איזה n איברים.

214
01:22:48,280 --> 01:22:56,400
או, סליחה, משהו כזה. כן? הנה. נכון? סתכלו. שורה של n איברים.

215
01:22:56,400 --> 01:23:24,220
וזה שמונה כאלה. זה היה דופק לכם את הסיפור. אני מקווה שאתם זוכרים למה, כן? קטע של אובייקטינג, שלו קופיז, דיפ קופיז. בקיצור, אתם רוצים את זה, לא זה. בסדר. אז מה הרעיון? אנחנו פשוט בונים. מתחילים לוח שבו הכל ריק. אפס בכל המקומות. זה יהיה n על n, דרך אגב. זה n על n.

216
01:23:24,220 --> 01:23:54,220
שולחים את זה ל solve n queens והוא יתחיל משורה 0 אז נמצא לעצמנו את ה n הגדול שלנו, אורך הבורד, מספר שורות, ועכשיו מה אנחנו אומרים? תראו, זה פונקציה רקורסיבית, כן? אבל פונקציה שתקרא לעצמה ותקרא לעצמה ותגדיל את אינדקס ה-rho אז אם אינדקס הרו שלנו הגיע עד הסוף, עד ל n גדול, לא n פחות אחד אלא ל0,1,3

217
01:23:54,220 --> 01:24:13,260
בעין גדול, "אור" ממש יצא מהלוח, זאת אומרת אם אנחנו יצאנו מהלוח בשורות, זה אומר שסיימנו לבנות פתרון תקין, אז נקרא לפונקציה פרינט בורד, שהיא פשוט תדפיס, תדפיס את המלכות וזה, ואז ריטרן.

218
01:24:15,580 --> 01:24:23,420
אבל זה אם סיימנו לבנות. בסדר? אז מה אנחנו עושים? אנחנו נניח שלא סיימנו לבנות, אז יש לנו...

219
01:24:23,420 --> 01:24:53,420
אז יש לנו לפחות מלכה אחת לשים. אז הנה מה שאנחנו חוטפים. אתם רואים? דרך אגב, זוהי היא התנאי הצירה של הפונקציה הרקורסיבית, שאם סיימנו לבנות, נדפיס. אם לא, נשים מלכה. מה אנחנו אומרים? לכל עמודה, נבדוק האם זה סייף לקחת את הלוח, איך שהוא כרגע, בשורה הנוכחית, בפורט

220
01:24:53,420 --> 01:25:23,420
בעמודה שאנחנו בודקים עבור ה-n שלנו ...האם זה סייף לשים פה מלכה? זאת פונקציית איזו שאנחנו כבר נראה. אם התשובה כן, אז תראו מה אנחנו עושים, אנחנו אומרים בורד בשורה רו, בקולום קולום, זאת אומרת, לוח השחמט במקום הנוכחי שווה טרו. זאת אומרת, אנחנו שמים כאן מלכה ...ואנחנו קוראים לפונקציה סוימה

221
01:25:23,420 --> 01:25:39,660
ואין קווינזה הגדולה שלנו בשורה הבאה בתור. זאת אומרת, מה שאנחנו אומרים, אם לא הגענו, כי אתם רואים איך אנחנו עוברים, אנחנו עובריםair שורה,

222
01:25:39,660 --> 01:25:53,380
כי מה חשוב שתשימו לב, שוב תשימו לב, בכל שורה יכול להיות רק מלכה אחת, ואנחנו יודעים שברשימה דו-ממדית הגדרנו שקוליבר זה פשוט...

223
01:25:53,380 --> 01:26:23,220
זה רשימה שמגדירה שורה שלמה, אז נוח לנו לעבור פר שורה. פשוט אנחנו עוברים פר שורה מלכה, פר שורה מלכה. אז ככה זה עובד. אז זה בדיוק כמו שעשינו. אמרנו, אם סיימנו לעבור את השורות, זאת אומרת, אם אינדקס שורה עבר את n-1, כי אתם יודעים איך שזה עובד במערכים מ-0 עד n-1, אז אם אינדקס שורה הגיע ל-n ממש,

224
01:26:23,220 --> 01:26:53,220
סיימנו לבנות לוח, בצורה מצלחת נתפיס אותו, אז זה הרעיון. עכשיו אם הסתם שכשאתם קוראים לזה על ההתחלה, עבור ראש ופס, ברור שלא בניתם לוח, כן? אז זה למה אנחנו בעצם עושים פה קריאה אקרוסיבית קדימה כזה. ואז כמו שאמרנו לכם, יש פה לולה שאומרת לכל עמודה, בשורה הנוכחית, נבדוק אם אפשר לשים על כאן.

225
01:26:53,220 --> 01:26:56,400
אם כן, יופי, נעבור לשורה הבאה בתור.

226
01:26:58,220 --> 01:27:00,780
ועכשיו מה קורה? שימו לב.

227
01:27:01,460 --> 01:27:03,540
ברגע שעשינו את זה,

228
01:27:03,900 --> 01:27:07,720
סול ואלקוויןס עברו לשורה הבאה בתור, ויצאנו מזה,

229
01:27:09,200 --> 01:27:15,180
פה אלמנט של ה-Back-Tracking ממש חובט בכם בראש.

230
01:27:16,000 --> 01:27:20,440
אנחנו מבטלים את המלכה שבדיוק שמנו,

231
01:27:20,940 --> 01:27:31,300
אחרי שחזרנו מהקריאה רקורסיבית שאומרת, אוקיי, טיפלנו בהצבה הזאת. מה זה אומר? תסתכלו.

232
01:27:33,040 --> 01:27:49,880
נניח, תסתכלו, נניח שלא יודע, שמנו מלכה כאן, שורה 2, ואז אנחנו אומרים בסדר גמור, קריאה רקורסיבית, רגע שנייה, אני רוצה להראות לכם במצגת,

233
01:27:50,700 --> 01:28:19,820
בורד, בשורה row, בעמודה קונומי, שווייתרו, שמנו מלכה, ונמשיך לבנות את הפתרון עבור לשורה הבאה בתור, עם מה שיש לנו עד עכשיו. ונניח שאנחנו עוברים לשורה הבאה בתור, ולא יודע, נניח שבשורה הבאה בתור, או שהמשכנו לבנות פתרונות טובים, או שלא. בכל מקרה, אנחנו רוצים לספור את כל הפתרונות, עבור כל המיקומים האפשריים של מלכות.

234
01:28:19,820 --> 01:28:49,820
זאת אומרת, לא משנה מה, לא משנה מה קורה, אחרי שהריקורסיה הסתיימה עבור שעה השורות, אנחנו חייבים לבטל את המלכה ששמנו פה, בשביל שנוכל לפדוק אפשרויות אחרות. איזה אפשרויות? תראו מה כתוב. זה לולאה פר עמודה. זאת אומרת.�, בשעה ההפקד, בשעה ההפקד, אתמוז אותו בבטן. הממלכה מזולאה והתפוצצה על כל אופן, אלא אם אתה רורק ומחכה להופקד שאתה צריך לתפוצץ אותו בחינך או שאתה רורק ואתה חייב להפקד בשביל עסק או חור, אתה מחזיק צ

235
01:28:49,820 --> 01:29:19,820
שורה הנוכחית שלנו, פר עמודה. אנחנו בודקים, האם זה סייף להניח פה מלכה, אם כן, נשיא מלכה, ונעבור לשורה הבאה בתור, ושם, זה יתחיל שוב, מכל, מאפס עד end. ושוב, ושוב, ושוב, ושוב, וככה בעצם אנחנו בודקים עבור כל הפתרונות האפשריים. זה ה-Back-Tracking, שימו לב, זה Back-Tracking, שגם, אנחנו חוזרים ממנו, מבטלים את ההתקדמות, ובודקים אופציה אחרת.

236
01:29:19,820 --> 01:29:49,820
זה הלב של Back Tracking, באמת. דרך אגב, מה זה פונקצית איז זהי? בואו נסתכל עליה. איז זהי היא דווקא פונקציה די פשוטה. הפונקציה הזאת היא בסך הכל שואלת האם זה בסדר לשים מלכה בלוח כפי שהוא כרגע בשורה הזאת בעמודה הזאת. אז מה אנחנו עושים את הפדקות הברורות בודקים שורה עמודה והאלכסונים אז פור איי אין ריינג' של עמודה מה אנחנו אומרים?

237
01:29:49,820 --> 01:30:13,900
אנחנו מקבעים שורה ואנחנו אומרים אם בשורה הזאת באיזה שהיא מהטעים בשורה הזאת הערך הוא לא פולס זאת אומרת הערך הוא יש מלכה פולס לא סייף זאת אומרת אם בשורה הזאת יש מלכה פולס אי אפשר לשים פה. נקסט.

238
01:30:13,900 --> 01:30:17,700
אם בעמודה הזאת

239
01:30:17,700 --> 01:30:47,700
לאורך העמודה הזאת יש מלכה? פולס. רגע, אני רק לא אוהב את הרווח הזה. אוקיי, ועכשיו פה אנחנו בודקים אלכסונים. יש פה זיפ וריינג' אבל אל תתבלבלו בבקשה. זה בסך כל בדיקה של שני האלכסונים. האלכסון הזה ואלכסון הזה. זאת אומרת אלכסון מצד אחד ואלכסון מצד שני. יש רק שני אלכסונים שמכסים את הכול. אנחנו בונים...

240
01:30:47,700 --> 01:31:17,700
x של הלאכסון, כן? אז יש לנו פה ריינג' שאתם רואים פה כתוב פה מ-rho עד מינוס אחד, אבל מן הסתם שבקפיצה שלילית, אבל מן הסתם שזה יעצור ב-0. מה הכוונה? אנחנו בודקים הלאכסונים, אבל אנחנו בודקים, כמו שאתם רואים, כתוב פה rho ולא m גדול. מה הכוונה?

241
01:31:17,700 --> 01:31:45,700
עבור כל מלכה אנחנו רק בודקים את האלכסון מתחילת הלוח עד אליה, לא ממנה והלאה, למה? כי ממנה והלאה לא שמנו כלום. זוכרים את ההגדרה? אנחנו שמים מלכה פר שורה. מהשורה הבא בתור עדיין אין מלכות כי אנחנו עוד לא שמנו. הריקורסיה בונה פתרון פר שורה. אז למה אנחנו חוסכים קצת פה?

242
01:31:47,200 --> 01:32:17,000
ופה גם אותו דבר, זה שהרינג' בנוי בצורה שלילית, תתעלמו מזה, אין לזה משמעות. אנחנו בסך הכל בודקים את האלכסון כאילו מהמלכה עד להתחלה, כן? כאילו בודקים פנימה החוצה, זה הכל. וגם פה עמודה אותו דבר, מהמלכה למעלה, למה? כי למטה אין כלום. או סליחה, כלום מי עצמנו שמאלה, סליחה, אני בלבלתי אתכם.

243
01:32:17,000 --> 01:32:46,900
מהמלכה שמאלה, כי מימינה עדיין לא שמנו שום מלכה, נכון? הריקורסיה בונה פר שורה, פר עמודה. ככה היא עובדת. ופה זה פשוט שני אלכסונים. אז פה אנחנו נחליף תפקיד, פה אתם רואים בכתה עמודות, הפעם מכלום עד לעין, זה הגיוני. אם הפור הראשון הזה דיבר לאלכסון כזה, מלכה שמאלה למעלה, אז...

244
01:32:46,900 --> 01:33:16,900
ה-4IJ השני פה אומר מלכה ימינה למעלה. זה הכל. בונים פה V כזה, אם זה עוזר לכם. למטה אין מה לחפש, כי אין שום כלום. וזהו, זה הכל. זה בסך הכל פונקציה שבודקת. נכון? בודקת שורה, עמודה, הלחסון שמאל, הלחסון ימין. זה הכל. אם יש מלכה בדרך - לא בטוח. אם שרדנו את כל הלאות האלה - אין מלכה?

245
01:33:16,900 --> 01:33:46,900
והיא תראient true. זה כל מה שהיא également עושה. היא רק בודקת, אם אפשר להניח פה מלוכה. וזה מה שאנחנו עושים, אז שוב, אני חוזר על ההגדרה, עבור מי שקצת מתקשה, כי זה backtracking, זה קשה. אנחנו בונים פתרון על ידי פר שורה, קודם כל, אם הגענו עד לסוף, חרקנו מהשורה האחרונה, נדפיס פתרון ותקין, אם לא, בשורה הנוכחית,

246
01:33:47,540 --> 01:34:17,540
פר עמודה נבדוק, האם זה בסדר לשים פה מלכה? אם כן, נשים מלכה ונבדוק מכאן והלאה עבור השורה הבאה בתור. האם אחרי ששמנו פה מלכה מחכה לנו פתרון איפשהו בהמשך.איפה שזה לא יהיה שמחכה לנו פתרון בהמשך, שירד עד לסוף הרקורסיה, הוא שלם. תדפיס אותו. אחרי שדפצת אותו, תחזור אחורה. מה זה לחזור אחורה?פה חוזרים.

247
01:34:17,540 --> 01:34:47,540
למה? מסיימים פה קריאה של סולבן קווינס, אחרי זה מבטלים את המלכה ששמנו פה, וממשיכים לבדוק עבור עמודה הבאה בתור. ואתם רואים? כל שורה אנחנו בודקים את כל עמודות, וככה אנחנו מבטאים שאנחנו בעצם בודקים עבור כל הפתרונות האפשריים. ועכשיו אני רק רוצה להראות לכם קוד שבאמת מריץ את זה. עכשיו תראו, הנה, יש לנו כאן פונט,

248
01:34:47,540 --> 01:35:17,540
פונקציה is safe היא כתובה פה כמו שראיתם במצגת יש לנו פה את  הסולבן קווינס בדיוק כמו שראיתם במצגת ופה אפילו יש לנו פה פונקציה של הפרינט בורד אם אתם רואים פה דרך אגב קו ארוך פה או אקסלש יואו 03 05 אל תלחצו זה סתם שטויות אסקי יוני קוד שאני שמתי פה בשביל נוחות ההדפסה והנה פה מה אני עושה אני שם להם לבדוק

249
01:35:17,540 --> 01:35:47,540
קוד שאומר, תפתור לי n מלכות בין 0 לשבע כולל, אולי נשים פה תשע, למה לא, שיהיה, והאמת שזה אפילו לא דורש נוט כ, אז יאללה בוא נריץ את זה, אז בואו נסתכל, תסתכלו, זה הפתרון עבור n שווה 1, מלכה יחידה, עבור n שווה 4, הנה באמת שני הפתרונות שאתם ראיתם במציאות, בואו נראה איתן נפצעים עד כמה כי זה אפשר לך ומאין אמת להחזיק להם בשבילך.ראהו טיפולים של מלכה שהיית משתפתך

250
01:35:47,540 --> 01:36:17,540
עבור ה-N שווה 5, יש פה כבר, ויש פה כל כך הרבה פתרונות שהוא אומר לי, אני לא רוצה להראות לך את זה, אז בואו נפתח את זה, תסתכלו. אגב, זו היה הדפסות, כן? אני שמתי פה קו עליון ותחתון, כדי שאתם תראו משבץ, שיהיה לכם קל להבין. אז תראו מה משותף לכל הפתרונות האלה. תראו מה קורה פה. בכל שורה, יש רק מלכה אחת. בכל עמודה, יש רק מלכה אחת.

251
01:36:17,540 --> 01:36:47,540
כל אלכסון is safe, זה הפתרונות, וזה בעצם המהות של הריקורסיה, זה המהות של ה-back-checking פה, מה הוא עשה? פשוט לכל הפתרון המשיך את הריקורסיה עד הסוף, גמר את הריקורסיה עד הסוף, כל הכבוד, מבטא את הפתרון מכאן, משנה אותו. וככה אנחנו לא דילגנו על

252
01:36:47,540 --> 01:36:50,740
על אף פתרון.

253
01:36:50,980 --> 01:37:01,180
על אף פתרון. זה כל הפתרונות האפשריים. אתם רואים? אל תדבלבלו. זה האלכסונים. אתם רואים? האלכסונים, They're safe.

254
01:37:04,380 --> 01:37:14,140
אז אם אתם הצלחתם להבין, אני שמח. אם לא הצלחתם להבין, אני פשוט אתמצא שוב, מה קרה פה ב-Backtracking?

255
01:37:15,180 --> 01:37:45,140
התנאי הצעירה שלנו, זה שסיימנו לבנות פתרון תקין, ואנחנו מדפיסים אותו. אם לא הגענו עד לסוף, אז בשורה הנוכחית, אנחנו עוברים לכל עמודה, מנסים לבנות פתרון. אם אפשר לשים פה מלכה, נשים מלכה, ונמשיך לבדוק פתרון עבור השורה הבאה בתור והלאה.

256
01:37:45,140 --> 01:38:15,140
סיימנו לבדוק את כל הפתרונות האפשריים עבור השורה הבאה בתור והלאה. אני מזכיר לכם, רקורסיה מניחים שיש פתרון עבור שאר, עבור ההמשך. אז פה ה-Back-Tracking קורה. ברגע Bill בנוסף ארדון 
שסיימנו לטפל רקורסיבית בכל השאר, אנחנו אומרים בסדר. יש לנו את כל האפשרויות שיכולנו שיש לנו. נבטל את ההתקדמות שלנו

257
01:38:15,140 --> 01:38:45,140
פה ונחפש פתרון שמתחיל בעמודה אחרת. זאת אומרת זה כאילו שנניח אני בשורה 3, שמתי פה את המלכה הזאת, אז מה שקורה הרקורס ימשיך לחפש לי פתרונות שיעבדו עבור שלוש המלכות הראשונות. אחרי שסיים אותי לבדוק את כל האפשרויות האפשריות האלה, אני מבטא את המלכה הזאת פה ומנסה לשים אותה

258
01:38:45,140 --> 01:38:57,100
בעמודה הבאה בתור. ואז בודק את כל האפשרויות מהעמודה הבאה בתור והלאה. ככה ה... קורסיית בק-צ'קינג הזאת עובדת. אני ממש מקווה שאצלחתם להבין את זה.

259
01:38:59,340 --> 01:39:28,806
אם לא, בואו ננסה את התרגיל האחרון של התערבול הזה: בואו ננסה את תרגיל 6.  מציאת מסלולים במבוך, שזו גם שאלת בק-צ'קינג מאוד קלאסית. ממה... ממה אתה עושה למרות? אדי, בטח אתה חייב להחזיק מחדש מטעם ספירה שחשוב בראשית אתה במשרד לעדןי והצפה בראשית של גרעין האד

260
01:38:59,340 --> 01:39:29,300
אם לא, בואו ננסה את התרגיל האחרון של התרגול הזה. בואו ננסה את תרגיל 6. מציאת מסלולים במבוך, שזו גם שאלת בק-צ'קינג מאוד קלאסית. מה אנחנו עושים? נתון מבוך בגודל n על m, או מבחינתכם, מטריצה דו-ממדית. מטריצה דו-ממדית שיש לה ערכים משני סוגים בלבד.

261
01:39:29,420 --> 01:39:59,220
טרו או פולס? אם הערך בתא כלשהו טרו, זה אומר אפשר לעבור דרכך. אם הערך בתא כלשהו הוא פולס, זה אומר אי אפשר לעבור דרכך. אוקיי, לעבור דרכתיים. למה? אנחנו צריכים לכתוב פונקציה רקורסיבית בק-צ'קינג שהיא סופרת את כל המסלולים האפשריים. מי?

262
01:39:59,220 --> 01:40:17,040
מטא שמאל ימין, שמאל, סליחה, למעלה, זאת אומרת, מהטא באינדקס 0,0 עד לטא הכי ימינה למטה, זאת אומרת, טא באינדקס n-1, m-1.

263
01:40:17,040 --> 01:40:26,920
זאת אומרת, מהקצה השמאלי עליון לקצה ימני תחתון של המבוך. צריך לחשב את כל המסלולים האפשריים שתקינים.

264
01:40:26,920 --> 01:40:56,820
איך אפשר לחשב מסלול כזה? יש לי, מכל טא מותר לי רק שני מהלכים אפשריים, ללכת ימינה או ללכת למטה. רק אם ימינה יש טרו, ורק אם למטה יש טרו. אז בואו ננסה לספור בידיים. נניח אני הולך ימינה, ימינה, אי אפשר. אוקיי. ימינה, למטה.

265
01:40:56,900 --> 01:41:26,740
ימינה, אי אפשר. ימינה, למטה. למטה, ימינה, אפשר. זאת אומרת, זה מסלול. זה מסלול. הכל הבדל הוא שהתחלתי מלמטה ואז הלכתי ימינה. וגם למטה, למטה, ימינה, ימינה, מסלול. שלושה מסלולים. זה שלושה מסלולים.

266
01:41:26,740 --> 01:41:56,740
אוקיי, יש חוקיות? יש חוקיות, קודם כל. כשאנחנו נרצה לכתוב פונקציית בקצ'אקינג, בכללי, אנחנו חייבים לכתוב לעצמנו את החוקיות שאנחנו רוצים בכלל לממש, כי... תקשיבו, אני חייב להגיד לכם, בקורס הזה לא מספיק אמרנו לכם לכתוב פסודו קוד או לכתוב תיעוד, אבל בעולם האמיתי, כשאתם תכתבו אלגוריתמים מסובכים,

267
01:41:56,740 --> 01:42:12,060
אחד הדברים שאתם תרצו לעשות זה קודם כל זה כזה step 1 write a pseudo code שאתם תדעו בכלל מה אתם רוצים לכתוב, ואז step 2 יהיה write actual code.

268
01:42:12,060 --> 01:42:41,340
Pseudo code זה ה- what to do מה שנקרא, וה- actual code זה how to do. בסדר? כמה שאתם יכולים לפרק את זה לשלבים על הדרך. אז כן, התנאי היצירה שלנו אומר: הגענו ליעד, וזה מסלול שאפשר לספור, או שהגענו למקום שגם ימינה וגם למטה זה false, ואי אפשר לעשות פה כלום, אז אין פה מה לספור, וזה עוצר אותנו.

269
01:42:41,340 --> 01:43:10,900
איך נתקדם? פשוט מאוד, נעשה שתי קריאות רקורסיביות, קריאה רקורסיבית אחת שלוקחת אותנו צד ימינה, אם לא הגענו לסוף, וגם קריאה רקורסיבית שלוקחת אותנו צד אחד למטה, אם לא הגענו לסוף. פשוט נספור את כל הדרכים האפשריות שנקבל מלקחת צד ימינה ומלקחת למטה. אוקיי? כי זה הרעיון.

270
01:43:10,900 --> 01:43:18,980
סופרים את כל המסלולים האפשריים. אז אתם יכולים לראות פה דוגמה לפתרון. אז איך נספור את זה?

271
01:43:18,980 --> 01:43:48,940
קאונט מייס סולושיונס, ניתן לנו את המבוך עצמו, מטריצה דו-ממדית בסך הכל, עם ערכים של True או False, נניח שמישהו כבר בנה לנו את זה, נתחיל מפוזיישן ההתחלה שלנו, בי דפולט, 0,0, ואתם רואים מה נעשה. ניקח אינדקס שורה, אינדקס עמודה, מהפוזיישן הנוכחי שלנו, נגדיר את ה-n ו-m שלנו, בסדר? זה הקצוות.

272
01:43:48,940 --> 01:44:14,940
ונתחיל קאונט, כמה מסלולים יש לנו מהמקום הנוכחי והלאה. נתחיל ב-0. עכשיו אנחנו אומרים, אם הפוזיישן שלנו הוא הסוף ממש, אז היי, הגענו, זה סוף הדרך. אוקיי, נעשה משהו אחר.

273
01:44:14,940 --> 01:44:33,280
אם לא ירדנו לשורה הכי למטה עדיין ואפשר לרדת שורה למטה, למה? כי התנאי הזה פה האנד הוא מייז בשורה שהיא נוכחית פלוס אחד: אותה עמודה.

274
01:44:33,480 --> 01:45:03,240
זה שאנחנו אומרים end ביטוי זה אומר end רק אם זה true או אם זה אחד. אתם זוכרים את הביטויים הבולייאניים? זה שאני אומר end משהו אז רק אם המשהו הזה הוא true, זאת אומרת הוא לא אפס או הוא לא רק, זה true. אז בעצם מה הif הזה אומר? הif הזה אומר אם עוד הגעתי לשורה הכי למטה ואני...

275
01:45:03,240 --> 01:45:22,400
אני יכול לרדת למטה, אז אני אקח את הקאונט הנוכחי שלי, מה שהוא לא יהיה, ואני אגדיל אותו בכל המסלולים האפשריים שאני יכול להגיע לסוף משורה למטה והלאה.

276
01:45:24,200 --> 01:45:54,140
בנוסף, יש לי איף אחר, לא אלס, איף אחר. אם לא הגעתי לעמודה הכי ימנית, ואפשר ללכת עמודה ימינה, אני אוסיף לקאונט שלי את כל הדרכים האפשריות שאפשר להגיע עד הסוף מעמודה ימינה והלאה. אז אתם רואים מה קרה פה בסך הכל. זה יחסית פשוט, כי קודם כל, תנאי הצירה שלי, אני קודם כל בודק איפה אני נמצא כרגע, מה זה.

277
01:45:54,140 --> 01:46:24,140
מה זה סוף הדרך? כרגע הקאונט הוא 0 עבור המצב הנוכחי שלי ואז אני אומר אם הגעתי לסוף אז היי, מצאנו פה מסלול ריטרן 1 ואז הרעיון הוא שכל פעם אנחנו לוקחים את כל המסלולים האפשריים האלה שמצאנו בקריאות רקרוסיביות יותר מאוחרות אך שזזנו קדימה ומוסיפים אותם

278
01:46:24,140 --> 01:46:43,280
ל-count שהוא מצטבר וגדל יותר ויותר כשאנחנו הולכים אחורה ברקורסיה, וה-count המקסימלי אנחנו נקבל אותו ב -KR1 של Position שווה 0,0. כי זה בעצם מי שקיבל -count שספר את הכל עבור כל התנועות האפשריות.

279
01:46:44,900 --> 01:46:52,840
והנה אני רוצה להראות לכם באמת קוד שפותר את זה, יש לנו פה את הפונקציה כאן שאתם ראיתם במצגת.

280
01:46:53,240 --> 01:47:08,920
יש פה פונקציה סתם שטותית שמייצרת מבוכ אז אתם רואים היא פשוט נעזרת ברנדום כן מייצרים מבוכ, אפילו עם מקדם הסתברותי אבל זה שטויות תתעלמו.

281
01:47:08,920 --> 01:47:20,040
בסך כלל בונים את המבוכ true או false ומחפשים פתרונות אז יאללה רנצל תראו מה קרה.

282
01:47:20,220 --> 01:47:49,600
אם יש לי פה מבוכ של שלוש על שלוש וכל התאים הם true אז אתם יכולים בעצמכם לחשב כמה פתרונות. יש לי פה אחד פתרון של למעלה למטה ואז ימינה, זה אחד, יש לי שתיים, שלוש, ארבע.

283
01:47:49,600 --> 01:48:19,500
חמש, שש, אפשר ממש לספור את הפתרונות ככה. בוא נריץ את זה שוב, אני רוצה מבוכ אחר. לא תביא לי מבוכ אחר. או הנה מבוכ אחר לגמרי תראו שתי פתרונות אפשריים בסך הכל. קודם כל למעלה למטה אז אני יורד למטה ואז הולך ימינה, פתרון. אחרת, הפתרון האחר שיעבוד לי זה ללכת ימינה.

284
01:48:19,500 --> 01:48:49,500
אין לך סוף, אז למטה, 2, אין פה הליכה באלכסון, אין לי, אני יכול רק או למעלה למטה או שמאלה ימינה, זה הכל, נראה את שוב, אוקיי, פה 0 פתרונות, למה? בוא נראה, ימינה, אני לא יכול, למטה, ימינה לא, למטה, ימינה לא, יש פה חומה של false שחוסמת אותנו, איפה את יידעת טובה בלרעך מה את אומר לך שאת מכיר בכלל?העץ הבלתי עץ אדם בבית מרבה מאוד,

285
01:48:49,500 --> 01:49:19,060
אפס פתרונות פה זה שוב הכל שתי פתרונות true true true true true true true true true וזו. אז פתרנו את זה איכשהו. אני מקווה שהצלחתם להבין קצת אינטואיטיבית את הרעיון הזה של backtracking יכול להיות שה...

286
01:49:19,060 --> 01:49:30,200
מבוא חזר לכם יכול להיות שדווקא אין המלכות היה ביג דיל עבורכם. אני חושב שאין מלכות הוא קצת יותר טוב להבין backtracking בגלל הרעיון הזה של.

287
01:49:30,840 --> 01:49:48,160
בנינו פתרון כאילו בנינו שלב בפתרון. מצאנו את כל הפתרונות מכאן והלאה. ואז אנחנו הולכים אחורה מבטלים את מה שעשינו פה כדי לבדוק פתרונות במקום אחר והלאה.

288
01:49:48,160 --> 01:50:18,160
אני מקווה שצלחתם להבין, זה קצת סיפור, אין ספק. אתם מוזמנים כמובן להתעסק עם הקוד הזה בעצמכם, מוזמן לכם במודל, אני מאוד ממליץ את זה, באמת. הקוד הזה כתוב כאן כדי שתוכלו לעשות לו מניפולציות, לשנות פה דברים, ואני ממש ממש ממש מקווה שתצליחו להבין ושתצליחו להגיע מוכנים למבחן ומה לא נשמע אתמול שתצעקו בהתחלה כדי להגיד להם זה לא נכון

289
01:50:18,160 --> 01:50:19,880
בהצלחה לכם.

