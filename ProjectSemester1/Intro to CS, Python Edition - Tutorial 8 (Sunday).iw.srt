1
00:00:00,000 --> 00:00:30,000
טוב, אז זהו, אז אתם יכולים רק שם להיות בשקט רגע. אוקיי, תודה רבה. אז רק תגידו לי בקצרה, מה למדתם אצל רועי היום? חיפוש בינארי, חיפוש בינארי, כן. סבבה, אז זה יהיה לנו משהו שאנחנו נדבר עליו ממש בקצרה, בסוף התרגול, אבל הפוקוס הראשי של התרגול, זה היה הנושא שאמרתם בשלב הקודם, שזה סיבוכיות. וסיבוכיות זה דורש...

2
00:00:30,000 --> 00:00:40,080
הרבה חשיבה והבנה קצת, דורש פיתוח של אינטואיציה מיוחדת, אז בואו בינתיים נתחיל. אתם כבר למדתם אצל רועית ההגדרה של סיבוכיות, נכון?

3
00:00:40,080 --> 00:01:10,040
פתרון הכללי של זה, שכשיש לנו תוכנות או אפילו יותר כללים מזה, אלגוריתמים, אנחנו צריכים למצוא מדד שהוא טוב לכל דבר, לא רק לכל ספציפי שאנחנו כותבים בשפה אחת, אלא ממש לכל מבנה פתרון, לכל אלגוריתם, אנחנו צריכים לדעת למדוד כמה הוא יעיל, כמה משאבים הוא לוקח כדי להריץ אותו, כמה משאבים הוא לוקח בשביל לאחסן את הדברים שאנחנו צריכים תוך כדי הפעולה. אז מבחינתי...

4
00:01:10,040 --> 00:01:40,040
אנחנו נדבר על סיבוכיות בצורה יחסית כללי, אז יש לכם פה שתי דוגמאות ממש ממש ככה פשוטות שאמורות להיות כבר טעם ראשון כזה, יש לכם כאן כמו שאתם רואים פונקציה מאוד מאוד פשוטה, אתם רוצים לחשב את סכום המספרים מ1 עד n, אז אתם כבר מכירים את הנוסחה נכון? את הנוסחה של הסכום סדרה החשבונית הזאת מ1 עד n, n כפול n ועוד 1 חלקי 2, נכון? אתם מכירים את זה, אז זאת אופציה אחת להחזיר את הסכום מספרים הזה בפקודה

5
00:01:40,040 --> 00:02:10,040
מנגד, אתם יכולים גם לנסות ולחשב את זה יד ענית. אתם יכולים למצוא פונקציה שמתחילה מסכום 0. ואז אתם פשוט בונים את הסכום על ידי את זה שאתם עושים לולאה שרצה על כל המספרים בין 1 ל-n ומוסיפים אותם לסכום הסופי הזה. בסופו של דבר שתי הפונקציות האלה עושות את אותו הדבר. אבל העניין הוא שאחת מן היא יעילה יותר מהשנייה. אז סתם דוגמא, מה אתם מניחים שירוץ בפחות זמן? איזו מהפונקציות?

6
00:02:10,040 --> 00:02:40,040
השמאלית. למה? מה בעצם קורה פה? בדעתכם. מתכלס זאת בעצם פקודה אחת שהיא תרוץ בלי קשר לגודל של n אבל מנגד פה בפונקציה מימין, יש לכם פה לולה שכמה פעמים שהיא עושה איטרציות זה תלוי בגודל של n. אז זה כבר האינטואיציה הראשונה שאנחנו צריכים בשביל להבין את הרעיונות של סיבוכיות. לא שומע? איזה מובן?

7
00:02:40,040 --> 00:03:10,040
- והסכום מ-A עד אם, זה של כאוהמת? - זה סכום סדרה חשבונית. -כן? -בסדר גמור. -אז, אנחנו נדבר באמת על שני סוגים של סיבוכיות. הסיבוכיות הראשונה, סיבוכיות זמן. זאת אומרת, בעצם זה כמה פעולות כתלות בכלא, אלגוריתם או התוכנית שלנו צריכה כדי לבצע. אז, אנחנו לא באמת מדברים כמובן על הזמן ב-real time של כמה זמן לוקח למחשב ספציפי להריץ את הפקודות

8
00:03:10,040 --> 00:03:14,680
‫אלא אנחנו נדבר על זה בצורה ‫שהיא יותר כללית עבור האלגוריתם,

9
00:03:14,760 --> 00:03:19,240
‫פשוט משהו בתלות בכלא. ‫אז אם באמת אנחנו מסתכלים ‫על הפונקציה הזאת,

10
00:03:19,400 --> 00:03:22,920
‫שיש לנו פה חישוב סכום, ‫אז אנחנו מתחילים בפקודה אחת,

11
00:03:23,000 --> 00:03:26,880
‫שהיא פשוט נקרא לה פקודה אחת, ‫אחרי זה יש לנו לולאה,

12
00:03:27,080 --> 00:03:34,040
‫שהיא חוזרת על עצמה א.פמים, ‫ואז בפנים יש פקודה אחת או שתיים.

13
00:03:34,120 --> 00:03:38,920
‫אם אתם רוצים לחלק את הפלוס שווה הזה ‫לחישוב הסכום ששם פלוס איי,

14
00:03:39,000 --> 00:03:43,120
‫ואז לפקודה השנייה שהיא ההשמה ‫של סם שווה משהו חדש.

15
00:03:43,640 --> 00:03:49,640
‫ובסוף עוד פקודה אחת. ‫אז זאת אומרת, אם אתם מסתכלים ‫על כזאת פונקציה,

16
00:03:49,800 --> 00:03:54,120
‫והייתם רוצים לבנות לה עכשיו ‫נקרא לזה פונקציה ציבוכיות זמן,

17
00:03:54,280 --> 00:04:02,080
‫מה אתם הייתם כותבים? ‫זאת אומרת, תחשבו על זה ככה, ‫נניח אני הייתי עכשיו, הופה רגע, אחורה, כן.

18
00:04:02,760 --> 00:04:07,360
‫עכשיו אני אפתח נוטפד ואני רוצה ‫שאתם תבין על מה אני מדבר.

19
00:04:07,960 --> 00:04:37,880
‫נניח שאני הייתי רוצה, רגע, ‫נקטין אותו קצת. אוקיי. אוקיי, אז נניח שעבור הפונקציה הזאת ‫הייתי רוצה לכתוב סוג של ככה פונקציית זמן, ‫כאילו כמה זמן, מה ציבוכיות זמן פה? ‫הייתי כותב משהו כמו t של n, כאילו כמה, בטלות ב-n, ‫כמה פקודות, מה הסדר הגודל לפקודות שאני אריץ פה? ‫אז זה יכול להיות משהו כמו, לא יודע, ‫סם שווה 0. מבחינתי זה.

20
00:04:37,880 --> 00:05:07,880
1, ואז יש לי פה לולאה שהיא רצה n פעמים, אז זאת אומרת, אני אעשה 1 ועוד n כפול, עכשיו בפנים יש לי פקודת פלוס שווה, אני אהיה לאודג', אני אגיד, נחלק את זה לשתי פקודות, לשני דברים שונים, לחישוב של הסכום סם פלוס 2, ואז הפקודה השנייה תהיה מבחינתי פשוט סם שווה משהו חדש, אז לא יודע, נכתוב פה n כפול 2, ואז בסוף יש לי שמה את הreturnvel sum.

21
00:05:07,880 --> 00:05:37,880
נניח שלהחזיר ערך חזרה, נקרא לזה גם פקודה נפרדת. אז מבחינתי אני יכול להגיד שכל הדבר הזה לוקח לי 2 כפול n ועוד 2 פקודות ב-r. אתם מבינים את הרעיון פה? אתם מבינים את האינטואיציה של החישוב הזה? אני בעצם פשוט עובר פה על הפקודות, מפשיט אותן לרעיון הכללי של איזה פעולות, איזה פעולות אני עושה פה? כמה פעולות אני עושה פה? היה מה אומרים להם אז מה זה שאתה רוצה לעשות? והאם משהו מהן קורה בתעלות ל...ל... כאלה לצענות שלך שאתה רוצה לתפקודות שאתה בא

22
00:05:37,880 --> 00:06:07,880
אני מקבל, אז פה הכלאת הוא פשוט אין כלשהו, וזה מה שיצאנו, אז לפחות על החישוב האינטואיטיבי הזה, יש שאלות? טוב, איפה אתה מכיר איך אתה צריך... אה, מבחינתי, מהתחלה תריצה את הפונקציה, פשוט מהתחלה של הפונקציה, אני מנסה ל... אני מנסה לכתוב בצורה מתמטית, כמה פעולות הפונקציה הזאת תריץ, כתלות בעין עצמו, בכלאת שמקבלת, בפרמטר

23
00:06:07,880 --> 00:06:37,780
האחד הראשון זה פשוט סם שווה 0, כן, אני מגדיר משתנה, סם שווה 0, זה מכניס פעולה אחת. אוקיי, קודם כל n כפול, ה-n כפול, את זה אתה מבין, נכון? לולאת הפור הזאת. אוקיי, ואז אני אמרתי, נניח שאני אפרק לשני חלקים את פקודת הפלוס שווה, חלק הראשון זה החישוב של סם פלוס i, ואז החלק השני זה סם שווה משהו חדש, לזה התכוונתי.

24
00:06:37,780 --> 00:07:07,780
אז בסדר ואז הריטיון סאם קראתי לו גם פקודה נפרדת טוב בקיצור זה רק ברמה של אינטואיציה. עכשיו אנחנו לאט לאט ננסה לחלק ממש לאקרונות את הדברים שאנחנו צריכים לדעת כדי שנוכל באמת לבנות ביטויים כאלה בצורה יותר החליטית. אז באמת העיקרון הראשון שלנו אנחנו נכתוב בעצם פונקציות אם אתם רוצים לקרוא לזה שהן תלויות בגודל הכלא. זאת אומרת כשהאנשים

25
00:07:07,780 --> 00:07:37,780
כשאנחנו ננסה לבנות ביטויים כאלה שיגידו לנו מה סיבוכיות הזמן של איזושהי פונקציה, מה שיעניין אותנו זה שהסיבוכיות תהיה תלויה בכלט עצמו, כי בסופו של דבר כל פונקציה, כל אלגוריתם, כל מה שזו לא יהיה, הוא תמיד עובד על משהו, תמיד איזשהו כלט, איזה שהם נתונים שאתם מזינים לו, אלגוריתם עושה על זה פעולה, ונותן לכם תוצאה. והתלות היא בנתונים עצמם, גודל הנתונים, במהנדס,

26
00:07:37,780 --> 00:08:07,780
נתונים בדברים האלה, אז זה מה שאנחנו נבנה בעצם, אנחנו נבנה סוג של פונקציות שהמשתנה שלנו יהיה בעצם הכלת עצמו, גודל הכלת יותר מזה אפילו. אז באמת, כמו שאמרנו כאן, אמרנו שהכלת שלנו הוא n, אז מבחינתנו גודל הכלת הוא זה שקובע לנו כמה פעולות שאנחנו נריץ פה, אתם רואים פה את עלולה, היא מתחילה מ-1 עד n כולל, אז n פעמים, בסדר? אז זה העיקרון הראשון, סיבוכיות

27
00:08:07,780 --> 00:08:37,780
פונקציה של גודל הכלא. עקרון שני, תסתכלו על מה שאתם רואים פה עכשיו, יש כאן איזושהי פונקציה חביבה קוראים לה contain target, היא מתקבלת איזושהי רשימה ואיזשהו target. מה הפונקציה עושה? לכל אייטם ברשימה הזאת, היא בודקת. האם האייטם הזה הוא ה target שאנחנו מחפשים, אם כן, נחזיר true. אם באף אחד מהמקרים לא מצאנו את ה target בכל הרשימה, נחזיר false . אז עכשיו אני רוצה לשאול אתכם

28
00:08:37,780 --> 00:09:02,740
האם אתם רואים מקרים שבהם הפונקציה הזאת תסיים את העבודה שלה מהר יותר ומקרים אחרים היא תסיים את העבודה שלה לאט יותר? איזה מקרים? 
נכון, או לא בכלל? גם אופציה? אז בדיוק, אתם עכשיו עשיתם חלוקה מאוד מהירה למקרה הכי טוב ולמקרה הכי גרוע.

29
00:09:03,040 --> 00:09:33,040
העמקי הכי טוב זה שוואלה בפעם הראשונה שאנחנו מתחילים לעבור לרשימה נפלנו על האייטם שהוא הטארגט והעמקing הכי גרוע עשינו מעבר שלם על הרשימה ולא מצאנו את הטארגט אז זאת אומרת יש לנו פה best case scenario ו worst case scenario אז עכשיו המטרה של העיקרון השני היא בעצם להבין כדי למדנע את היעילות של האלגוריתם הזה שפוטץ את הבעיה הזאת מה נכון שאנחנו

30
00:09:33,040 --> 00:10:02,880
מה נכון שאנחנו נסתכל עליו, המקרה הטוב ביותר או המקרה הגרוע ביותר? מה יהיה נכון להחליט על האלגוריתם הזה אם הוא יעיל או לא? לפי איזה מקרה? במקרה הגרוע, כי המקרה הגרוע אנחנו יודעים שהאלגוריתם הזה תמיד יעבוד במקסימום הכי לאט עד לכמה זמן שזה ייקח וזה באמת ייתן לנו דרך להבין אם אלגוריתם יעיל מאוד או יכול להיות רק יעיל לפעמים, עכשיו תראו.

31
00:10:02,880 --> 00:10:32,880
ברור שבמציאות, בעיקר כשאנשים מעניין אותם להשיג תוצאות בחיים אמיתיים, לפעמים אתם תראו שאלגוריתמים שייממשו, תוכנות שאתם משתמשים בהם, משחקים שאתם משחקים בהם, אין לא יודע, אלגוריתמים מתקדמים שהם משומשים בכל מיני דברים בעולם. במציאות יש שימוש באלגוריתמים שהם לא בהכרח ממש מהירים ב-Worst case scenario, אבל אלגוריתמים שהם יוצאים די מהירים ב-Average case scenario, במה שנקרא

32
00:10:32,880 --> 00:11:02,880
ממוצע משוקלל, בכאלת הצפוי שהסיכוי שייתקבל הוא הכי גבוה, אלה אלגוריתמים שכן יש בהם שימוש בעולם האמיתי, אני לא אגיד לכם שלא. אבל כרגע עכשיו, שאנחנו מתחילים ללמוד על סיבוכיות, אנחנו מתחילים בצורה הבסיסית ביותר, ובה הדגש הוא, חישוב סיבוכיות לפי המקרה הגרוע ביותר. אז סתם שאלה, במקרה הגרוע ביותר, כמה בעצם פקודות אנחנו מריצים פה? כמה פעולות, לא פקודות סליחה, פעולות.

33
00:11:02,880 --> 00:11:09,380
תחשבו על משהו אבסטרקטי, אני לא הולך לפתוח פייתון פעם אחת בתרגול הזה, זה תרגול שהוא תיאורטי

34
00:11:09,380 --> 00:11:12,260
כמה פעולות, מה סדר גודל פעולות שאנחנו נריץ פה לדעתכם?

35
00:11:12,260 --> 00:11:40,060
n או שתי n, נכון? רגע, יש לנו פה 4 לכל אייטם בארי, זאת אומרת, זה n כפול כבר, n כפול, עכשיו פה שאלה, השוואה, אייטם נוכחי, האם אתה שווה לטארגט? בדרך כלל אתה...נכון! בפי פי אייטם, אנחנו עושים פה if כלשהו, וצריך להשווא את זה בשביל x כפי x אייטם, חלק מה

36
00:11:12,260 --> 00:11:42,240
רגע, יש לנו פה 4 לכל אייטם בארי, זאת אומרת, זה אין כפול, כבר, אין כפול. עכשיו פה שאלה, השוואה, אייטם נוכחי, האם אתה שווה לטארגט? נכון, פר אייטם, אנחנו עושים פה איף כלשהו, אם האיף אצלי הכי יופי, אז נעשה פעולה, אם לא, לא נאהוב, פשוט נעבור לאיטרציה הבאה, זאת אומרת, יש לנו כאן סדר גודל של פעולות, אין פעולות ועוד מספר קבוע של פעולה.

37
00:11:42,240 --> 00:12:12,240
או לא, אז זה בעצם הסיבוכיות זמן של הפונקציה הזאת, משהו סדר גודל של n, n בחזקת 1 ממש, זה העיקרון השני, אנחנו ניתעשה לפי client suite scenario, זה מה שיעניין אותנו בחישוב סיבוכיות, השאלות על זה, סבבה, לבסוף, העיקרון שלישי זה תזכורת, כשאנחנו מדברים על סיבוכיות, אנחנו כבר לא נדבר ממש על המימוש הספציפי של הקוד הספציפי בפייתון הספציפי בגרס

38
00:12:12,240 --> 00:12:32,920
הדרך האלוקית היא רק שהייתה מישראל כאן ואתה מוכן לבדוק בפן כללי מישראל, מישראל בתוך קוליסטורי תעינה איכות אני וככל שהסיוע ההם, הם לא ניתן לו לבדוק איכות מהמילים שלהם.

39
00:12:33,120 --> 00:13:02,920
ויותר בקטע של בעיה, תהליכים לפתור אותה ופתרון. אז אנחנו נתעסק ממש בצורה הכללית הזאת. וזה למה פה נניח, בפונקציה הקודמת של הסכום של מספרים מ-1 עד n, אז עשינו חישוב, הפרדנו לפעולות נפרדות וזה, ואמרנו יש פה בערך שתי n ועוד שתיים. אבל אתם מבינים שגם יכולנו לחטוף פה, לא יודע, n ועוד שתיים, יכולנו להגיד שהפלוס שווה זה פקודה אחת, יכולנו לעשות את זה.

40
00:13:02,920 --> 00:13:32,200
אז בסופו של דבר זה לא משהו שממש משנה, זה לא באמת קריטי פה. המקדם הזה, הקבוע כפול ה-n, הוא פחות חשוב. מה שיותר חשוב, זה סוג הפונקציה, הסוג הכללי של הפונקציה סביב ה-n. האם זה n בחזקת 1, n בריבוע? האם זה לוג n, שורש n? הסדר גודל של הפעולות, הוא באמת מה שיעניין אותנו. הפרטים הקטנים זה כבר לאחר כך.

41
00:13:32,200 --> 00:13:45,140
אז באמת אתם יכולים לראות עכשיו דוגמאות שונות לחישובי פונקציות סיבוכיות, כאילו פונ קציות של כמה פעולות אלגוריתם מריץ לפי כלת בגודל n.

42
00:13:45,140 --> 00:14:02,080
אז לא יודע אם יש לכם נניח פונקציה כזאת שחישבתם ומצאתם, זה יצא 2.5 פעולות בערך כפול n ועוד 2, בתכלס אז הסדר גודל פה הוא פשוט ליניארי, סדר גודל של n פעולות או לא יודע משהו אחר.

43
00:14:02,080 --> 00:14:31,700
פונקציה שתריץ 100 פעולות בלי קשר ל-n, בלי קשר לכלת, רק 100 פעולות תמיד, מבחינתנו סדר גודל קבוע, סדר גודל של קבוע מספר פעולות, לא תלוי ב-n, או לא יודע, משהו מאוד מאוד מוגזם כמו פונקציה שאתם חישבתם ומצאתם, מריצה פעולות של 2 בחזקת n ועוד 1 ועוד 2 ועוד 1 פעולות בסך הכל.

44
00:14:32,700 --> 00:15:01,620
מזה אנחנו הבנו שהסדר גודל של פעולות פה הוא 2 בחזקת n. שימו לב, אני אפילו לא אמרתי 2 בחזקת n ועוד 1, כי מה זה בעצם? 2 בחזקת n ועוד 1 זה פשוט 2 כפול 2 בחזקת n. ואמרנו, הקבוע שלפני הפונקציה על n פחות מעניין אותנו, כי זה משהו שאנחנו יכולים כבר בשאיפה לאינסוף, מנקודת מסויינות והלאה, להגיד לכם זה כבר לא באמת משנה את הסדר גודל.

45
00:15:01,620 --> 00:15:31,620
אז זה מה שיעניין אותנו, או אפילו גם אם יש לנו מקרה של n כפול log n, הרעיון הוא פונקציה של n כפול של פונקציה של n, בסדר? זה כן חלק מהסדר גודל. אז כל הדוגמאות האלה שאתם רואים כאן, כל הדוגמאות האלה, הם בעצם מובילים אותנו להגדרה הפורמלית. עכשיו אתם ראיתם משהו דומה בהרצאה, אני אנסה להסביר אותה כדי שאולי עכשיו אתם תבינו קצת יותר טוב ברמה אינטואיטיבית. כדי להגדיר בעצם את הרעיון

46
00:15:31,620 --> 00:15:42,880
על זה של הסיבוכיות זמן של איזשהי פונקציה, אנחנו בעצם מדברים על כמה הפונקציה גדלה בצורה סימפטוטית, כלומר,

47
00:15:42,880 --> 00:15:53,420
איך הפונקציה גדלה, באיזה סדר גודל היא גדלה, כשאתם שואפים לאינסוף, מנקודה מסוימת והלאה, כשאתם אומרים בתכלס, לאורך זמן, אז מה קורה?

48
00:15:53,420 --> 00:16:26,353
בשביל זה אנחנו נשתמש בשתי פונקציות. הפונקציה הראשונה, נגיד נקרא לה F של N, זאת הפונקציה שאנחנו עכשיו בונים, זאת הפונקציה שהיא בעצם מייצגת את הסיבוכיות זמן של אלגוריתם, זה הפונקציה שכתבתי לכם, פה בנו את P, אתם ראיתם, כתבתי פה, T של N שווה ל-2N ועוד 2. פשוט ספרתי כמה פונקציה זמן של נale

49
00:15:53,420 --> 00:16:23,400
בשביל זה אנחנו נשתמש בשתי פונקציות. הפונקציה הראשונה, נגיד נקרא לה f של n, זאת הפונקציה שאנחנו עכשיו בונים, זאת הפונקציה שהיא בעצם מייצגת את הסיבוכיות זמן של אלגוריתם, זה הפונקציה שכתבתי לכם פה בנוטפד, אתם ראיתם, כתבתי פה t של n שווה לשני n ועוד שתיים. פשוט ספרתי כמה פעולות האלגוריתם הריץ. אז נקרא לפונקציה הזאת עכשיו f של n, בסדר, למה לא? הפונקציה הזאת שדיברתי עליה, הזאת שאתם ספרתם בידיים, ממש.

50
00:16:23,400 --> 00:16:53,400
הסתכלתם על קוד, אמרתם זה כמה פעולות. זאת תהיה הפונקציית F של N שלנו. אז כמו שאתם מבינים, זו פונקציה שסופרת כמה פעולות אלגוריתם מריץ, אז זאת פונקציה שהיא חיובית, מונוטונית עולה, המספר פעולות יכול רק להעלות, לא לרדת. אז זאת תהיה הפונקציה הראשונה שלנו. אנחנו נגדיר פונקציה שנייה, G של N, וזאת תהיה הפונקציה שהיא ,בעצם, תהיה הקנה מידה שלנו. כשאני אומר לכם G של N, תחשבו על N.

51
00:16:53,400 --> 00:17:17,600
M בריבוע, שורש M, לוגי M, כלומר אני אומר לכם זאת פונקציה שאנחנו בעזרתה נחשב את הסדר גודל של הסיבוך לזמן, אנחנו בעצם נשווה אליה לסדר גודל שלה, ואז פה אנחנו מתקרבים בעצם להגדרה של מה זה O של, מה זאת קבוצת פונקציות שהן באותו סדר גודל, מה הכוונה?

52
00:17:17,600 --> 00:17:47,600
אז אני אומר לכם שאנחנו יכולים להגיד עבור פונקציה F כלשהי שהיא O גדול של G של N, או אני יכול לכתוב לכם באמת את הביטוי שאתם כבר ראיתם בכמה מקומות ואתם גם תכירו יותר מאוחר, אתם רואים פה כתוב F של N שווה O גדול של G של N, או לא יודע, יש אנשים פוריטנים שיגידו לכם, זה לא שווה, זה שייך ל, כי O גדול זה קבוצות, אבל בסדר, נדבר על זה אחר כך. או שזה

53
00:17:47,600 --> 00:18:17,600
לא בכלל, אבל הרעיון הוא, אני יכול להגיד לכם ש-f היא o גדול של g של n, אם, ופה זה חשוב, פה זה החלק שבעצם הופך את זה למשהו שהוא נכון, אם עבור קלט שהוא גדול מספיק או יותר גדול, ואם עבור קבוע c כלשהו שהוא גדול מספיק או יותר גדול, אם עבור שני תנאים כאלה שאומרים לכם, עזבו אתכם עכשיו מ-n, תעזבו אתכם עכשיו מכמה קבוע כפול הפונקציה, תניחו שיש לכם, וזה בטח אפשר להגיד שהם בכלל חשוב לגר booking נציונות שלan

54
00:18:17,600 --> 00:18:47,600
קלט גדול מספיק, תניחו שהקבוע שאתם עושים, את השיא הזה כפול הפונקציית G' שאתם משווים איתה, תניחו שהוא גדול מספיק. הרעיון הוא, שעבור אותם קבועים גדולים מספיק, שממהם והלאה, אתם יכולים להגיד שבעצם F של N היא תמיד חסומה מלמעלה, באותו קבוע כפול G של M. מה זאת אומרת? עכשיו, הנה החלק שבו אני חייב להראות לכם למה אני מתכוון בצורה אינטואיטיבית. אם אני באמת רוצה להגיד לכם עכשיו,

55
00:18:47,600 --> 00:18:59,900
F של N היא פונקציה, 2N ועוד 2, זאת פונקציית ציבוכיות הזמן של הסכום המספרים מ-1 עד N שאתם ראיתם, זוכרים? עוד לא שכחתם. זה המשמעות של F של N.

56
00:18:59,900 --> 00:19:16,700
אז עכשיו מה אני רוצה להגיד לכם? אני משווה את F של N ל-G של N שהוא בסך הכל N, פשוט N. זאת אומרת, אני מנסה להגיד לכם שקבוצת כל פונקציית ציבוכיות הזמן בסדר גודל של N,

57
00:19:16,700 --> 00:19:46,540
היא חסם עליון עבור הזמן ריצה של F של N שעליה אנחנו מדברים כרגע. אז איך אני מוכיח לכם את זה? אוקיי. בעצם אני לא חייב, אני אגיד לכם, אתם פה בכיתה, תגידו לי אתם, תנו לי N כלשהו, N0 כלשהו, תנו לי N0 ותנו לי איזשהו קבוע C כלשהו, כך שאני אוכל בעצם לכתוב את מה שאתם ראיתם שם, כך שאני אוכל לכתוב עבורם, F של N.

58
00:19:46,740 --> 00:19:56,860
ממש קטן שווה ל c כפול g של n לכל n שהוא גדול מ-n0. תנו לי דוגמאות.

59
00:19:56,860 --> 00:20:32,993
בוא נלך על 3. אוקיי, אני יכול לכתוב פה 3, רגע.  כאשר n0 שווה...  כן? סתם תבחר מישהו, לא חייבים מספר גדול דרך אגב. לא, אני רוצה להגיד שאני לא, אבל עאלה. הואלה, מבחינתנו n0 אפילו תבחר 5.  לא, משהו כזה. היפר לטבע נכון, זה סביר, מישהו צבע לנו לנציג את זה תביא לה להפחד מ-n0, משהו כזה יבטר להפחד את זה להפחד נכון קצת. יקרה לנו

60
00:19:56,860 --> 00:20:26,820
אוקיי, אני יכול לכתוב פה שלוש, רגע. כן? סתם תבחר מישהו, לא חייבת מספר גדול דרך אגב. וואלה, מבחינתנו, N0, אפילו תבחר חמש, אתה יודע משהו. תסתכלו עכשיו. שתיים כפול, שניים, אתה יודע שהוא, אפילו לא גדול מחמש. בוא נעשה.

61
00:20:26,820 --> 00:20:56,820
גדול שווה לחמש, סתם מרוב נוחות. נניח ש-n שווה חמש, אז יש לנו פה שני n ועוד שתיים, שתיים ועשרה, שתיים ועשרה, רגע, עכשיו שלוש כפול חמש, 5, 5, 10, האם, C כפול G של n חושא מלמעלה F של n? ועכשיו, אתם יודעים ששלוש כפול n, אתם תגדילו אותו אצי ב-n יותר ויותר גדול, בין 2 ל-n בין 8 בנצין 2 למעשה הקדימה

62
00:20:56,820 --> 00:21:26,820
גמרנו, מנקודה מסוימת, והלאה, כאילו, הווד שתיים הזה, בחיים לא יהיה קרב את השתי n הזה להיות שלוש n. זאת אומרת שתי n ועוד שתיים, קטן שווה לשלוש n מהנקודה הזאת והלאה. לנצח. זה הרעיון. אתה מבין? הרעיון הוא עבור קרת שהוא גדול מספיק והלאה. עבור קבוע כלשהו, אתם תגידו לי איזה קבוע חיובי. קבוע מספיק גדול בשבילכם. אתם כבר יכולים להגיד זהו. g של n, הפונקציה שאליה אנחנו משווים.

63
00:21:26,820 --> 00:21:55,100
את הסיבוכיות, היא חסה מיליון פה, זה הפואנטה, זה בעצם הדרך שהיינו להגיד, מצאנו סדר גודל שהוא לפחות חוסה מלמעלה, את הזמן ריצה של העלגוריתם שאנחנו עכשיו עובדים עליו, F של N, T של N, Z המי שאנחנו מנסים לחשב, אתה, כמה יעיל אתה, מה חוסם אותך מלמעלה, אז מצאנו סדר גודל של ה-G של M הזה, פה ספציפית, פשוט אין רגיל.

64
00:21:56,100 --> 00:22:26,020
וכאילו, זהו, זה כל הלב של הסיפור הזה, זה כל החסימה מלמעלה, אז כמו שאתם ראיתם, שני n ועוד שתיים, ראיתם עכשיו, עשינו עכשיו בזמן אמת, הראינו לכם שזה חסום מלמעלה בפונקציה g של n, אז בעצם אני יכול להגיד לכם, שסיבוכיות של שני n ועוד שתיים, היא o של n, o גדול של n, זאת אומרת, כל הפונקציות האלה בסדר גודל של n, חסם עליון, יפה?

65
00:22:26,020 --> 00:22:55,780
עכשיו, חסם עליון אמרתי, אז שום דבר לא מונע מכם לקחת פונקציה כזאת לדוגמה של שני n בריבוע, ולהגיד, את חסומה מלמעלה לא רק בפונקציות שהן בסדר גודל של n בריבוע, אלא גם של n בשלישית, או n ברביעית, נכון? הם יותר גדולים, הם חסם עליון. אז זהו, אז שים לב, לא אמרתי כאן תטא של, לא דיברתי פה על חסם הדו, שהוא גם עליון וגם תחתון,

66
00:22:55,860 --> 00:22:59,560
‫זה משהו שדיברתם עליו עם רועי? ‫-לא.

67
00:22:59,560 --> 00:23:04,760
‫אז אולי משהו שאתם תכירו יותר מאוחר, ‫אבל בעיקרון לא אומרים לכם רק,

68
00:23:04,760 --> 00:23:12,460
‫או יותר נכון, כשאתם חשובים סיבוכיות, ‫זה לא חוכמה כל כך למצוא ‫רק חסם עליון או גדול,

69
00:23:12,460 --> 00:23:18,960
‫החוכמה האמיתית היא למצוא ‫את האו גדול, למצוא גם משהו שנקרא אומגה,

70
00:23:18,960 --> 00:23:27,100
שזה חסם תחתון, שבו התפקיד של האי שוויון די מתחלף, ‫תפקיד קצת מתחלף, בערך,

71
00:23:28,120 --> 00:23:40,660
ואז אם אתם מוצאים שfn g של n היא גם o גדול, כלומר היא גם חסם עליון מנקודה מסוימת והלאה, אבל גם חסם תחתון מנקודה מסוימת והלאה, אז אתם בעצם יכולים להגיד שאותה פונקציה,

72
00:23:40,660 --> 00:23:56,220
g של n, היא לא סתם o גדול ואומגה, אלא אתם יכולים להגיד תטא, זאת אומרת שזה כזה נראה כמו o וכף באמצע, זאת אומרת, חסם מדויק, זאת אומרת, אתם אומרים, זה לא רק חוסם אותו מלמעלה בסדר גודל, או לא רק חוסם אותו מלמטה בסדר גודל, זה ממש, זה.

73
00:23:56,220 --> 00:24:26,220
בסדר גודל, איזה ממש, זה סדר הגודל של הסיבוכיות, אבל זה קצת מעבר למה שאנחנו מתעסקים איתו כרגע, לבינתיים אנחנו נדבר איתכם כרגע רק לגבי עוג גדול, ותניחו שאנחנו מנסים לחשב עוג גדול שהוא צמוד מלמעלה, זאת אומרת שהוא סוג של, סוג של חסם עליון צמוד, בערך, אנחנו נודה קצת על זה במבנה, מבנה נתונים אתם מדברים על סיבוכיות בצורה, אפילו בצורה פורמלית כמו שצריך, גם אם אתם לא,

74
00:24:26,220 --> 00:24:56,220
תבינו לגמרי סיבוכיות בקורס הזה, במבני נתונים אתם תהיו חייבים להבין את זה, ממש. בסדר, אבל כבר עכשיו תכירו את הרעיון הכללי של סיבוכיות, פשוט מחשבים עם כזה חסם עליון. בסדר, באינטואיציה דיברנו עלייך עכשיו בהרחבה. מעולה? אוקיי. שאלה. נכון, אתה מדבר על חסם עלייה, נכון? לא חסם על ידיים, אבל לא סופרינום, נכון? ‫-אני מדבר על גדול שווה.

75
00:24:56,820 --> 00:25:26,820
בסדר? אל תדבר איתי עכשיו על חסם מלא, על חסם עליון, סופרמומ הוא רק משהו שהוא... לא, לא נתעסקים בדברים האלה, בסדר? לא על סופרמומים, בסדר? זה לא קורס בחדווה, את זה אני משאיר להאמין, תודה. אוקיי, בקיצור, דיברנו עכשיו על ההגדרה הזאת של הקצב גדילה סימפטוטי, ההגדרה הזאת, אנחנו נראה אותה עכשיו עוד מעט שוב, באותו דבר, רק במשמעות שונה. מה המשמעות השונה? סיבוכיות של מקום, מה הכוונה?

76
00:25:26,900 --> 00:25:56,480
אנחנו צריכים לדעת לחשב כמה יחידות זיכרון, כמה תאי מידע, אני אומר את זה בצורה כללית ממש, לא כמה ביטים על מחשב, כמה יחידות מידע אנחנו צריכים בשביל לממש אלגוריתם, כי וואלה, אלגוריתמים יכולים להיות מאוד יעילים במספר פעולות, המצד שני, הם יכולים לתפוס הרבה מקום בזיכרון בשביל הנוחות שלנו, ואנחנו צריכים גם לדעת לחשב את זה. לא מאוד קשה, אנחנו כבר נראה את זה, אבל זה הסיבוכיות השנייה שאנחנו מדברים עליה.

77
00:25:56,480 --> 00:26:26,480
ציבוכיות מסוג של מקום וגם פה אתם תראו אותם שלושה עקרונות שדיברנו עליהם מקודם יכו לו, אז לפני שנדבר עליהם, קודם כל אני חוזר חזרה לפונקציית סכום מספרים מי אחד עד אין, תגידו לי אתם בקצרה כמה יחידות זיכרון נוספות בגלל האלגוריתם אני צורך? לדעתכם. בואו נראה, סם שווה 0, זה יחידת זיכרון אחת, אני מקצא מקום בזיכרון למשתנה סם. יחידת זיכרון

78
00:26:26,480 --> 00:26:56,480
זיכרון אחת. שוב, לא מאבד לכם כמה ליטים, הסוג משתנה, לא מדבר איתכם. מדבר איתכם על פשוט יחידות. יחידה אחת, בואו להסתכל עוד, מה יש לנו פה? יש לי פה את המשתנה i, משתנה אחד, שנמשנה באיטרציות נוספת של הפורט, אני משנה את הערך שלו, אבל זה עדיין משתנה כלשהי שהוספתי לזיכרון. אוקיי. 200 00:16:08,270 ->00:16:10,283 20000 ריינג׳, אתם יודעים שהוא לא נמצא בזיכרון כולו, ריינג' זה משהו שאנחנו פשוט כל פעם שאנחנו מסתכלים עליו, הוא רקם להסת

79
00:26:56,480 --> 00:27:26,480
ואומר בסדר, הנה המספר, בואו נתייחס ל-range הזה בתור לא משהו שבעצם תופס מקום בזיכרון, בשביל זה יש לנו את ה-i, אוקיי? אז אז כאן היה לנו את sam ואת i, בואו נלך איתכם רחוק, בואו נלך איתכם לזה שאני לא יודע, החישוב של sam פלוס i תופס מקום בזיכרון, אז יאללה, שלוש, ולבסוף בואו נלך איתכם עוד יותר רחוק שהreturn value של sam, לשמור אותו בתור return value גם תופס מקום בזיכרון.

80
00:27:26,480 --> 00:27:44,680
ארבע, תגידו לי ארבע מקומות בזיכרון, או של מה זה הדבר הזה? או שלך, זה קבוע, זאת אומרת זה האלגוריתם שמבחינה עד כמה מקום בזיכרון הוא תופס, לא משמעותי, זהו, זה האינטואיציה שאתם צריכים לקבל מכזה דבר.

81
00:27:44,760 --> 00:28:14,760
אז מכאן והלאה אני יכול לחזור מאוד מאוד מהר על העקרונות שכבר דיברתי עליהם. קודם כל, איך אנחנו מודדים סיבוכיות מקום? בדיוק באותה צורה איך שמדדנו סיבוכיות זיכרון. אנחנו בעצם בונים פונקציה שהיא תלויה בגודל הכלת, אז זאת אומרת אם אנחנו מדברים על גודל כלת בגודל n כלשהו, אז לפי זה אנחנו עובדים. מה הכוונה? הנה דוגמה מאוד פשוטה שמראה לכם סיבוכיות מקום שהיא תהיה לינארית. מה זאת אומרת? פונקציה ליצור

82
00:28:14,760 --> 00:28:44,620
רשימה, אנחנו מקבלים כלט n, מספר n ואנחנו בונים רשימה, תראו כאן בעזרת least comprehension, אנחנו אומרים פה לכל i בריינג' שבין 0 ל-n פחות 1, נוסיף איבר בערך i כלומר אנחנו בעצם בונים, זה בעצם, זה, זה כאילו שכתבתי ליסט שווה לייסט על ריינג' של n, אתם מבינים מה אני מדבר, זה פשוט רשימה.

83
00:28:44,620 --> 00:29:14,480
עם כל האיברים, 0, 1, 2, 3 עד n מינוס 1 כולל. כמה מקום בזיכרון זה תפס? באורך של n. אז זאת אומרת, אם אני שואל אתכם, מה סיבוכיות זיכרון של זה, או של n, האם ברור לכם? האם יש שאלות, משהו פה לא ברור? אין בעיות? פה, יש לי שאלה עליך, פה, כמה מקומות בזיכרון?

84
00:29:14,480 --> 00:29:44,480
אני בעצם תפסתי בגלל האלגוריתם הזה. מה האלגוריתם הזה של החישוב סכום מספרים מ-1 עד N עשה? כאילו מה הוא עשה? מה הוא תפס בזיכרון? . . . . לא שומע? . . . כי אתה מבין פה, לא הוספתי עוד מישהו שתנה לזיכרון שהייתי צריך לשמור בצד.לא. i משנה ערך כל הזמן. sam משנה ערך כל הזמן. החישוב סמ. .  . .

85
00:29:44,480 --> 00:30:14,480
פלוס איי משנה ערך כל הזמן, זה לא עוד משתנים שתופסים מקום במקביל. עכשיו כשמאוחר יותר נגיע לרקורסיה, של קריאה שפותחת עוד קריאה, ופותחת עוד קריאה, זה כן תופס מקום בזיכרון, כפונקציה של n, כי זה קריאות שנשארות פתוחות, זה כן, פה לא, פה זה בסך הכל, סדרתי פשוט, סיימנו איתרציה של הפור, מגניב, עוברים להבאה בתוך, בסדר? בוא נראה אם לא פספסתי במקרה של בחטא

86
00:30:14,480 --> 00:30:44,480
אוקיי, עוד לא, יופי, אוקיי, אז עיקרון הראשון אמרנו סיבוכיות מקום גם אותו דבר כפונקציה של גודל הכדלת n, זאת אומרת אותה דרך חשיבה, בסדר? איקרון שני, גם פה לגבי best case ו worst case, תראו גם פה שני תרחישים קיצוניים לחלוטין, יש לנו פה פונקציה שמקבלת רשימה והיא מחזירה רשימה, אבל מה?

87
00:30:44,480 --> 00:31:14,480
יש ברשימה, את כל האיברים, מרשימת הכלת שהם חיוביים. אז, best case מבחינת סיבוכיות מקום, זה אם הרשימת כלת היא כולה מספרים שלילים, אז מה שאנחנו נחזיר זה רשימה ריקה. מנגד, אם הרשימה המקורית היא כולה חיוביים, אנחנו פשוט נחזיר עותק של הרשימה המקורית.. אז תגידו לי אתם, האם אתם שמים לב להבדל בין סיבוכיות הבסט קייס לסיבוכיות ה experiest קייס? מבחינת מקום?

88
00:31:14,480 --> 00:31:26,700
מה אתם אומרים? Best Case, מה יהיה סיבוכיות מקום? Best Case, סיבוכיות מקום? O של אחד, זאת אומרת תחזיר רשימה ריקה.

89
00:31:26,700 --> 00:31:42,080
Worst CASE? O של אין. ממש צמוד כזה. יופי. אז עכשיו תגידו לי אתם, האלגוריתם הזה, O של מה אני צריך לקרוא לו, אם אני עובד בצורה מסודרת? O של אין. זה העיקרון השני.

90
00:31:42,080 --> 00:32:12,080
אנחנו מחשבים סיבוכיות מקום לפי ה- Worst Case Scenario, בתרחיש שבו אנחנו צריכים את המקסימום מקום בזיכרון. שאלות? יופי, נניח שלא. ולסוף יקרון שלישי, זה פשוט, אומר לכם, כשאנחנו מדברים על סיבוכיות, עוד פעם, לא קשור לסופה, לא קשור למחשב שזה רץ עליו, נטו תלוי באלגוריתם, במלל הכללי. אתם צריכים להסתכל על הקוד, אתם צריכים לעשות לו אבסטרקציה,

91
00:32:12,080 --> 00:32:42,080
לפעולות שאתם בעצם עושים פה, לא תלוי בשפת תכנון. אז בואו באמת נסתכל פה, יש פה שני מימושים שונים לקונספט של לקחת רשימה ולהחזיר רשימה, אבל כל האיברים בסדר הפוך. המימוש הקצב פה שאתם רואים, אנחנו פשוט מחזירים רשימה שהיא פשוט הסלייס של הרשימה המקורי, מהתחלה עד הסוף, אבל בקפיצות של מינוס אחד, ואתם ראיתם את זה בתרגול שדיבר על זה, שזה באמת מחזיר לכם את הרשימה אבל לא

92
00:32:42,080 --> 00:33:12,080
או מנגד, אנחנו יכולים גם לבנות את הרשימה הזאת בצורה אחרת, יכולים לבנות רשימה רברסט כזאת, להגדיר אותה בהתחלה בתור רשימה של אפסים, באורך רשימת הכלא, ואז אנחנו יכולים להשתמש, אגב, יצא לכם לראות את פונקציית איניומרייט פעם, זאת פונקציה, אולי לא דיברתי עליה הרבה בתרגולים, אבל בתכלס, אם בדרך כלל אנחנו עושים איניובר סוג, אין להיסט,אני יכול לא רק לעשות,

93
00:33:12,080 --> 00:33:42,080
איתרציה על האייטמים, אלא גם אני יכול לעשות איטרציה על אייטם ובמקביל לקבל אינטג'ר שהוא האינדקס של האייטם הזה ברשימה. על ידי זה שאני נאזר בפונקציית אי-ניומרי, כלומר האייטם הראשון, באייטרציה הראשונה של זה, אני אקבל את האייטם הראשון פה ו-i יהיה שווה 0. באייטרציה הבאה בתור, אני אקבל את האייטם השני של הרשימה ו-i יהיה שווה 1. למה אנחנו משתמשים באייניומרי ?כי זה נוח, הרבה פעמים אנחנו רוצים לעבוד לא רק על ה..

94
00:33:42,080 --> 00:34:12,080
אייטמים שברשימה, אלא גם עם האינדקס שלהם, זה פשוט מדעי המחשב, תמיד עושים דברים כאלה. בקיצור, מה הפואנטרג? מלווה פה ריבורסט ליסט, בעזרת מה? נגיד, אורך הרשימה פחות 1, כלומר, האינדקס האחרון, פחות i. אז אתם מבינים מה זה, כאשר i שווה 0, נשים פה בריבורסט ליסט באיבר הראשון, את האייטם ה... כאילו, איזה אייטם? זאת אומרת, רגע, אייטם רבעון גדולה לנצץ שאתם חושבים בכלל. והקטיום הוא קטטטלנטציצ הלה

95
00:34:12,080 --> 00:34:42,080
אבל באינדקס האחרון, כן? זה אגב למה אנחנו התחלנו את הרשימה מלכתחילה, אתם רואים? כדי שיהיה לנו אינדקס אחרון כזה לשים שמה. זאת אומרת, רשימה מקורית, נתחיל לעשות עליה מעבר משמאל ימין, רשימת, הרשימה שנחזיר, כבר יש לנו אפסים בהכל, ואנחנו בעצם עוברים עליה ברוורס, לפי האינדקסינג הזה. "לנקס של ליסט פחות 1" זה אומר, תתחיל מהאינדקס האחרון, ואז תחזיר מזה תחסיר מזה איי, אז נתחיל מ  בסוף. ואז

96
00:34:42,080 --> 00:35:12,080
ואז אחד לפני הסוף, ואז אחד לפני, אתם מבינים? פשוט כזה סדר. נו, אם אתם לא מאמינים לי, אתם יכולים להריץ את זה בקוד, אבל תאמינו לי, זה פשוט, זה מה שזה עושה. בקיצור, שני מימושים שונים, ועדיין. מה סיבוכיות המקום של זה? מקום? העור שליהם. אנחנו פונים ומחזירים רשימה שהיא קופי ברוורס.עור שלהם, אורך הקהלת הן? אז...

97
00:35:12,080 --> 00:35:42,080
סיבוכיות מקום, אין, לא אמור להיות יותר מדי מוזר, זמן, תשמע, אם אתה שהתי סיבוכיות זמן, אז אתה צריך לענות לי על, אוקיי, מה סיבוכיות הזמן של לבנות סלייס, האמת שגם זה אני יכול בערך לענות לך, איך אתה, מה הדבר ההגיוני, איך אתה בונה סלייס חדש של הרשימה, אתה פשוט עושה את זה ידנית, אתה מתחיל מה-F שאתה מתחיל, עוצר את ה-F שאתה עוצר, ועושה את זה בצעדים שנדרש, אז גם פה הייתי אומר לך, לא שאתה רוצה לעשות, הזאתה צריך להשתמש, לעשות מכל מי שהיית צריך, ולא שאתה צר

98
00:35:42,080 --> 00:36:12,080
לא משלמה. אני מרגיש שזה עדיין או של אין סיבוכיות זמן פה. פשוט בונים את הסלייס הזה. לא שמעת? כן, אבל אני כבר יכול עכשיו להגיד לכם, כבר עכשיו יכול להגיד לכם, אין פה יותר מדי מה לחשוב. גם אחד סיבוכיות זמן, פר איבר שהיה ברשימה המקורית, אנחנו בונים לו מצביע חדש, ברשימה החדשה. אנחנו בונים סלייס חדש. עדיין או של אין? וגם פה, פה בכלל אתם רואים את זה.

99
00:36:12,080 --> 00:36:34,800
האינו מרייט הזה עושה איתרציות לפי אורך הרשימה, פשוט מגדירים מצביע חדש ברשימה הרברסט, עדיין או של n, שניהם הם בעצם או של n או של n, זמן ומקום, שניהם, הם פשוט בונים רשימה חדשה, לפי הרשימה המקורית, שאלות? אוקיי.

100
00:36:35,620 --> 00:36:51,140
דיברנו על זה הרבה מאוד ואתם כבר מבינים שאנחנו, גם כשאנחנו בונים פונקציית סיבוכיות, יהיו לנו קבועים כפול n ועוד קבועים ואתם כבר יודעים שהדברים האלה פחות או יותר נעלמים כשאנחנו מדברים על סדר גודל.

101
00:36:51,140 --> 00:37:03,820
וגם פה, אם עכשיו אני עובר אתכם לשקופית שהיא מראה לנו את ההגדרה של סיבוכיות מקום, זה копיפסט של הסיבוכיות זמן, זה קופיפסט. אין פה שום דבר חדש.

102
00:37:03,820 --> 00:37:33,740
פה בסך הכל f של n, היא תהיה פונקציה שמתארת את סיבוכיות המקום במקום זמן. וזהו, כל השאר הדברים שכתוב פה, קופיפסט. אוקיי. הנה שקופית נחמדה שמראה לכם, לפחות בצורה מוחשית, את ההבדלים בגדילה הסימפטוטית של הפונקציות השונות, שאנחנו נגיד, או של. אז נניח, או של 1, פונקציה שפשוט, היא לא משתנה לפי, אה, מה הצירים? ציר x זה...

103
00:37:33,740 --> 00:38:03,740
גודל הקלט n, וציר y זה פשוט מספר הפעולות. אז. אתם מבינים ש-o של 1 לא תלוי בגודל הקלט, לכן אתם תראו קו שלו משתנה. קבוע. אה... מה עוד אינטואיטיבי לכם? 0 של n, אתם מכירים את זה, פשוט קו ישר. אוקיי? אז ככל שאתם מגדילים את n, יש לכם a כפול n ועוד b, אתם מכירים את מוסכת הישר, הנה זה הישר שלכם.

104
00:38:03,740 --> 00:38:30,140
אבל יש גם פונקציות אחרות שכדאי שתכירו וכדאי שגם תשימו לב להבדלים ביניהן, לדוגמה: לוג, עכשיו אני לא יודע כמה אתם זוכרים את הרעיון של לוג מקודם, נניח במכינה או מה שהספקתם ללמוד בבית ספר כן או לא, אבל כבר עכשיו תכירו שבאופן כללי פונקציית הלוגריתם על משתנה כלשהו היא קטנה יותר מפונקציה ליניארית.

105
00:38:30,140 --> 00:38:59,960
לוג זה בדרך כלל, בעיקר אסימפטוטית, יותר קטן מליניארית, תכירו. מעל זה יש גם את הרעיון של לקחת את n ולכפול אותו בלוג n, n כפול לוג n זה משהו שהוא יותר גדול מ-n עצמו, אבל קטן יותר מ-n בריבוע. שוב, לוג n קטן מ-n, אז מן הסתם ש-n כפול n יהיה יותר גדול מ-n כפול לוג n, נכון? אתם מצליחים לעקוב?

106
00:39:00,760 --> 00:39:29,820
זה קצת מתוסבת לפעמים, חוץ מזה אתם יכולים להניח אוקיי, אז n בחזקות יותר ויותר גדולות, אז היא יגדל יותר ויותר מהר. יש לכם משהו שהוא אפילו עוד יותר גדול, 2 בחזקת n, זה אפילו יותר גדול מכל הפונקציות הפולינומיאליות על n, אז תכירו ש-2 בחזקת n בכלל גדל מאוד מהר. אגב, אנחנו נראה דוגמא לפונקציה שראינו כבר בתרגולים קודמים, שהסיבוכיות זמן שלה היא 2 בחזקת n.

107
00:39:29,820 --> 00:39:59,820
אנחנו נראה דוגמה לזה, אגב. ולא יודע, איני דוגמה קיצונית מאוד, n שהוא בחזקת n. אז מה הדוגמה קלאסית לזה? n עצרת. n כפול m פחות 1, כפול m פחות 2, זה בכלל סיבוכיות מטורפת. נסתדר לא לכתוב פונקציות שמגיעות לסיבוכיות כזאת, בוא נגיד את זה ככה. בסדר. אז ראינו פה הרבה מאוד תיאוריה, הרבה מאוד הסברים, הרבה מאוד אינטואיציה והמטרה היא עכשיו, אנחנו נראה פה עכשיו.

108
00:39:59,820 --> 00:40:29,820
איזשהו רצף ארוך מאוד של דוגמאות ותרגילים, אני מקווה שנצליח לפתור אותם עכשיו די מהר. אז בואו נראה כמה אתם עדיין ערניים. סבבה, נתחיל מדוגמה מאוד מאוד פשוטה, הנה פונקציה, שלוש שאלות בסך הכל, מה פונקציה עושה, מה סיבוכיות זמן שלה ומה סיבוכיות זיכרון, אז בואו נתחיל ממה הפונקציה עושה, תגידו לי, אתם, הנה, אני אפילו אצליח להזום הנה, רק שתראו ממש טוב, הנה, מה הפונקציה עושה? … ו emotions,הרי מצדו את זה להגיד

109
00:40:29,820 --> 00:40:59,820
הפונקציה מחזירה את האיבר המקסימלי בליסט. איך היא עושה את זה? נכון? לא, באמת, נכון. מתחילים מדוגמה פשוטה, פונקציה, מתחילים, דפולק, האיבר הראשון, עוברים על הרשימה, אם איבר ברשימה גדול מהמקסימום שיש לנו כרגע, כל הכבוד, אתה עכשיו המקסימום, נחזיר. יופי. מה סיבוכיות זמן? או של, כן, או של, אורך הרשימה.

110
00:40:59,820 --> 00:41:28,940
סיבוכיות מקום? למה המקום או שלם? זה איבר יחיד. מה כשזה משתנה יחיד? אה, רגע. תניחו לרגע, שאם אנחנו לא בצורה חד משמעית העתקנו את הרשימה המקורית, רק לקרום ממנה איברים באיטרציה, לא מוסיף לסיבוכיות הזמן שלנו באו שלם. זאת אומרת...

111
00:41:28,940 --> 00:41:49,440
Item in list זה עדיין ס..סליחה, לא סיבוכיות זמן, סיבוכיות מקום, אני מנסה להגיד 4 item in list זה סיבוכיות מקום עדיין O של אחד, אנחנו רק קוראים מידע שקיים כבר בזיכרון, מבחינת זיכרון זה לא מוסיף O של M, זיכרון.

112
00:41:49,440 --> 00:42:19,180
אבל ה..זה.. כן, אז רגע, נכון, אבל זה משהו שנתון לך ככלת, השאלה היא בסיבוכיות מקום של פונקציה, זה כמה הפונקציה שלך מוסיפה, כמה היא תופסת אקסטרה מקום בזיכרון, בגלל שהפונקציה שלך רצה. אז זה למה הפונקציה שאתם רואים פה, אתם אמורים להגיד די מהר, סיבוכיות זמן, O של N, למה? יש לנו פה איטרציה לאורך הרשימה.

113
00:42:19,180 --> 00:42:49,120
וקבוע בפנים ובחוץ, O של N בזמן, כמה סיבוכיות מקום, אתם רואים את זה, אתם מסתכלים, מקסימום זה איבר יחיד, אייטם בכל פעם שעוברים על הרשימה זה עדיין איבר יחיד, כי אנחנו פשוט עושים איטרציה, אותו אייטם פשוט מוחלף להיות משהו אחר כל פעם שעוברים לאיבר הבא בתור. וזהו, וההשוואה פה בפנים והפעולת השמה פה בפנים זה הכל O של אחד בזיכרון, ופה ריטרן, מקסימום זה איבר.

114
00:42:49,120 --> 00:43:18,640
זה בעצם, זה משתנה אחד, איבר אחד מתוך מה שיש ברשימה. בקיצור, סיבוכיות מקום, או של אחד. אז אני שואל עכשיו, האם יש שאלות, האם, זה עדיין לא ברור, למה זו סיבוכיות מקום של או של אחד, לא או של n. משהו לא ברור? תשאלו, עכשיו זה הזמן. שאלות? סיבוכיות זמן או של n. זמן או של n, למה? אתה רואה פה, אתה עושה, אתה קורא מהר מאוד, אה, four item in list, עוברים על הליסט,

115
00:43:18,640 --> 00:43:48,640
ליסט אורך של n, n כפול מה שיש בפנים. אז מה אומרת ה p או של 1? או של 1 זה מקום, כי מקום אנחנו לא מעתיקים פה את כל הרשימה. בסדר? אז זה מה שהיה לנו להגיד על הדוגמה הזאת.אוקיי, נעבור הלאה, לדוגמה הבאה בתוכנית, דוגמא 2. הנה פונקציה מאוד מאוד קצרה, הנה פונקציית סכום המספרים מ1 עד n אבל אנחנו כבר יודעים מראש את הנוסחה. תגידו לי אתם עכשיו.

116
00:43:48,640 --> 00:44:18,640
אנחנו יודעים מה הפונקציה עושה, סכום המספרים אחד עד n, מה סיבוכיות מקום וזמן שלה? גם וגם. או של אחד. האם למישהו לא ברור למה? אין בעיה, נתון לנו מספר, אנחנו לוקחים את המספר הזה, כפול, המספר ועוד אחד, כל זה, מחלקים בשתיים. אז אני יודע, אני יודע, זה יכול להיות מטעתיה ולמעשה, יש פה אין תלשונות,טענות של מה עשינו, פנימ פרס ציון ישרות של מתי כוח בדרך

117
00:44:18,640 --> 00:44:48,640
שאלה שלך, כי נכון שאנחנו אומרים הציבורכיות זמן של זה או של אחד וגם מקום או של אחד, אבל מותר לנו לעצור, לשים כוכבית ולהגיד היי, זה לא שאתם מתבלבלים, זה נכון שבמציאות למשתנים מסוגים שונים, לגדלים שונים של מספרים, בשפות תכנות שונות, יש מימושים שונים ואופטימיזציות שונות ונכון שאם היה פה מספר ממש ממש גדול

118
00:44:48,640 --> 00:45:18,640
או לא יודע, מספר float כלשהו, מאוד מאוד מסובך, עם הרבה ספרות אחרי הנקודה העשרונית, אני יכול להבטיח לכם שברקע הדבר הזה היה נאלץ לעשות פעולות יותר מסובכות, או יותר פעולות פשוט, כדי לחשב את זה. כי יש אופטימיזציות נפרדות למספרים פשוטים, לעומת מספרים מסובכים. זה מציאות של אחרים אמיתיים. אבל עכשיו ניסה זום חזרה ואומר לכם, אבל היי, זה עדיין רק

119
00:45:18,640 --> 00:45:48,640
תיאוריה של קורס מבוא למדעי המחשב, אז כרגע אל תחשבו על הקושי הזה, וזה למה זה בסדר להגיד או של אחד בהכל פה, אוקיי, דוגמה שלישית, הנה פונקציה קצת מעניינת, תניחו שיש לכם קלט, מטריצה בגודל N על N, אז שימו לב, גודל הקלט עכשיו הוא לא סתם N, אלא N על N, N בריבוע, זה הקלט, ואנחנו הולכים לבנות משהו.

120
00:45:48,640 --> 00:46:18,640
אז אני עכשיו איעשה זום אין על הפונקציה, ואני רוצה לראות אם אתם מצליחים להבין מה הפונקציה הזאת בעצם עושה, אני מאוד סקרן לדעת. מה הפונקציה עושה? תסתכלו. בונים משולש, איזה משולש? אולי למדתם על ההגדרות של משולשים במטריצות? משולש תחתון, עליון, משולש תחתון שמאלי, אומר לכם משהו? תראו. עוברים באמת ברנג' של...

121
00:46:18,640 --> 00:46:48,640
תסתכלו, נגדיר n להיות אורך המטריצה, אבל אתם מבינים מה זה מטריצה? רשימה של רשימות, רשימה של רשימות. זאת אומרת, אורך המטריצה זה בעצם להגיד כמה שורות יש למטריצה, כי אנחנו נגדיר כל שורה במטריצה להיות רשימה בנפרד. אתם זוכרים שדיברנו על מטריצות, או שזה היה בתרגול הקודם ושרון דיבר איתכם, אוקיי אבל אני הקלטתי את זה מראש, אז מבחינתי אני כאילו עדיין הראיתי לכם.לא משנה. לא משנה.

122
00:46:48,640 --> 00:47:18,640
לא, באמת, מי שראה את הקלטה מראש ראה, דיברת איזה עומק, בכל מקרה. ברשימה הדו מימדית, נכון? מה הכוונה ברשימה הדו מימדית, זה פשוט רשימה שאיברים שלה זה רשימות, אז כשאני אומר העורך של הרשימה הדו מימדית הזאת, אני בעצם רוצה להגיד לכם כמה רשימות יש שם בפנים, ואם כל רשימה מייצגת שורה של המטריצה, אז הגיוני להבין שכשאני אומר עורך המטריצה הזאת, שהיא n על n, אני פשוט אקבל את n עצמו.

123
00:47:18,640 --> 00:47:48,640
אתם מבינים או שאיבדתי אתכם? איבדתי אתכם? ני רואה שקצת דממה פה אז. אני אכתוב לכם פה, רק למקרה שאולי... לא יודע, איבדתי אתכם. הנה דוגמה מאוד מאוד פשוטה למטריצה דוממתית. ברשימות, תניחו שיש לכם רשימה של 1,2,3, חייבה רבה בתור, רשימה של 4,5,6, חייבה רבה בתור, רשימה של 4,5,6

124
00:47:48,640 --> 00:48:18,640
ש-7, 8, 9, תניחו שכל שורה פה זה רשימה נפרדת ותניחו שהמטריצה היא פשוט רשימה שכל שורה היא איבר נפרד שלה, אתם מבינים? אז, אם אין, אם זאת מטריצה של 3 על 3, מה זה אין פה? כמה איברים יש פה? שלושה איברים, עכשיו, שאנחנו מבינים את זה, אז אנחנו מקבלים את המטריצה הזאת

125
00:48:18,640 --> 00:48:41,140
נגדיר את הטריינגל שאנחנו כבר מחזיר. נגדיר n, שזה כמה שורות יש במטריצה. יופי. עכשיו נגיד, לכל שורה במטריצה, מה נעשה? נוסיף למטריצת טריינגל, נעשה לה אפנד למה? תסתכלו טוב. מטריצה, השורה ה-I שלה, זאת אומרת,

126
00:48:41,140 --> 00:49:03,860
פר שורה, אנחנו מסתכלים על השורה ה-i הנוכחית ואנחנו מוסיפים סלייס, סלייס שמתחיל מההתחלה ונגמר, לא כולל, בעמודה ה-i, אינטואיטיבית, מה שקורה פה, אנחנו בעצם בונים סלייסים שהם גדלים ככה, משמאל לימין,

127
00:49:03,860 --> 00:49:33,700
בשורה הראשונה, טכנית, מה יהיה גודל הסלייס? מ-0 עד 0 לא כולל 0? זה יהיה סלייס ריק. אז השורה הראשונה, הקודקוד של המשורה שזה, טכנית לא יתחיל אפילו בשורה הראשונה, יתחיל רק בשורה השנייה. למה? כי מה קורה עבור i שווה 1? מטריצה בשורה 1, אינדקס 1, סלייס שמתחיל מההתחלה, נגמר ולא כולל באינדקס 1. זאת אומרת, הארבע הזה.

128
00:49:33,700 --> 00:50:03,700
ושורה מתחת לזה יהיה לנו את ה7, 8 ושורה מתחת לזה זה כבר יהיה נו רשימה ב3 וכן הלאה וכן הלאה. בקיצור אנחנו בונים פה מטריצה שהיא בעצם תהיה משולש שמאלית תחתון של הרשימה המקורית של המטריצה המקורית. show transparent אן איך הם הולכים להגיד למה זה נכון? הy מקום להבטיח אם עבדתי אתכם, האם הם צריכים להבין למה זה נכון, הם הולכים להבין או שאיבדתי אתכם? איפה איבדתי אתכם? הבנתי

129
00:50:05,380 --> 00:50:15,700
אה... אני לא הכי השתכנעתי, אבל בסדר, רק בגלל שאין לנו את כל הזמן שבעולם, אני אמשיך בכל מקרה. בוודאי! בסדר. טוב... מה הסיבוכיות של הסיפור הזה?

130
00:50:15,800 --> 00:50:34,500
בן: W worst case. בוודאי! וורסט קייז. תזכרו: אנחנו מדברים על וורסט קייז... וואלה? כן. אין בריבוע. הוורסט קייז שלנו... ובאמת אנחנו... הדרך אגב... למה אין בריבוע אבל? זה לא סתם לזרוק ניחוש להגיד... אה... מטריצה מקורית... אז...

131
00:50:34,500 --> 00:50:38,500
נניח שהסיבוך יהיה במקרה הכי גרוע, זה עוד מטריצה מקורית, כן, אבל לא בדיוק.

132
00:50:39,440 --> 00:50:50,620
שימו לב לסכום של איך שאנחנו בונים את זה, אנחנו בונים פה סלייסים הולכים וגדלים, סלייס בגודל של 0, אחר כך סלייס בגודל של 1, אחר כך בגודל של 2-3.

133
00:50:51,400 --> 00:51:03,600
יש לנו פה סכום, סכום סדרה חשבונית שמתחיל מ-0 ונגמר בין פחות 1, אבל אתם יודעים מה הנוסחה לחשב סדרה חשבונית מ-1 עד n או 0 עד n פחות, אתם מבינים את הרעיון.

134
00:51:04,360 --> 00:51:24,080
יהיה לכם ספציפית פה, אתם יודעים מה זה יצא? הסכום מ-1 עד n-1 זה לא n כפול n ועוד 1 חלקי 2, זה בעצם זה טכנית, זה יהיה n-1 כפול n חלקי 2, אבל יש פה עדיין n כפול n בפנים, או של n בריבוע.

135
00:51:24,080 --> 00:51:53,600
אה, לא, פשוט כי הסכום שאנחנו עושים, אם אתה ממש רוצה לדעת, זה פשוט כי הסכום שאנחנו עושים הוא לא מ-1 עד n כולל, אלא זה סכום של מ-1 עד n פחות 1. רגע, אתם מבינים את זה? זה סדרה חשבונית, זה כאילו, אם אני אומר לכם עכשיו, רגע, הנה, אם אני עושה 1 ועוד 2 ועוד טה טה טה ועוד n ממש, אז אתם יודעים שזה שווה ל n כפול בסוגריים.

136
00:51:53,600 --> 00:52:23,600
n ועוד 1, כל זה חלקי 2, נכון? אבל מה אם אני עשיתי פה סכום רק עד ל-n פחות 1? אז פה זה כאילו n פחות 1, ושם זה פשוט n, כי אתה מבין? כן, אז כאילו פה אני סוגר את זה בסוגרון... בקיצור, עדיין יש לי פה O של סדר גודל n בריבוע. זה סכום סדרה חשבונית. אני אגיד לכם עכשיו מראש. כשאתם מתעסקים בסיבוכים

137
00:52:23,600 --> 00:52:53,600
הסיבוכיות, צריך לזכור בעל פה כמה סכומים מסוימים של סדרות, סדרה חשבונית, תורה, סכום של, לא יודע, סדרה הנדסית אולי, סיגמא של שתיים בחזקת איי, כשהאיי הוא מאחד עד אין, זה סכומים ששימושי לכם לדעת. גם אולי למבחן הזה, תלוי, אבל בעיקר למבנה נתונים, שם אחד מנושאים המרכזיים זה הסיבוכיות. זה מסוג הדברים שפשוט כדאי לכם לזכור בעל פה.

138
00:52:53,920 --> 00:53:23,920
בקיצור, מי ששואל אוקיי אז איך זה מתקשר לסיבוכיות מקום וזמן פה, אז התשובה היא - הפונקציה הזאת בונה סלייסים מהמטריצה המקורית. סלייס בגודל 0 ועוד סלייס בגודל 1 ועוד סלייס בגודל 2, אז סיבוכיות המקום בזמן פה היא בעצם זהה. גם בגלל הפעולה של בניית הסלייסים. ואני מזכיר לכם לבנות סלייס בפייתון זה פשוט לעשות קופי 1-1 איבר איבר, זאת אומרת, למצביע מצביע, אבל

139
00:53:23,920 --> 00:53:53,920
ואת מי אין את הרעיון, פעולת הסלייס היא לינארית באורך הכלת ואנחנו מביאים כלת בגדלים כאלה וסיבוכיות מקום, פשוט מאוד, אנחנו בונים מטריצה חדשה וכל רשימאי בגדלים האלה והמטריצה היא סכום כל הרשימות האלה אז עדיין זה גם יהיה אור שם בריבוע, גם פה וגם פה. לפני שאני ממשיך, הלאה, האם יש שאלות? האם זה לא ברור? שאלה? אם לא שמה? אין סלייס, מה זאת אומרת?

140
00:53:53,920 --> 00:54:23,920
יש רק מה? רק איי, אני לא מבין. אתם מתכוונים אפנד רק למט איי? אה, אז פשוט אם היה כתוב פה רק מט איי וזהו, זה לא כאילו שאני פשוט העתקתי את המטריצה המקורית? אז אני שואל אותך חזרה, האם הייתי עכשיו מעיף את הדבר השני, אז הייתי...

141
00:54:23,920 --> 00:54:53,920
מעיף את זה, פשוט מעיף את זה, אז זה כאילו שאני בעצם בונה פה פשוט קופי של המטריצה המקורית, זה עדיין או של אין בריבוע, ועכשיו זה אפילו יותר טבעי להגיד לך למה, קופי של מטריצה של אין בריבוע, אין בריבוע, אוקי, עוד שאלות? מניח שלא, אוקיי, עכשיו אנחנו מתחילים רצף של תרגילים שמי שעכשיו מסתכל ויפתח את הפאופוינט ויראה כמה תרגילים פה יהיה חרד אבל אל תדאגו איננו נעשה את זה די מהר

142
00:54:53,920 --> 00:55:23,920
הנה פונקציה מאוד מאוד פשוטה, זה כבר מסוג התרגילים שאתם יכולתם למצוא באיזשהו מבחן. פונקציה פשוטה. פונקציה שנקבלת שני מספרים, N ו-M גדול. אוקיי, נגדיר A ו-B להיות שווים 0, בסדר. עכשיו יש לנו פה שתי לולאות, 4i in range של M. A פלוס שווה איזשהו מספר אקראי. אחר כך לולה 4i in range של M. B פלוס שווה מספר אקראי.

143
00:55:24,300 --> 00:55:44,480
מבט מהיר על זה, מה עשו בוחיות זמן פה? לא שומע? יש פה שני מספרי קלט. לא בדיוק, כי שתי עלולות האלה רצות, לא רק אחת מהן, אבל הן לא קבועים, גם n וגם m הם משתנים.

144
00:55:45,200 --> 00:56:15,200
יש פה שני משתנים, לא אחד, אז לא מקסימום, סכום. O של n ועוד m. אני אה.. אני מבין למה אתה אומר את זה, כי עד עכשיו ראית סיבוכיות בהקשר של משתתי אחד, אבל פה ספציפית, אומרים לנו ישירות, יש לכם כאן שני קלטים נפרדים, שלכל אחד מהם יש אורך נפרד. ופה, ב.. בתרחישים כאלה, אנחנו לא מתייחסים רק לקלט אחד ומתאלימים מהשני.

145
00:56:15,220 --> 00:56:44,360
הם לא קבועים, לא n ולא m, ולכן אנחנו חייבים להגיד שהסיבוכיות כלת פה היא, סיבוכיות זמן פה היא o של n ועוד o של m, כי יכולים להביא לך n שווה 10 אבל m שווה מיליון, או להביא לך n שווה 10 וm שווה, לא, תשמע, תשמע, אני מבין אותך, אני מבין למה אתה אומר מקסימום, אבל אני מצטרך להגיד לך, רק בגלל שהם משתנים ולא קבועים, רק בגלל זה,

146
00:56:44,360 --> 00:57:14,160
אתה לא יכול להגיד מקסימום, אני מבין את ההיגיון שלך ואני אומר לך עדיין אי אפשר להגיד פה מקסימום, פה ספציפית הפונקציית סיבוכיות שלנו זה אחד מהעקרונות שדיברנו עליו, היא פונקציה על גודל הקלט, אבל יש לך פה שני קלטים, אז אני מבין ועדיין, הפתרון הוא O של N ועוד M בזמן ומקום אחד כי יש לך פה פשוט מה?

147
00:57:14,160 --> 00:57:44,160
A, B ו-I, שלושה משתנים. שאלות? אז תזכרו, אני יודע? ראינו פה עכשיו, קלט שני, ועדיין, בגלל שכל קלט הוא משתנה, וזה דינמי, אז כל משתנה, כזה, מגיע לו את המקום הנפרד שלו, בסיבוכיות. אוקיי, לומדים, לומדים. תרגיל שני, פונקציה. נתחיל...

148
00:57:44,160 --> 00:58:14,160
a שווה 0. אחר כך, לכל i בריינג' של n, אוקיי, אז ברגע שאנחנו רואים את זה ישר בראש אומרים n כפול משהו. מתחילים ב-n כפול משהו. מה? פה כתוב 4j בסדר ההפוך של הריינג' שמתחיל מ-i עד n. זה בכוונה מכשיל. זה מכשיל. אבל, לא באמת. קודם כל, reverse

149
00:58:14,160 --> 00:58:44,160
אני אומר לכם עכשיו, מטעמי חישוב לא מעניין אותי. אני מוחק את זה בראש, מנטלית, לא קיים. ריינג' שמתחיל מ-i ועד n. זאת אומרת, שימו לב, כש-i שווה 0, אז יקרה 0 או פעם אחת. כש-i יהיה שווה פעם אחת, זה יקרה מה? פעם אחת?לא, רגע, לא, אפוק, אפוק, סליחה, רבעס. לא, אתם צודקים, אתם צודקים. סליחה, אפוק. כש-i יהיה שווה n פחות 1, זה יקרה...

150
00:58:44,160 --> 00:59:14,160
פעם אחת, כש-I יהיה שווה N פחות 2 זה יקרה פעמיים, אוקיי, נכון, זה למה אני אומר מראש הסדר לא עניין אותי כי בסופו של דבר החישוב, הסכום פה יהיה אותו סכום, מה הסכום? כמה פעמים מה שרץ פה בתוך הפור השני ירוץ, זה ירוץ, 1 ועוד 2 ועוד 3 ועוד 4 ועוד 5 ועוד N פחות 1 פעמים, עכשיו אתם מבינים למה אמרתי את מה שאמרתי? שוב, העלולה החיצונית היא מעבירה את I מ...

151
00:59:14,160 --> 00:59:30,000
היא 0 עד N פחות 1, בסדר. הלולה הפנימית אבל, היא אומרת, שככל ש-I גדול יותר, מה שקורה בפנים, רץ מעט יותר פעמים.

152
00:59:31,600 --> 00:59:41,640
אז פה אנחנו כן, הייתי אומר, אולי כדאי שווה לקחת מה שנקרא, דף ו-S, ולכתוב את זה. מכתוב מה אנחנו מבינים שקורה פה.

153
00:59:42,300 --> 01:00:12,260
אז זאת אומרת, עבור I שווה 0, זאת אומרת, זה ירוץ לנו, לא יודע, N פעמים, נניח N פעמים, בסדר? ועבור I שווה, אני מדבר איתכם על הלולה אפור השנייה, בסדר? כמה פעמים מה שבתוך הלולה השנייה רץ. אז אני אומר לכם, עבור I שווה 0, הריינג' יהיה פה ריינג' המלא. אז הלולה הפנימית תרוץ N פעמים, ואז I שווה 1, אז היא תרוץ N פחות 1 פעמים, ואז היא תרוץ...

154
01:00:12,260 --> 01:00:42,240
N ועוד פחות 2, אתם מבינים? ואז אתם כבר יכולים בראש, בראש שלכם כבר לעשות את ה-וודג' שלוש נקודות, אוקיי? עד שה-I מגיע ל-N פחות 1, ואז בעצם זה ירוץ למה? פעם אחת? בקיצור, מה כתבתי פה כרגע? מה כתבתי? סכום סדרה חשבונית, מ-1 עד N, ואנחנו כבר יודעים, מה הסיבוכיות של כזה דבר? O של N בריבוע. זאת אומרת, סיבוכיות זמן פה, היא O של N בריבוע.

155
01:00:42,240 --> 01:01:12,240
בריבוע, זאת התשובה. לפני שאני ממשיך, האם למישהו זה לא ברור, למה? אז זאת אומרת, בשאלות, עכשיו הנה טיפ שאני יכול לתת לכם מהבנה שלי: הרבה פעמים בשאלת ציבוכיות זה קל ליפול למלכודת שבה אנחנו רואים איזושהי לולה חיצונית כלשהי, להעסיק מסקנה מראש, ואז, לא כל כך להבין מה קורה בלולה הפנימית, לא כל כך להבין מה היחס שלה לדברים מבחוץ,

156
01:01:12,240 --> 01:01:36,560
ואז אולי אני יכול ליפול למלכודת, אולי הייתי יכול להניח שלא יודע, פה זה L כפול ואז, טוב רגע, אני לא יודע מה קורה פה, אבל אז אתם ראיתם שאם אני לקחתי את כל זה, ישבתי על זה, חשבתי, כתבתי פה, בניתי את הביטוי, פתאום אני קולט, אה רגע, זה סכום סדרה יש בונים, ואז אני לא הייתי חייב להיות תקוע רק על זה ש-for I in range של M.

157
01:01:36,560 --> 01:02:06,220
אז אני לא יודע אם מה שאמרתי עכשיו אומר לכם משהו, אני רק מנסה להגיד לכם, לפעמים אתם יכולים בחישובי סיבוכיות להיתקע על גישה כלשהי, ויכולה לא לתת לכם לסיים. שאלה. אם ההגנה השנייה הייתה ברנג' של M.אז מה היה כתוב פה? אם היה כתוב פה 4J in range M, אז זה לולה קלאסית של M בריבוע. זאת אומרת. זה אותו דבר, או של M בריבוע. לא, כן, רגע.

158
01:02:06,220 --> 01:02:16,780
ה-O של N בריבוע, אתה צודק, אבל אתה מבין ש... בוא נגיד את זה ככה, כשאתה מחשב את זה ב-O של, אתה צודק לגמרי.

159
01:02:16,780 --> 01:02:26,860
במציאות, כמובן שיש הבדל בין N בריבוע מלא, לבין N כפול N פחות 1, או N כפול, סליחה, N כפול N ועוד 1, אבל חלקי 2.

160
01:02:26,860 --> 01:02:35,360
הרי ברור לך ש... זה קצת חצי מלא, מה שנקרא, אבל ב-O של, אתה צודק, זה אותו O של. בסדר.

161
01:02:35,360 --> 01:03:05,340
אז אמרנו סיבוכיות זמן היא O של N בריבוע, כי זה סכום סילביו הישבוני, אחד עד N. יפה, תרגיל הבא בתוך. עכשיו בואו נתעסק קצת עם חזקות. וזה שימושי. אוקיי, פונקציה כזאת. שאלה? פונקציה קודמת. כן? מקום? נכון. למה סיבוכיות מקום היא O של 1? יש לנו את A משתנה. I.

162
01:03:05,340 --> 01:03:35,340
משתנה שמשנה את הערך שלו, J משתנה שמשנה את הערך שלו ופה חישובים מתמטיים בגודל השתיים שלושה נפרדים במקסימום, בקיצור O של אחד. רגע, אהלן, כן? אחת שניינטג נפרדת. have a crush ב... לא לא זה הכל ביחד רגע רגע רגע רגע, מה שכתבתו כאן, שימו לב למישהו שמתבלבל, כתבתי פה N ועוד M-1 ועוד  פחות 2, כתבתי פה, שים לב כמה פעמים

163
01:03:35,340 --> 01:04:05,340
הפקודה הזאת תרוץ. תסתכל, עבור i שווה 0 יש לך פה עלולה פנימית 4j אם, העזוב אותך שסדר הפוך, רברסט, עזוב את הרברסט, ריינג' שבין i ל-n, אבל אם i שווה 0, זאת אומרת כאשר עלולה חיצונית היא על i שווה 0, עלולה פנימית תרוץ n פעמים, וזה מה שאמרתי, יש פה הפקודה הזאת, הרי כל ה-

164
01:04:05,340 --> 01:04:33,140
הורים האלה הם רק כמה פעמים מה שבפנים ירוץ, כן? אז זה ירוץ n פעמים, אחר כך סיימנו את זה, i שווה 1, ואז הריינג' הזה יתחיל מ-1 עד n גדול, אתה מבין? n פחות 1 פעמים, וכן הלאה בכלל. זה החישוב. כל פעם שאתם רואים 4, 4 אומר לכם, הנה מה שבפנים, כמה פעמים זה הולך לרוץ.

165
01:04:33,140 --> 01:05:03,140
או של n בריבוע, סכום סדרה חשבונית, לא, אני בודק, לא, אני בודק את הכל ביחד, לא, אז רגע, זה בדיוק, האמת זה מתקשר למה שאמרתי ממקודם, לא להתבלבל בטעות, לא לנסות, לפעמים, כשאתם מפרידים, בין כמה כל 4 רץ בנפרד, אתם קצת מאבדים את התמונה הכוללת, זה מה שניסיתי להגיד

166
01:05:03,140 --> 01:05:33,140
מקודם האמת, ולא הצלחתי. אז זה למה אמרתי, אם מקודם אתה אומר for i ראית של n, אה סבבה, זה n כפול, מה שזה לא יהיה של לולאה פנימית אומרת לי, אני אומר, יופי, וזאת הגישה שתתקע אותך במקום, כי אתה לא תדע איך לחשב. התשובה היא, תסתכל על הכל ביחד, תנסה להבין, הלולאה פנימית, איך היא תלויה בלולאה החיצונית, ואז הבנו, אה, עבור i שווה 0, זה ירוץ n פעמים, עבור i שווה 1, זה ירוץ n פחות

167
01:05:33,140 --> 01:06:03,140
בכל פעמים. בונה, בונה, בונה, מסיים סכום סדרה חשבונית הרי יש פקודה אחת בלולה הפנימית, אז אני יודע שאני אפילו לא צריך לעשות כפול משהו, אלא פשוט לספור כמה פעמים, זה ירוט. ספרנו, מצאנו סכום סדרה חשבונית, הבנו שזה או של n בריבוע. אוקיי אז בואו נמשיך, בכל זאת אני רוצה להספיק דברים. אוקיי אז תגיש שלישי, אנחנו צריכים לעשות טיפה ספדרון על העניינים, מה? לאט לאט רגע

168
01:06:03,140 --> 01:06:06,880
שנייה, בואו נתחיל את זה, בשביל מי שלא מהרו.

169
01:06:06,880 --> 01:06:13,560
נתחיל מכ-a שווה 0, אוקיי, 4i in Range שמתחיל ב-n חלקי 2 ונגמר ב-n.

170
01:06:13,560 --> 01:06:32,680
אוקיי, אז יש לי פה n חלקי 2 כפול, נניח, עדיין, O של n בלולא החיצוני. מה קורה בפנים? יש לי פה j שווה 2 ואז גלולה שאומרת, כל עוד ש-j קטן שווה מ-n, אוקיי? יש לי פה k פלוס שווה, לא מעניין אותי.

171
01:06:32,680 --> 01:07:01,180
יש לי פה j כפול שווה 2. תראו מה קורה פה, j התחיל מ-2, אני מכפיל אותו ב-2, עכשיו הוא 4, מכפיל אותו ב-2, עכשיו הוא 8 וכן הלאה וכן הלאה עד ש-j מגיע להיות n. אז עכשיו אני שואל אתכם, תעזבו רק לרגע את הלולאה החיצונית, אנחנו רואים שלולאה פנימית אין קשר ללולאה החיצונית, לכן מותר לעשות ההפרדה הזאת.

172
01:07:01,940 --> 01:07:31,940
קודם כל לולאה פנימית, אני שואל אתכם, כמה פעמים, מה הסדר גודל של הלולאה הפנימית? מה סדר גודל החזרות שהיא חוזרת על עצמה? אז התשובה היא לוב בסיס 2 של n, ועכשיו אני כן רוצה להתעכב לחצי שניה, להסביר את זה, כי אני יודע שלוב לא אינטואיטיבי לכולנו, אז חכו שניה, הנה מה שאני רוצה להראות לכם, תראו, נניח שיש לי, אני אתן לכם עכשיו דוגמא, עם מלון כדורדנים

173
01:07:31,940 --> 01:08:01,940
מספרים, נניח שיש לי J שווה 2, נניח ש-N גדול שווה 8, עכשיו השאלה היא J בחזקת כמה כדי להגיע ל-8? J בחזקת מה ייתן לי 8? 2 בחזקת מה ייתן לי 8? 3! זאת אומרת האפונקציית ווייל הזאת היא תרוץ 3 פעמים, 2 ...

174
01:08:01,940 --> 01:08:31,940
או שלוש, או פעמיים, אתם יודעים משהו? נקרא לזה, אז הפונקציית y הזאת היא תרוץ את ה-log פעמים הזה פחות אחד. או, הנה, כי אנחנו מתחילים את j משתיים ולא מאחד, יאללה. אז יש לי פה שתיים, כפול שווה הוא ארבע, כפול שווה שמונה, אה, אומרים לי y j קטן שווה ל-n, זה אגב למה כתוב פה קטן שווה ולא קטן מי, כי זה עדיין ירוץ ש-j יהיה שווה ל-n עצמו, אתם מבינים?אתם מבינים? גם שווה קטן שווה

175
01:08:31,940 --> 01:09:01,940
ש-j שווה n זה עדיין ירוץ, אז זה כן ירוץ בדיוק לוג בסי שתיים פעמים, זאת אומרת, יש לי, רגע, איפה שהיינו, אחורה, אחורה, אחורה, אוקיי, נו, הנה, אוקיי, אל תאבדו ריכוז, j מתחיל מ-2, j כפוי שווה 2, כמה, 4, 4 קטן שווה לשמונה, אז j כפוי שווה 2, כמה, 8, 8 קטן שווה לשמונה, אז  כמונט,  שווה x,  שווה x ח Esta, עכשיו אתם שונים להשמונה, אז שים את עצמך, בשבה אתם להמרוכים. אוקיי? רגעה אתה חייב לחמוד רבה,

176
01:09:01,940 --> 01:09:31,940
אז j כפוי שווה 2, כמה? 16, עכשיו זה יעצור, בקיצור, עכשיו אוקיי, איך אנחנו סופרים את זה? אז התשובה היא, התשובה היא כמה פעמים הלולאה הפנימית הזאת רצה, התשובה היא log בסיס 2 של n. זה כמה פעמים, log בסיס 2 של n, זה בדיוק כמה פעמים לולאת ה-while רצה. לפני שאני ממשיך, האם יש לכם,

177
01:09:31,940 --> 01:10:00,740
שאלות האם זה לא ברור ואני מדגיש לוג בסיס 2 מה זאת אומרת איך לוג עובד? כשאני כותב לוג בסיס 2 של N אני אומר זה מה החזקה שאני מעלה את המספר 2 כדי להגיע לN, זאת ההגדרה של לוג ואני מדבר בכוונה אני אומר את המילה בסיס כי זה יכול להיות לכם לוג על בסיס שונה אבל פה דיברתי על לוג בסיס 2, כן?

178
01:10:00,740 --> 01:10:30,740
והוא זכה ללוק בשביל שתיים, פה כבר? תראה, אתה יכול לכתוב במחשבון לוג ואתה תגלה שזה יהיה לוג בסיס עשר, אתה יכול לכתוב את המילה לן, אל אין, וזה לוג בבסיס של המספר אי, של השתיים, נקודה שבע, אחד, ככה וככה. אבל אנחנו לא... במדעי המחשב הרבה פעמים יהיה לך נוח לעבוד עם לוג בבסיס שתיים, אבל אני אומר, אם יש ספק, אם במה שאתה כותב, מה שאתה מתעסק, יש ספק, תגיד איזה בסיס הלוג, אם יש ספק. אם אין,

179
01:10:30,740 --> 01:11:00,740
אם כולם מסכימים על אותו בסיס, בסדר, אל תכתוב לי. אבל פה, אני מלמד אתכם, אני רוצה שיהיה לכם ברור איזה בסיס לוג זה. שתבינו מה זה בעצם אומר. לכן, הלולאה הפנימית היא רצה לוג n פעמים, והיא בעצמה רצה כמספר הפעמים של לולאה חיצונית מריצה. לולאה חיצונית אמרנו שהיא רצה חצי n פעמים, שזה o של n. כלומר, יש לי פה o של n כפול o של לוג n. מה התשובה?

180
01:11:00,740 --> 01:11:30,740
סופית פה o של מה זה? o של n log n. עכשיו האם יש שאלות? משהו בתרגיל הזה? מקווה שלא, אז בואו נמשיך, נעשה את זה כבר יותר זריז, פונקציה מאוד מאוד פשוטה. a שווה 0, אוקיי, לא מעניין אותי, i שווה n, אוקיי, כל עוד שi גדול מ-0, מה אני עושה? a פלוס, לא מעניין אותי, i חלק מאחת רואה, חלק יותר. אוקיי, בעצם זה יקרה שאת אגרוף תנאים יקרה אני חולק קצת דרך לגיהינום, הפרקום שלה זה יעלה לזה שאני יכול להגיד שאני אדרג לחברתי אני אגנה והיופעתי של הכל ב

181
01:11:30,740 --> 01:12:00,740
חלקי שווה 2, אז זאת אומרת, אני לוקח את i, מחלק אותו ב-2. גדול מ-0? מחלק אותו ב-2. גדול מ-0? מחלק אותו ב-2. מה הסיבוכיות של הדבר הזה? לוג בסיס 2 של n, בדיוק. למה? כי מספר הפעמים של עולתboriler הזאת אמורה לרוץ, זה בסדר גודל, לוג בסיס 2 של n, כי זה בערך כמה פעמים שהייתי צריכים להעלות בחזקה את המספר 2, כדי להגיע ל-n, ופה אנחנו פשוט עשינו את הפעולה הפוכה, חילקת

182
01:12:00,740 --> 01:12:18,200
רגע, משום מספר כל אחד של השיגל ה' ערך ערך כמו  והחוף זה שמישהו של שנים מגיעה אחרת ששניהם חלקים, מי ייצא אותו יחד לשבעה ומתנהלו יחד לשתוי?

183
01:12:18,380 --> 01:12:44,640
אוקיי, נקסט, עכשיו שאלות של היי רגע, אם אתם עדיין ערים, מה הקריטריונים הכי טובים בשביל להשוות את היעילות של אלגוריתמים? אז תשובה ראשונה אומרת מספר הפעולות, תשובה שנייה אומרת מקום בזיכרון, תשובה שלישית אומרת גם תשובות א' וב' ותשובה רביעית אומרת אף אחד, אז מכל מה שהעברנו עכשיו בתרגול, זרקו ניחוש, מה התשובה שאנחנו מעדיפים לשמוע?

184
01:12:44,640 --> 01:13:14,640
אתה יודע מתא יודעת שלמה גם לדעת אותך אותי והפך מספר פעולות. אז אנחנו בתרגול הזה נגיד לך גם וגם. שאתה צריך את שניהם. שאתה צריך גם סיבוכיות זמן, אבל אתה גם צריך סיבוכיות מקום. אבל זה בערך כלל. אני מסכים איתך, הרבה פעמים מדברים רק על סיבוכיות זמן. אני מסכים איתך, אבל מה העניין? יכול להיות לך אלגוריתם של סיבוכיות זמן מאוד קטנה, אבל סיבוכיות מקום משהו ענקי . . . . . . . אני בהחלט לא בהכנח אותך ... אותה שסיבכית זמן משהו שאתה לא יודע או אהיה, שלמעשה שאתה יודע מישהו הזה, אתה צריך ... מספר פעול

185
01:13:14,640 --> 01:13:44,640
זה יהיה רלוונטי, אז השאלה הזאת, זה שאלה של סתם, זה סתם שאלה (�טעון) -אבל בדרך כלל אתה ממעביד שזה יותר יותר מ..דרך כלל 
-לפעמים, לפעמים ועדיין לא תמיד, לפעמים ועדיין לא תמיד, זה תלוי בצורך, תלוי במימוש, תלוי בתמשיכתה, תלוי שלוש נקודות, לא משנה, זה סתם, בסדר? זה סתם שאלה. שאלה 6, לראות אם אתם עדיין זוכרים, איך אנחנו מודדים סיבוכיות מקום א, אז איזו תשובה

186
01:13:44,640 --> 01:13:54,000
מה לדעתכם היא הכי נכונה? זה אגב מתרגל אתכם למבחנים שבהם התשובות כתובות בצורה לא ברורה.

187
01:14:02,960 --> 01:14:14,560
נכון, התכוונת הכותב פה הייתה מה שסיף ג' מנסה להגיד, זאת אומרת לספור כמה יחידות זיכרון, תאי זיכרון,

188
01:14:14,560 --> 01:14:43,260
אנחנו צריכים בשביל להריס את התוכנית הזאת. היי, אני אמרתי לך עכשיו, זה מתרגל אתכם למבחנים שבהם התשובות לא הכי ברורות ואתם צריכים בחוש השישי להבין מה התכוון הכותב. אל תגידו שאנחנו מלמדים אתכם רק פייתון, מלמדים אתכם קצת יותר. אוקיי, יאללה, חזרה לשאלות הכן רלוונטיות. אוקיי, תודה רבה.

189
01:14:43,260 --> 01:15:13,260
הפונקציה הכי פשוטה שבעולם, שהיא באמת מכווינה אתכם לסיבוכיות שכבר דיברנו עליה, כבלו i, אנחנו רוצים ש-i יגיע ל-n, מתחילים את i ב-1, וכל עוד ש-i קטן מ-n, מכפילים את i כפול שווה עם k. אז באמת השאלה כמה פעמים עלולה-at-y זאת תרוץ, התשובה היא log בסיס k של n, זה אומר k בחזקת,

190
01:15:13,260 --> 01:15:43,260
למה, מביא אותנו לאין? התשובה היא, מספר הפעמים שזה ירוץ. שאלות? מניח שלא, כבר דיברנו עכשיו הרבה על לוגיים. יופי, וממשיך הלאה. אוקיי. בסדר, הנה פונקציה עם טריק אחד מכשיל שאולי עוד לא ראיתם. אוקיי, פונקציה שמקבלת מכרוזת. בסדר, הנה הפונקציה מתחילה. לכל אות, בתוך...

191
01:15:44,200 --> 01:16:14,200
רשימת האותיות באנגלית כתוב לכם פה למטה אינגליש לטרס = ככה וככה אני אומר לכם מראש אל תתבלבלו נניח שאינגליש לטרס זאת רשימה של 26 שטבים A,B,C עד Z אוקיי אז לכל אות ברשימת האותיות באנגלית אנחנו שואלים אם האות הנוכחית לא נמצאת במחוזת הקלט בחזיר falls. ואם איכשהו...

192
01:16:14,200 --> 01:16:27,060
מצאנו כל אות ברשימה, מהאותיות האנגלית, מצאנו כל אות בתוך הכלת שקיבלנו, נחזיר תרופה. עכשיו אני שואל אתכם, מה סיבוכיות זמן של הדבר הזה?

193
01:16:33,560 --> 01:16:43,320
זו שאלה מאוד מכשילה. -מה? -השאלה היא סיבוכיות זמן של זה. -סיבוכיות זמן של זה? -כן, סיבוכיות זמן של זה. -סיימי בבקשה את הצלם. -מעניין.

194
01:16:43,320 --> 01:17:13,320
אוקיי, בואו אני אעזור לכם, יש פה שני דברים שלא ברורים אליהם כשאתם רואים את זה פעם ראשונה, קודם כל, ה-4 של, ה-4 הזה, 4 אות ברשימת האותיות באנגלית, אז עכשיו תכירו, בגלל שרשימת האותיות באנגלית היא קבועה תמיד, והיא לא תלויה בכלל, פה במקרה הזה 26, זה יכול גם היה להיות אלף, לא משנה, קונספטואלית, ה-4 הזה הוא o של אחד האותיות שלך פעם ראשונה, ואתה יכול להרשות את זה לכל אחד מהאותיות שלך בבית הלטפון. תהיה מוכן לא להתגורר, יצא פה להעביר תחברים בשובל ז

195
01:17:13,320 --> 01:17:43,320
מה שלומך? מה קורה?

196
01:17:43,320 --> 01:18:13,320
אבל זה בשבילכם. בסופו של דבר בשבילכם, לנות לכם השאלות לפני שהם צצו אחרי. אז, אם אות לא נמצאת באיפוט סטרינג, אז פה דווקא פעולה כבדה. למה? אופרטור אין משווה, בודק, בעצם בתוך אופרטור אין מתחבא לכם מימוש של חיפוש. חיפוש האות בתוך המחוזת. עכשיו מן הסתם שהמחוזת היא לא... לא נתון לכם

197
01:18:13,320 --> 01:18:43,320
המחרוזת היא ממויינת, אף אחד לא אמר לכם שהתווים בתוך ה input string ממויינים מהקטן הגדול, לא, זה טקסט שמישהו כתב, אז החיפוש הוא אם ככה, חיפוש בדרך הקשה, לעבור תו, תו, תו, תו, ולבדוק, , הי, תו, האם אתה שווה ל letter, זהו, אז עכשיו לשאול אתכם, האופרטור , מה הסיבוכיות שלו, owe של n, כלומר owe של אורך ה input string, ולכן

198
01:18:43,320 --> 01:19:13,320
כן, אה, וזה שכתוב פה Note זה כלום, זה רק אומר, אחרי שרצת את אופרטור אין, תגיד לי ההפך ממך, זה בסך הכל בוליא�ון. בקיצור, בגלל אופרטור אין הזה, למעשה יש לנו פה, 4 שרץ O של אחד פעמים, כפול, O של N. אז סיבוכיות הזמן של כל הסיפור הזה, זה O של N. בגלל אופרטור אין, לא בגלל ה-4. האם עכשיו הבנתם?

199
01:19:13,320 --> 01:19:42,860
שאלה, אם פייפון לא עשה חיפוש בינארי, אנחנו נדבר על חיפוש בינארי יותר מאוחר, זאת אומרת עוד כמה דקות כשנגיע לזה. האינ הזה? לא אני אומר לך, האופרטור אין הזה, הרי מה הוא עושה? הוא עובר על כל האינפוט סטרינג תו אחרי תו, לא רגע רגע.

200
01:19:42,860 --> 01:20:12,120
הפור הזה עושה משהו אחר, הוא עושה פור אייטם בתוך רשימה שהאורך שלה הוא קבוע, זה למה זה או של אחד הפור, האו של אין מגיע לך מתוך הפקודה של אופרטור אין. זה בסדר, אני כן מתייחס אליו, אבל תחש מה? זה אין רשימה באורך קבוע. לא אינפוט סטרינג, העורך שלה זה האין המדובר.

201
01:20:12,120 --> 01:20:41,960
זה ה... כן בדיוק, זה מחזיר אותנו חזרה לעיקרון הראשון של, בוא נגיד את זה ככה, חכו שנייה לפני שאתם מאבדים אותי, לא סתם התחלתי, שנייה אל תאבדו אותי, לא סתם התחלנו את התרגול בלדבר על העקרונות, העיקרון הראשון אומר שאנחנו מחשבים את הסיבוכיות בתור פונקציה על גודל הקלט, פונקציה בסוגריים על מה? על אין, אורך, גודל הקלט, הקמה, אם זה סטרינג?

202
01:20:42,000 --> 01:21:11,680
כמה תווים? אם זה מטריצה? כמה איברים יש במטריצה? זה, זה החישוב. סבבה, זה טוב שאנחנו עוברים על זה. אוקיי, אני עובר הלאה. אז דיברנו על זה, התשובה כאן היא O של N, בגלל אופרטור אין. יש לנו פה 26 כפול O של N, O של N. נקסט, תרגיל צ'י, אוקיי, שאלה קונספטואלית ששואלת אם אתם זוכרים את ההגדרה. נתונים?

203
01:21:11,680 --> 01:21:41,680
‫אם שני אלגוריתמים, ‫לא להבה־האתי בבקשה, שני אלגוריתמים, ‫אלגוריתם ראשון, a, סיבוכיות שלו, oli. ‫אלגוריתם שני, b, סיבוכיות של על של log n. ‫שאלה, האם בכל תרחיש אפשרי ‫אלגוריתם של ol שלog n, ‫ירוץ יותר מהר מאלגוריתם של ln? ‫נכון מאוד, זאת השאלה, ‫השאלה היא האם תמיד. ‫לא נכון. ‫-לא נכון. ‫למה לא? ‫הגול ה-n שווה.

204
01:21:41,680 --> 01:22:11,680
בדיוק, עבור ה-N0 האלה, עבור ה-C הזה, שהם קטנים מספיק, עבור מקרה הקיצון בהתחלה של האלגוריתמים. פחות או יותר, כן. ואז אם הייתי מבקש מכם במבחן לכתוב דוגמא נגדית, אתם הייתם עכשיו כותבים, לא יודע, משהו, לא יודע, נניח O של ה-LGN, הייתם כותבים נניח פונקציה שהיא, לא יודע, מה-LGN, או אני לא יודע מה.בקיצור, אתם הייתם כבר מוצאים.

205
01:22:11,680 --> 01:22:41,680
הייתם ממציאים, איזה שהם שים, כל שהם, הייתם ממציאים מה שצריך. בקיצור התשובה היא, לא שומע? בדיוק, עבור כלת שהוא קצר, hand5 זה גם דוגמה טובה, זה גם דוגמה מעניינת. אוקיי, זה גם דוגמה טובה. בקיצור, אתם יכולים להנפיץ דוגמאות נגדיות, וגם אם לא, תזכרו את ההגדרה, ההגדרה של ה.. אני יודע שאנחנו כבר הולכים על

206
01:22:41,680 --> 01:23:11,680
הפסקה, אבל בבקשה, תנסו להתרכז, זה תראו בשבילכם. בקיצור, הדוגמאות הנגדיות שאתם יכולים להביא זה גם עבור N' שהם קטנים מ-N0 כלשהו, עבור C שהוא קטן יותר ממה שצריך, לפי הגדרה גם. בקיצור, מצאתם את התשובה. אוקיי, תרגיל 10, פיבומאצ'י. באמת שזה חשוב לי להראות לכם, אז תנסו לעקוב, אני יודע שאנחנו נקפוץ קצת על ההפסקה, אני מצטער, אבל זה חשוב. אתם זוכרים את הפתי

207
01:23:11,680 --> 01:23:41,680
הפתרון הרקורסיבי למצוא את פיבונצ'י, נכון? כן, ואני רוצה להסביר למה, אני רוצה להסביר למה, שנייה, סיבוכיות הזמן של הפונקציה שמוצאת פיבונצ'י בצורה רקורסיבית, איך אתם הייתם מצליחים לחשב את סיבוכיות הזמן? אז תראו, התשובה היא, יש הרבה דרכים, אני רוצה להראות לכם דרך אחת, שאתם תראו דוגמאות נוספות לה בקורס מבני נתונים.

208
01:23:41,680 --> 01:24:11,680
אוקיי, אז תראו בבקשה, אתם רואים כאן את הפונקציה של פיבונאצ'י, איך אני הייתי מנסה לבנות את החישוב. עבור המספר הפיבונאצ'י ה-n , הנה מה שאני עושה. אני עכשיו אכתוב את זה בתור t של n, זמן לפי n. יש לי את, נניח, לא יודע, את השאלה של ה-if, ולחשב סכום של מה שהft בין פחות 1 ו עין פחות 2 מפגרינם. בקיצור זה o של 1, אבל o של 1 זה החלק הקal, חוץ מ-o של 1. ולפי כך, אתה יכול להכיר האינטגרצציה הזאת הזאת המיועדת

209
01:24:11,680 --> 01:24:41,680
יש לי את ה-T של N פחות 1 ועוד T של N פחות 2. האם אתם מבינים את מה שכתבתי כרגע? אני שוב אני כותב, פונקציית ציבוכיות הזמן של ה-fibonacci ה-N היא בעצם שווה לציבוכיות הזמן עבור ה-N פחות 1, כי אני קורא, פיזית, קורא לפיו של N פחות 1 ועוד הציבוכיות של ה-N פחות 2, שוב, כי אני קורא לפיו של N פחות 2.

210
01:24:41,680 --> 01:25:11,680
ואו לא יודע איזה שהוא O של אחד, ואני אגיד לכם כבר עכשיו כמה ה-O של אחד הזה מעניין אותי, מספיק בשביל שנמחוק אותו, ברמה הזאת. אה, אתה מריץ את האיף הזה, השוואה, מתמטית, אתה חייב פעולה,אבל אתם מבינים ש- in the grand scheme of thing לא רלוונטי לחישוב הגדול, עכשיו. אני רוצה עדיין למצוא לדבר הזה חסם מליון די טוב. אני רוצה למצוא O של. אז

211
01:25:11,680 --> 01:25:25,240
אז לאט-לאט, איך אני הייתי עושה את זה? אז תראו, פה אני עושה טריקים של אי שוויון. מה אני אומר? אני אומר ש-T של M פחות 1 ו-T של M פחות 2 הם קטנים מממה?

212
01:25:25,240 --> 01:25:38,780
מ-רגע, משתיים כפול T של M פחות 1. מה זאת אומרת? לגחתי את ה-M פחות 2, זה פחות זמן מ-M פחות 1, נכון? אוקיי, מה זאת אומרת?

213
01:25:38,780 --> 01:26:08,700
אני אומר שכל זה, זה פחות זמן ממה? מפעמיים, T של M פחות 1. עכשיו, הנה הקטע שבו זה כבר נהיה כיפי. מה זה אומר? אני אקח את הקטן מי שעשיתי עכשיו, ואני אכניס את זה פנימה. מה זאת אומרת? אני יכול גם להגיד שזה בעצמו קטן ממה? קטן משתיים כפול של השתיים כפול של... רגע, כפול של T של M.

214
01:26:08,700 --> 01:26:38,560
פחות שתיים. רגע, אני רוצה שתראו את זה. אוקיי, האם אתם מבינים מה עשיתי פה? תסתכלו, T של M פחות 1, פשוט קחו את זה ותפעילו עליו את מה שעשיתי כאן. זאת אומרת, T של M פחות 1, אני יכול להגיד, אתה קטן מ-2 כפול T של M פחות 2. אל תלכו לאיבוד, אני לא ממציא פה משהו חדש, אני מתחיל מאיך שהגדרתי את T של M לכל N.

215
01:26:38,560 --> 01:27:08,560
כן, אתם יכולים לקחת את הN הזה מלפחות אחד מותר לכם לוקח את זה, אני יודע מה ההגדרה שלו, אני אומר תי של N קטן משתיים כפול תי של N פחות אחד, אז תחליפו את האין הזה בכל אין שבא לכם, פה אני כותב N פחות אחד, אין בעיות, אז אני הולך למסקנה שמתבקשת, זה קטן משתיים כפול השתיים כפול זה, למה זה טוב? למה זה טוב? כי מה בעצם המסקנה שאנחנו מגיעים אליה, זה קטן ממה? מה תבנית פה?

216
01:27:08,560 --> 01:27:38,540
יש לי פה 2 בחזקת i, כל זה, שימו לב, זה מביא אותנו לתשובה. זה בעצם 2 בחזקת i כפול t של n, רגע, פחות i, או במילים אחרות, מתישהו אני אגיע ל-2 בחזקת n, רגע, בחזקת n, נו, מתישהו זה יקרה. כל זה כפול o שם.

217
01:27:38,540 --> 01:28:08,540
של אחד, לזה התכוונתי, לזה, לזה חיפשתי, לביטוי הזה. זאת אומרת, כל הקטן מי, קטן מי, קטן מי... לפרוס לN פחות, עוד קטן יותר, ועוד יותר קטן מזה. כל העבודה הקשה הזאת כדי שיכולתי להגיע לחסם עליון שאני יודע שהוא נכון. למה? עשיתי עבודה, כל זה קטן מי? קטן מי? -אבל אתה יכול לעשות את זה... -זה הכל קטן מי? הכל קטן מי?

218
01:28:08,540 --> 01:28:38,540
‫אני כן יכול להגיד לכם ‫ש-T של N הוא באמת קטן מ-2 חזקת N. ‫אין בעיות, אין בעיות, תסתכלו. ‫אני יודע שאנחנו מוחקים את ההפסקה, ‫אני יודע, אבל תנסו לעקוב, תנסו לעקוב. ‫נתחיל מהקטן מ הראשון, ‫זה שאתם הודאיתם איתי איתו. ‫אתם ראיתם, הגדרנו את T של N… ‫העפנו את ה O של 1, לא עניין אותם. ‫הגדרנו את T של N להיות,  ‫-T של N פחות 1, ועוד, ‫T של N פחות 2, נכון? ‫עד כאן סבבה? ‫אמרנו...

219
01:28:38,540 --> 01:28:56,580
t של n פחות 2 הוא קטן מ-t של n פחות 1, הגיוני, פחות קריאות רקורסיביות, נכון? אז t של n פחות 1 ועוד t של n פחות 2 זה קטן מפשוט להגיד פעמיים t של n פחות 1, אז מה עשיתי?

220
01:28:56,580 --> 01:29:26,500
אני נכנסתי לביטוי של t של n פחות 1 פנימה, t של n פחות 1, תסתכלו על זה, אם פה היה כתוב כאן, תסתכלו כאן, t של n פחות 1, אז פה היה כתוב לי t של n פחות 2 ועוד t של n פחות 3, זאת אומרת t של n פחות 1 קטן מ-2 כפול t של n פחות 2, נחש מה כתוב פה? בדיוק, ה-2 כפול t של n פחות 2.

221
01:29:26,500 --> 01:29:56,500
זה הקטן מי. אני פשוט פרסתי את הביטוי בפנים, הרחבתי אותו לפי מה שעשיתי בשורה הראשונה. הפעולה שאני עשיתי בשורה הראשונה, להגיד שהסכום הזה קטן מי, איזושהי גרסה יותר גדולה, עשיתי את אותו הדבר לעומק עבור העיןים היותר קטנים, עבור העין פחות 1, עבור העין פחות 2, מצאתי אפילו ביטוי כללי לזה, והלכנו עד לסוף הטבעי. עד לאן?

222
01:29:56,500 --> 01:30:25,620
N פחות N. האם עכשיו יש שאלות? אה, תסתכל, תגדיל את I, I מ-0, I שווה 0, זה המקרה התחלה. I שווה 1, זה כבר זה, כן? זה כבר N פחות 1. N פחות I בפנים, אתה רואה? תגדיל את I עוד ועוד ועוד ועוד ועוד, עד שיהיה לך פה N פחות N. T של 0 זהו של 1, ברור.

223
01:30:25,620 --> 01:30:55,620
"צלם כמו יו"ל, זה לא ייוורקצצ"ל או... -מה? "צלם כמו יו"ל, דברקצוצץ". אין בעיות, אתם יודעים משהו? זה בסדר גמור, גם אם זה n פחות אחד, זה בסדר. אנחנו מדברים פה על סדר גודל. אנחנו עדיין נגיע לבערך 2 בחזקת n. וזה בסדר. למה? שוב, גדול מהזמן שלנו, אנחנו רק מחפשים סדר גודל. "צלמת הלקטור" אז למה אתה צריך להוציא את הקטור שלנו דברים? איפה? אה, לא, זה סתם, זה רק כדי להגיד לך, אנחנו הגענו עד לריקי,

224
01:30:55,620 --> 01:31:25,620
קריאה רקורסיבית הכי תחתית שיש ועדיין יש לך את העיף הזה. אני כתבתי את האו שלך, לא רק כדי להזכיר לנו שהי Here עדיין רצים פה דברים זה סתם. אתה יכול להעיף את זה אם בא לך. בסדר? העיקר שהבנתם את הפריסה הזאת של ה-n-Autonomy של  כל הסיפור הזה של הקטן מי קטן מי. למה הראתי לכם את זה? כי במבנה נתונים אתם תראו את זה בתור אחת מהשיטות לחשב סיבוכיות של דברים מסובכים. זאת דוגמה קלאסית לאיפה זה מתחיל:

225
01:31:26,600 --> 01:31:56,600
אוקיי, כן חריגה רצינית, אוקיי, רגע שנייה, חכו שניה, חכו שניה, אני יודע שאני מהבא אתכם, אוקיי, תקשיבו שניה, תקשיבו שניה, אני כנראה אדלג אתכם בצורה אלגנטית על המעבר הקצר של חיפוש בינארי, אם אתם רוצים אותו, יש אותו בהקלטה מראש, פשוט כי עכשיו אנחנו לא מספיק, לפני זה אני רק רוצה, רגע, חכו שניה, אני רק רוצה לסיים אתכם עוד דבר וחצי אחד אחרונים ואז נעלה למעלה, שניה...

226
01:31:56,600 --> 01:32:26,500
כרגע דיברנו על סיבוכיות הזמן של הפיבונאצ'י, אל תלכו לאיבוד, רגע, זה היה סיבוכיות זמן, עכשיו אתגר לא פשוט, מה סיבוכיות המקום של הדבר הזה? כן, זה לא פשוט, או של אחד זה לא. עכשיו, אז עכשיו אני רוצה, אז זהו, אז חכו שניה.

227
01:32:26,500 --> 01:32:56,500
אז חכו שנייה, אני רוצה להראות לכם. אבל אם אתה מתכבש ב-Dictionary למשל ואתה מחשב שאתה אומר  את זה .. לא, אני רוצה להראות לכם את זה, לא, חכו לרגע ממושים מתקדמים, אני רוצה להראות לכם תמונה אחת שתסביר לנו את זה, פשוט תמונה אחת שתגיד הכל. אוקיי, אל תלכו לאיבוד, אני יודע שאנחנו חורגים מהפסקה וזה באמת שזה בשבילכם, אנחנו עושים את זה עכשיו כדי שאחר כך בהקלטה תשלימו רק את החיפוש הבינארי, אוקיי.

228
01:32:56,500 --> 01:33:26,500
ריכוז, הנה דוגמה ויזואלית לקריאות הרקורסיביות של פיבונאצ'י, נניח עבור פיב ארבע, תראו איך הקריאות האלה עובדות. ואני מזכיר לכם, פייתון יריס את הדברים בצורה סדרתית, הקוד שכתוב פה, הקוד שאתם רואים כאן, תראו את זה, נניח שאתם נכנסים לפיב של ארבע, "בודקים תעיף", לא מתקיים, אין בעיות, מתחילים להריץ את פקודת ריכוז. ולא יכולים להריץ את פיפ של ארבע, כי עם חברה עשרה הוא לא יהיה חברה. זה חשובף. יצרי צריך להגיד שהם חושבים

229
01:33:26,500 --> 01:33:52,520
אבל הריטרן צריכה לחשב אז, יש לכם פה פיב של m פחות 1 ועוד פיב של m פחות 2. הנה החלק הקריטי, כשאתם נכנסים לפיב של m פחות 1, אתם צריכים לסיים את כל העץ הרקורסיבי הזה, לפני שבכלל תגיעו להריץ את הפיב של m פחות 2 פה, איך זה מתורגם ויזואלית, תסתכלו.

230
01:33:53,140 --> 01:34:23,140
"פי" בארבע, יצטרך לקרוא לפי בשלוש ולפי בשתיים, אבל הקריאה היא, החלק השמאלי של הביטוי ואז לחלק הימני. שוב, אתם רואים? "פי" בין פחות אחד ועוד "פי" בין פחות שתיים? קודם אתם קוראים לזה, וזה צריך להסתיים, לפני שזה בכלל יכול להתחיל לרוץ. כי זה סדרתית, עובד. לא מקבילי, אנחנו לא מדברים פה על תכנות מקבילי, לא הגענו לדברים האלה. סדרתי, דבר אחד חייב להסתיים לפני שאתם מריצים...

231
01:34:23,140 --> 01:34:53,140
את הפקודה הבאה בתור, תת פקודה מבחינתכם, אז ויזואלית איך זה נראה, פיב 4 יקרא קודם לפיב 3, שיקרא קודם לפיב 2, שיקרא קודם לפיב 1 ורק אז הפיב 1 הזה יתקפל, אבל שימו לב, 4, 3, 2, 1. כמה קריאות רקורסיביות פתוחות לנו הכי הרבה ברגע נתון? 4, כלומר O של מה? O של N. ועכשיו, למה O של N? בגלל רע Food Systems,

232
01:34:53,140 --> 01:35:23,140
זה באמת המקסימום, וזה בחיים לא יהיה יותר גדול מזה, ברקורסיה הזאת. כי תראו, Fib 1 התקפל, כי פגנו כבר 1, עכשיו פותחת Fib 0. אוקיי, אנחנו הגענו שוב למקסימום, אותו מקסימום, כי אנחנו מדברים על כמה מקום בזיכרון תופסים במקביל. זה, ואז F0 מתקפל, F2 הזה יתקפל, ורק אז F3 הזה יקרא ל-F1, יתקפל, F3 יתקפל, ורק אז נפתח Fib 2. אמור  כן זרג בידיים  ודגירה רק: אין לי איזה חום? אין לי כלום על הרצון ואין לי כלום מדי

233
01:35:23,140 --> 01:35:28,120
‫היי, כשפתחנו פה את פיפ 2, ‫זאת רק קריאה אקרוסיבית שנייה שפתוחה.

234
01:35:28,940 --> 01:35:40,820
‫חזרה אחורה, מה זה אומר? ‫הקריאה הזאת, רצף הקריאות הראשון מתוך 2, ‫אחד אחרי השני, אחרי השלישי הקרבי, זה העומק המקסימלי.

235
01:35:41,120 --> 01:35:47,000
‫ובחיים הסיבוכיות מקום לא תהיה יותר גדולה מזה, עבור הפונקציה הזאת. ‫האם הבנתם?

236
01:35:48,480 --> 01:35:53,720
‫אה... בואו נראה רגע שניהם, ‫יש טעם להמשיך. פונקציה 11.

237
01:35:55,520 --> 01:36:07,140
‫טוב, לצערי, לא, לא, לצערי, ‫אני צריך לבקש מכם שמי תרגיל 11 והלאה, ‫בבקשה תשלימו מהקלטה מראש, ‫סיימתי להקליט אותה ב-4 לפנות בוקר, ‫אתם תסתדרו, אני מעריך.

238
01:36:09,420 --> 01:36:18,020
‫יאללה, תעלו ל-110. ‫בהקלטה מראש יש את מה שאתם מחפשים, ‫מי שבזום, אני אפתח שוב את הנוכחות ‫בתקלאת המעבדה עוד כמה דקות.

239
01:36:18,020 --> 01:36:18,520
ביי.

