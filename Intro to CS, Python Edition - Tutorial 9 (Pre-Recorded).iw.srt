1
00:00:00,000 --> 00:00:22,080
היי, ברוכים הבאים לתרגול התשיעי של הקורס מבוא למדעי המחשב. נושאי התרגול היום יהיו מיונים, מילון וגם רשומה, או לפחות דרכים מסוימות לממש את זה בפייתון, זה נושא שהוא קצת פחות סגור. טוב, בואו נתחיל. מיונים, מה ולמה?

2
00:00:22,080 --> 00:00:44,380
הגרסה הקצרה היא, בעולם מדעי המחשב, אנחנו עובדים הרבה פעמים עם נתונים, מבני נתונים מסוימים, רשימות, מערכים, רב-ממדיים, מה שזה לא יהיה. ובחלק מהמקרים, זה די חשוב לנו,אפילו קריטי, שהם יהיו ממויינים בסדר מסוים.

3
00:00:44,380 --> 00:01:00,380
אז גם אם אתם לא בטוחים למה אנחנו רוצים או בכלל צריכים למיין רשימות מערכים, פשוט תסמכו על זה שאנחנו נצטרך את זה בשביל לפתור בעיות יותר מורכבות שיבוא בעתיד.

4
00:01:00,380 --> 00:01:14,140
אז בינתיים נתחיל לחשוב על מיונים, מהקטן הגדול, מהצורה הכי פשוטה שיש. בואו נראה דוגמה יחסית אינטואיטיבית לצורת מיון מסוימת שנקראת...

5
00:01:14,140 --> 00:01:44,140
מיון בריאות. איך היא עובדת? נניח שיש לנו איזושהי רשימה. הנה אני אפילו אראה לכם דוגמה לרשימה קטנה: 4 איברים. 5 6 1 3, מה נעשה? נתחיל מלהסתכל על הזוג הראשון של האיברים ברשימה. ואנחנו אומרים כזה דבר: אם האיבר הראשון הוא גדול יותר מהשני, אז פשוט נחליף ביניהם. במקרה של הרשימה הזאת כאן זה לא המצב, אין.

6
00:01:44,140 --> 00:02:14,140
בין בעיות? אז לא נעשה כלום. עכשיו, נעבור להסתכל על זוג האיברים הבא בתור. לא שלישי רביעי, אלא שני שלישי. זאת אומרת, אנחנו הסתכלנו על הזוג הזה, של ראשון שני, ואז עשינו מעבר אחד ימינה, לזוג שני שלישי. עכשיו, נשאלת אותו דבר. האם הראשון שבזוג גדול יותר מהשני שבזוג? התשובה היא כן, שיש גדול יותר מאחד. אז מה?

7
00:02:14,140 --> 00:02:44,140
מה נעשה? נחליף ביניהם. פשוט נעשה את ההחלפה הזאת שאתם רואים כרגע. עכשיו יש לנו חמש, אחד, שש, שלוש. אוקיי, סיימנו לטפל בזוג הזה, נעבור לזוג הבא בתור. זוג שש, שלוש? וואלה! שש גדול משלוש, נחליף ביניהם. עכשיו, הגענו למצב שבו, אנחנו סיימנו לעשות מעבר אחד שלם על הרשימה,

8
00:02:44,140 --> 00:03:13,080
הופה, וקיבלנו שהערך הגדול ביותר ברשימה עבר לסוף שלה. ואם אתם חושבים על זה, זה גם הגיוני, כי בכך שעשינו מעבר על כל זוג אפשרי של הרשימה, תמיד מי שהיה הגדול מבין הזוג, תמיד וידענו שהוא נמצא בקצה הימני של הזוג, בקצה הרחוק. תמיד עשינו את ההחלפה הזאת, אם היה צריך.

9
00:03:14,000 --> 00:03:44,000
מה זה נותן לנו? אוקיי, אפשר להגיד שמי היה נותן הכי גדול  עד לסוף, עדיין יש לנו את שאר הרשימה. אז, עכשיו אנחנו נתחיל לעשות בדיוק את אותו הדבר שוב, מהתחלה, כל פעם נמיין זוגות, זאת אומרת, פשוט נעשה את הסוואפים הכרחיים, כל זוג בהתאם, אז נניח פה, בהתחלה, יש עכשיו חמש שבא לפני אחד ,טוב, זה לא טוב, אז, אני עכשיו מחליף

10
00:03:44,000 --> 00:04:13,520
ביניהם, אני אביא להסתכל על זוג הבא בתור, חמש לפני שלוש, זה לא טוב, אני אמיין אותם, שלוש לפני חמש, וזהו, בעצם סיימתי למאיין את הרשימה, ואני יכול להגיד לכם כבר עכשיו שהתהליך שאנחנו נעשה הוא אפילו יותר כללי, זאת אומרת, אנחנו נעשה, תחשבו על זה כמו O של N איטרציות בערך, אנחנו נעשה O של N איטרציות,

11
00:04:13,520 --> 00:04:42,920
O של N לולאה חיצונית, שאומרת, עבור כל איבר ברשימה, אבל מלמעלה למטה, אנחנו בעצם נעשה לולאה פנימית, שכל התפקיד שלה יהיה לוודא שהאיבר הגדול ביותר ברשימה יעבור עד לסוף, ואז כאילו לולאה חיצונית היא תקטן באחד, ואז אנחנו נעשה עוד פעם את המיון בועות הזאת מהתחלה עד הסוף, אבל הפעם הסוף יהיה,

12
00:04:43,880 --> 00:05:13,880
איבר לפני הסוף. ואחרי זה, אנחנו נעשה אות פעם מיונבוט, והפעם זה יהיה האיבר אחד לפני לפני הסוף. ככה עד שאנחנו נגיע למצב שבו, הגענו לאיבר הראשון, והוא בעצמו, נמצא כבר במקום. כאילו מה שאני מנסה להגיד, זה תהליך שבו אנחנו בעצם ממיינים מהגדול לקטן מימין לשמאל. זאת אומרת, אנחנו תמיד מבדאים שהאיבר הגדול ביותר

13
00:05:14,400 --> 00:05:26,680
עובר עד לסוף עשינו את זה אז מבחינתנו סוף המערך הוא done deal ואנחנו עכשיו נתעסק בשאר המערך לא כולל האיבר הסופי ונעשה בדיוק אותו תהליך.

14
00:05:27,040 --> 00:05:43,140
נפעבע את הגדול ביותר בתת מערך הזה עד לסוף וסיימנו עכשיו נעבור לתת מערך העוד יותר קטן וכן הלאה וכן הלאה עד שנסיים באיבר הראשון ממש. זאת אומרת.

15
00:05:44,040 --> 00:06:11,700
זה כאילו תהליך שהוא בסוג של O של N לולאה חיצונית על גבי O של N בלולאה פנימית. זה סיגמה כזה אם אתם רוצים לחשוב של I מינוס 1, כל פעם ה-I שלנו, אתם יכולים להגיד שהוא מתחיל ב-N ויורד עד לאחד כזה, או הנה, אני אראה לכם, תראו דוגמה למימוש פייתון שזה.

16
00:06:11,700 --> 00:06:41,680
אנחנו מגדירים את פונקציית ה-Bubble Sort שלנו עם רשימה, נגדיר N אורך הרשימה, ואז נגיד ככה, לולאה חיצונית אומרת נתחיל מ-N, זאת אומרת, אנחנו נתחיל מלהסתכל על כל הרשימה, ונקטין את זה כל פעם בצד אחד, עד שנרד בעצם לתחילת הרשימה, זה הרעיון. כל איטרציה חיצונית, תפקיד שלה להגיד, בעבנו את הערך הגדול ביותר לסוף הרשימה.

17
00:06:41,680 --> 00:07:11,680
ואז סוף הרשימה זה פשוט נהיה משהו שהוא יותר ויותר קטן. ואז הלולה הפנימית היא בעצם זאת שעושה את פעולת הבייבוע עד לסוף הרשימה המוגדר בלולה החיצונית. מה אנחנו עושים? הפעולה הכי פשוטה שיש. האם איבר נוכחי גדול מאיבר הבא בתור? אם כן, swap in place.well, אז מה הרעיון פה?אנחנו עושים סתום.אז בבקשה, נאלצנו לעשות סווט ׳אינפליסק׳.אז בעזרת הערך ההפכינון אנחנו יכולים להראות איפה נבטיח,רתמיד מאוד מהקרנים ביותר.נצוץ שאתה יכול להבין שהגד

18
00:07:11,680 --> 00:07:41,680
את זה, ממש מאינדקס 0 עד אינדקס i פחות 2 ו-i פחות 1, זה הרעיון כאילו, מחליפים בין האינדקסים האחרונים ממש, ביניהם, אם צריך, וכשסיימנו לטפל בכל הלולה החיצונית, איטרציה אחת שלמה, זאת אומרת, אתם רואים? עבור, או יותר נכון, עבור לולה הפנימית, ברגע שאנחנו מסיימים לטפל בה, אתם רואים? איתי פנימית, נראה לי שפחות אחד מפה לולה פנימית להפסס מהלולה הפנימית, והוא חייב לחזק בבינה שלנו כאיש שמתמיד לא יכול לעבוד וח

19
00:07:41,680 --> 00:07:58,400
לחלוטין, אז אנחנו יכולים לקדם את האי שלנו. או פה במקרה הספציפית הזאת, להקטין אותו. וזה בעצם הדרך שלנו להגיד, טיפלנו בסוף עלולה, סליחה, בסוף הרשימה, ועכשיו אנחנו נטפל בשאר הרשימה בלי איבר האחרון.

20
00:08:00,200 --> 00:08:05,180
אני מקווה שאתם מצליחים להבין, אולי הצורה שבה אני הסברתי קצת מוזרה.

21
00:08:05,180 --> 00:08:12,700
בסך הכול תחשבו על זה, אנחנו ממיינים תתי רשימות הולכות וקטנות.

22
00:08:12,700 --> 00:08:21,280
מה זה המיון שלנו? זה בסך הכול להעיף את האיבר הגדול ביותר, לקצה של תת הרשימה שבה אנחנו נמצאים.

23
00:08:21,280 --> 00:08:29,340
ברגע שסיימנו את זה, אנחנו סיימנו את כל עלולה פנימית פעם אחת, לא פעם אחת, סליחה, סיימנו את כל עלולה פנימית,

24
00:08:29,340 --> 00:08:50,340
את ה-for הזה לחלוטין, ואז אנחנו הולכים להסתכל בלולה החיצונית על האיטרציה הבאה בתור, שהיא פשוט להסתכל על תת רשימה קטנה יותר, כי אנחנו עכשיו עוצרים באיבר קודם יותר, יותר רחוק מהסוף. זה הרעיון.

25
00:08:50,340 --> 00:09:20,220
אני מקווה שהצלחתם להבין את הרעיון של מיון בוט, זה פלוס מינוס הרעיון. אז כאילו, זו דרך שהיא בערך אינטואיטיבית, כי אתם פשוט חושבים לעצמכם שאתם עוברים על כל זוג של איברים ברשימה, עושים סוואפים, שזה יחסית פשוט, עשיתם את זה, העברתם את האיבר הגדול ביותר לסוף, ואתם אומרים, אחלה, טיפלנו בסוף, בואו נעשה את זה שוב, כדי להעביר את האיבר השני הכי גדול למקום השני לפני הסוף.

26
00:09:20,220 --> 00:09:50,220
ואז זה איבר שלישי הכי גדול למקום השלישי לפני הסוף וכן הלאה וכן הלאה עד שאנחנו מסיימים התחילה של לולה. בקיצור זה המצב של לולה בתוך לולה, מצב שבו הגענו בעצם לאושלנד בריבו. עכשיו זו דרך אחת למיין לא בדיוק דרך מיטבית לא בדיוק דרך יעילה. יש דרך אחרת שהיא קצת יותר טובה. אנחנו ניקה לה במרכז

27
00:09:50,220 --> 00:10:20,220
דרך האידיאלית אבל הכוונה היא זה פשוט הדרך שיש לה את הסיבוכיות זמן שהיא הכי טובה שאנחנו מכירים אם אין לנו איזשהו ידע מוקדם או איזה שהם עזרים מיוחדים. מה הכוונה! עלגוריתם מיון בסיבוכיות של n כפול log n. במקרה שלנו נראה את מיון מיוז. set proposition=(1,2,3)נוכל להענק את מיון מיוז.

28
00:10:20,220 --> 00:10:50,220
מה אנחנו נעשה פה? תהליך די פשוט, ניקח רשימה, נניח, נסתכל על הרשימה הזאת, פשוט נחלק אותה לשני חצאים, כל חצי בנפרד. מה הרעיון? יש לנו פה אלגוריתם שהוא רקורסיבית, לוקח רשימה, מחלק אותה לשני חצאים, ממיין בעצם כל חצי בנפרד, ואחרי שכל חצי בנפרד מוים,

29
00:10:50,220 --> 00:11:20,220
ממזג את שני החצאים האלה לרשימה אחת גדולה. הרעיון הוא שהריקורסיה הזאת ממשיכה, כל חצי בעצמו מתפצל לחצאים עד שנגיע לתנאי הצ see-rar שזה יהיה רשימה שהיא בגודל אחד. ואז פשוט אם יש איבר יחיד אז הוא ממוין בצורה טריוויאלית. אתם אומרים אוקיי אז איפה החלק שבו אנחנו ממזגים, זה מיון מיזוג, אז אכן

30
00:11:20,220 --> 00:11:50,220
אנחנו נצטרך לממש אלגוריתם מזוג, שמה שהוא עושה, הוא מקבל בעצמו שתי רשימות ממויינות, הוא פשוט ממזג אותן לרשימה אחת ממויינת.אתו..אז תסתכלו לרגע על האלגוריתם הכללי.נניח אנחנו רוצים לכתוב תוכנה, נקרא לה multSoort, היא תקבלת רשימה.נגדיר את אורך הרשימה, אם האורך הוא 1, זאת אומרת אם הגענו לתנאי הצירה, פשוט נחזיר את הרשימה איכשהי, כי היא ממויינת.אם לא, נפתח עם...אלגוריתם מזוג, ו..ילד Invest קבל מיוון אי-ט

31
00:11:50,220 --> 00:12:20,220
נעשה את הקריאה הרקורסיבית, נפצל לתת רשימה שמאלית ותת רשימה ימנית. אז אתם ay שתת הרשימה השמאלית פה ספציפית היא פשוט כזה סלייס של הרשימה המקורית אבל שנגמר באמצע. והתת רשימה הימנית הוא סלייס שמתחיל באמצע ונגמר בסוף. ואז קריאה רקורסיבית. אתם מסתכלים על הקוד הזה. וברור לכם שהקסם במרכאות נמצא בפונקציית המרג'

32
00:12:20,220 --> 00:12:26,000
היא זאת שלוקחת שתי תתי רשימות כאלה וממזגת אותן לרשימה אחת.

33
00:12:27,220 --> 00:12:34,540
אגב, אם אתם רוצים לדעת איך מגדירים את הסיבוכיות של הדבר הזה, סיבוכיות הזמן, אתם יכולים ממש לראות את זה פה.

34
00:12:34,940 --> 00:12:49,080
נגדיר שפונקציית הסיבוכיות זמן שלנו, t של n כאן, היא תהיה בעצם פעמיים, t של חצי n, ברור לכם למה, כי אנחנו שולחים בקריאה הרקורסיבית,

35
00:12:49,260 --> 00:13:12,260
שתי קריאות רקורסיביות, את שני החצאים, ועוד פעולת המרג' שהיא תיקח o של n, למה? כי אנחנו שולחים למרג', n חצי רשימה, n חצי רשימה, ואנחנו עושים שמה טרוורס אחד על פני שתי הרשימות האלה, כדי לבנות את הרשימה הממוזגת.

36
00:13:12,760 --> 00:13:17,260
אז כל פעולת המרג' היא לחלוטין לחלוטין o של n.

37
00:13:17,960 --> 00:13:47,860
עכשיו אם אתם רוצים במקרה לדעת איך זה נראה, יש לי כאן בקוד שמתלווה לתרגול, דרך אגב, עוד לפני כן, יש כאן קוד שמראה דוגמת הרצאה לבאבל סורט, אז רק שתראו שהבאבל סורט עובד, אני יכול להריץ כאן את התא האינטראקטיבי הזה, הנה, ככה ייצרתי רשימה אקראית, לקחתי ליסט בין 1 ל-10, עשיתי לו שפל,

38
00:13:47,860 --> 00:14:17,860
הראיתי אותה לא ממויינת ואז קראתי לפונקציית ה-Bubble Sort ועכשיו היא ממויינת. אוקיי אבל זה לא מה שאנחנו רצינו להסתכל עכשיו רצינו להסתכל על Merge Sort כי בכל זאת איך המרג' עובד? אז גם אם ראיתם את זה בהרצאה בואו תראו את זה שוב עכשיו אז קודם כל הנה פונקציית המרג' סורט כפי שראיתם אותה עכשיו בשקופית והנה פונקציית מרג' ככה אתם ממש יכולים לממש את פונקציית המרג' בצורך

39
00:14:17,860 --> 00:14:47,860
מה קורה פה? אתם מקבלים שתי רשימות ואתם הולכים לבנות את הרשימה הסופית, אז נגדיר רשימה ריקה. נגדיר אינדקסים רצים עבור הרשימה הראשונה והשניה, נתחיל אותם באפס. ואז נעשה וייל פשוט. הנה מה שהוויל אומר.הוויל אומר, כל עוד שהאינדקס הרץ על הרשימה הראשונה עוד לא הגיע לסוף, ל-length של הליסט, ואותו דבר יקרה.

40
00:14:47,860 --> 00:14:51,540
‫אם האינדקס הרץ של רשימה שנייה. ‫עוד לא הגענו לסוף.

41
00:14:52,000 --> 00:14:58,040
‫אז כל עוד שאנחנו עדיין עוברים ‫על פני שתי הרשימות שקיבלנו, מה נעשה? ‫נשאלת השאלה.

42
00:14:58,600 --> 00:15:05,040
‫האם האיבר הנוכחי ברשימה הראשונה ‫קטן מהאיבר הנוכחי ברשימה השנייה?

43
00:15:05,800 --> 00:15:17,400
‫אם כן, נוסיף את האיבר הנוכחי ‫מהרשימה הראשונה, זה שקטן יותר, ‫אל הרשימה הממוזגת, על ידי פקודת הפנד,

44
00:15:17,900 --> 00:15:24,340
‫ונקדם באחד את האינדקס הרץ של הרשימה הראשונה, ‫כדי לעבור להסתכל לאיבר הבא שלו.

45
00:15:25,740 --> 00:15:33,140
‫אנחנו נגיד באלס, אם זה לא קרה, ‫זאת אומרת, האיבר הנוכחי של ליסט 1 הוא גדול שווה,

46
00:15:34,100 --> 00:15:46,260
‫אז מבחינתנו, נוסיף דווקא את האיבר מהרשימה השנייה, ‫כאן ועכשיו, לרשימה הממוזגת, ‫ונקדם לו את האינדקס. מה המוטיבציה?

47
00:15:46,940 --> 00:16:03,340
‫המוטיבציה היא שאנחנו נעשה מעבר, ‫על פני שתי הרשימות, ונוודא שכל פעם שאנחנו מסתכלים על זוג איברים, מתאימים בשתי הרשימות האלה, ואני מזכיר לכם, ליסט 1 וליסט 2 הן ממוזגות בעצמן.

48
00:16:03,740 --> 00:16:33,700
‫מרג' ממזג שתי רשימות קטנות יותר, שהן ממויינות. ‫אז אנחנו עושים את המעבר הזה על פני שתי רשימות ממויינות, ומתי הווייל הזה ייגמר לדעתכם? ‫התשובה היא, הווייל הזה ייגמר כשסיימנו לעשות אפנד, מאחת משתי הרשימות. ‫זאת אומרת, הווייל הזה נגמר כשסיימנו את הטרברס שלנו על פני אחת משתי הרשימות.

49
00:16:33,700 --> 00:17:03,700
זאת אומרת, אחת מהרשימות האלה גמורות. אבל אז מה נשאר לנו? יכול להיות 몸נו שישאר לנו הצורך להוסיף את שאר האיברים מהרשימה האחרת, שכנראה שהם כולם גדולים יותר, מי שנשארו, וזה למה לא הוספנו אותם בווייל. אז הנה הפקודה שמסיימת את הmerge, מה היא אומרת? אגב אתם זוכרים שפלוס שווה שומר על ה-ID? un week@aillessons premium-10232116

50
00:17:03,700 --> 00:17:33,700
לא משנה, מה אנחנו נעשה? אנחנו נגיד מרג'ליסט תישארי את עצמך ונוסיף לך בנוסף בסוף שלך את מה שנשאר מליסט 1 ואת מה שנשאר מליסט 2. אתם רואים למה? לפי איך הסלייס עובד? הסלייס שלנו אומר, אומר נוסיף לקצה של מרג'ליסט

51
00:17:33,700 --> 00:18:03,700
את ליסט 1 סלייס שמתחיל, מאיפה שהאינדקס הרץ שלו עצר, וגם אותו דבר בליסט 2. אז אם אחת מהרשימות האלה נגמרו, זה כאילו להגיד להוסיף סלייס רק, והרשימה שעוד לא נגמרה, זה באמת מוסיף לה את השאר. ולבסוף, אתם מבינים משהו, גם אם הפלוס שווה הזה לא היה מחזיר את אותו אובייקט, זה בסדר. כי בכל מקרה, אנחנו מחזירים אותו בצורך רשימה שאין אספקו, ומעשה, על מחר 4,hardware 4, ורמרן 8, אעברנו את 1 הנבחרת, והאספקטזור הזה, ולא צריכים להע

52
00:18:03,700 --> 00:18:31,300
ריטרן מרג'ליסט, אז ככה יש לנו רשימה, ובואו נעשה עכשיו סנטי צ'ק קטן, בואו נראה, נגיד אני עושה LST שווה 1, 2, 3, בואו נראה, ID של ליסט, תודה רבה, LST פלוס שווה 4, ID של LST, אוקיי?

53
00:18:31,300 --> 00:18:43,000
סנטי צ'ק למי ששכח את הפרט החביב הזה, פלוס שווה שמר על ה-object ID של ה-List, אבל לא משנה, זה לא קשור לחלוטין.

54
00:18:43,000 --> 00:18:55,060
בקיצור, למה אני מתעכב על המרג' הזה? כי חשוב לי שתכירו איך מיזוג של שתי רשימות ממויינות עובד ואיך הוא ממומש.

55
00:18:55,060 --> 00:19:09,920
אז פה כמובן, אני יכול להראות לכם דוגמה, אני לוקח פה רשימה, מערבב אותה, ואז מפעיל עליה את ה-merge sorted הרקורסיבי הזה, ואם עשינו את העבודה נכונה, זה אמור לעבוד לנו, אז בואו נסתכל.

56
00:19:09,920 --> 00:19:24,720
הנה ה-non-sorted list שלנו, אה, bubble sorted התכוונו, merge sorted, וופס, בואו נראה את זה שוב, הנה, לקחנו את הרשימה, מיינו אותה. נו, אפשר להגיד שעשינו את זה.

57
00:19:24,720 --> 00:19:54,540
רגע, למה הרצנו בטעות את bucket sort? הנה, אני אתקן את זה לבקט, רגע, רגע, מה שהתכוונו להגיד זה לתקן מרג' סורטד במרג' סורט, כן? אז הנה. אבל, אם כבר, אני אדבר על, bucket sort, זה באמת המיון הבא שאנחנו רוצים להכיר, מה זה bucket sort? אז תראו.

58
00:19:55,020 --> 00:20:24,500
בהינתן זה שאנחנו יודעים, מה הערך המינימלי, ומה הערך המקסימלי, שיש באיזשהו רשימה, אנחנו יכולים למיין אותה, יותר מהר, מ-n כפול הוגן. אנחנו יכולים, יכולים למעשה, לעשות את המיון שלנו, בסיבוכיות זמן של, או של n, איך זה יעבוד? בואו תראו דוגמה. אני רוצה להראות לכם את הדוגמה המספרית קודם.

59
00:20:24,500 --> 00:20:37,660
אז תסתכלו, נניח שנתנו לנו כזאת רשימה, רשימה שיש בה 1, או יותר נכון, 5, 1, 2, 3, 1, 4, 3.

60
00:20:37,660 --> 00:20:54,460
אתם מצליחים לזהות מכאן ערך מינימלי, ואיך מקסימלי? מה זה אומר? אני יכול עכשיו לבנות מראה חדש, או רשימה, איך שתרצו לקרוא לזה, ומה יהיה האורך של אותה רשימה חדשה?

61
00:20:54,460 --> 00:21:24,420
האורך יהיה מספר הערכים בין הערך המינימלי שהופיע ברשימה שאני רוצה למיין, ובין הערך המקסימלי. פה הופיעו לי בדיוק 5 הערכים, 1 המינימום, 5 המקסימום, אז זאת אומרת אני הולך לבנות רשימה שהאיבר הראשון שלה יייצג את הערך הנמוך ביותר, והערך האחרון שלה יייצג את האיבר הגדול ביותר. עכשיו מה אני יכול לעשות?

62
00:21:24,420 --> 00:21:38,720
עם זה? איפה הקסם? איך אני יכול למיין? אני עושה מעבר כזה על הרשימה המקורית, פה מגיע ה-O של N, בסדר? שתדעו, הבנייה הזאת היא אפילו לא הייתה

63
00:21:38,720 --> 00:21:53,600
O של N, כי אתם רואים שזה קצר יותר מהרשימה המקורית, זה מה שנחשב בשבילנו O של 1, כי זה נקבע לפי MAX value וה-MEAN value שברשימה המקורית, אם זה נתון לנו.

64
00:21:53,600 --> 00:22:22,800
אם אנחנו יכולים לחשב את זה, אתם יודעים משהו? סליחה, זה לא חייב להיות נתון, אנחנו יכולים לעשות את זה ב-O של N פעמיים, לחשב מקסימום של ערך ומינימום של ערך מתוך רשימה, אז פעמיים O של N, אין בעיות, יש לנו MEAN ויש לנו MAX, הנה, MEAN שווה 1, MAX שווה 5, ואז זה אומר, bucket list length שווה 5.

65
00:22:23,780 --> 00:22:51,380
ואז אני יכול ממש לעשות ליסט מזה, ממש, כאילו, אני יכול לעשות, אני יכול להגיד, bucket list, bucket list נקרא לזה, שווה ליסט של ריינג' של, הנה, תראו למה אני מתקבל, כאילו, ממש, אתם מבינים את השטות הזאת, ריינג של, אתה יודע, MAX פחות MEAN ועוד 1, הנה, הנה, אני אפילו אייף את זה.

66
00:22:51,380 --> 00:23:19,320
כאילו שתבינו כמה זה פשוט, בסדר? אז חיפשנו את המינים, זה לקח אהו של אין, חיפשנו את המאקס לקח אהו של אין, בסדר? נניח שהם נתונים, וגם אנחנו יודעים שהערכים בפנים, כאילו הם לא חורגים מתוך זה, כן? זה קריטי. זה לא תמיד משהו שאפשר ליישם אותו לכל רשימה, נניח שמצאנו, נניח שיצרנו רשימה כזאת, אוקיי. עכשיו החלק הרלוונטי.

67
00:23:19,320 --> 00:23:49,320
אני מתחיל לעשות מעבר לרשימה המקורית, הנה אני אפילו העיף עם כל זה. אני מסתכל על חמש, אז מה אני הולך? אני הולך עכשיו ל-bucket list שלי. אתם יודעים משהו? אני אעשה את החיים יותר קלים, אני אעשה שה-bucket list יהיה דווקא באורך שש, אתם יודעים למה? כי אינדקס אפס יייצג את הערך אפס, אינדקס אחד יייצג את הערך אחד, עכשיו אתם רואים למה אני מתכוון? עכשיו אני אומר פשוט,

68
00:23:49,320 --> 00:24:06,740
4 נאם, in, Unsorted List, מה אני פשוט אומר? אני אומר באקט, במקום נאם, פלוס שווה 1. אתם רואים את הקסם?

69
00:24:06,740 --> 00:24:18,100
אני עושה מעבר על הרשימה הלא ממוימת, עבור כל מספר שאני מסתכל. נניח 5, אז אני ללכת לבאקט, באינדקס, שהוא שווה למספר.

70
00:24:18,100 --> 00:24:46,500
אז זה אינדקס 0, 1, 2, 3, 4, 5, פלוס שווה 1, יאללה. נקסט, איבר באינדקס 1, פלוס שווה 1, נקסט, איבר באינדקס 2, פלוס שווה 1, איבר באינדקס 3, פלוס שווה 1, איבר באינדקס 1, פלוס שווה 1, 4, אין בעיות, 1, 3, אוקיי, 2.

71
00:24:47,500 --> 00:25:03,500
מה זה נותן לי? אחרי זה, אני פשוט עכשיו אומר, סורטד ליסט, שווה, שווה למה? לאסט קומפיינשיין יעבוד?

72
00:25:03,500 --> 00:25:33,500
לא, אולי כן, אולי לא. אבל מה שאני יכול לעשות, אני פשוט אעשה מעבר כזה על הבוקט ליסט שלי. אני אגיד לכל איבר, אם הערך שלך, כאילו, לכל איבר, אני פשוט אשים,  כגודל שלך, כמספר ההופעות שלך, ברשימה הסופית. זאת אומרת, אני אבנה רשימה סופית. אני אתחיל. האם מספר 0 מופיע שם? לא, המספר 1 מופיע שם.

73
00:25:33,500 --> 00:25:49,240
פעמיים, אז אין מיסע אחד, פסיק אחד, אני אעבור לעבר הבא בתור, שתיים, מופיע פעם אחת, שלוש, מופיע פעמיים, ארבע מופיע פעם אחת, וחמש מופיע פעם אחת. כאילו, לפי זה, אנחנו נבנה את הרשימה.

74
00:25:49,240 --> 00:26:10,960
הנה, אני רוצה שתראו את הבנייה, תראו שזה לא מאוד קשה, האמת, כי אני יכול לעשות את זה בפקודה אחת. אז הנה, קודם כל תראו את הבקקט סורט שלנו, אנחנו בונים את הבקקט שלנו, את הרשימת בקקטס, אתם רואים, אנחנו ממש פה, אפילו נותנים לנו רק המקסימום, אז אנחנו מניחים שהערכים הם אי שליליים.

75
00:26:10,960 --> 00:26:34,640
אז אנחנו בונים את הבקטס שלנו, ממש תתחיל מאפס עד למקסימום ולך עד הסוף, פור אייטם אין הליסט, תוסיף אותו לבקקטס, מספר הופעות שלו, זאת אומרת, תוסיף הופעה, עוד הופעה, ואז הרשימה הממויינת, איך נבנה אותה? אנחנו נעשה מעבר על בקטס, בעזרת פונקציית אין יומרית, היא תיתן לנו שני דברים.

76
00:26:34,640 --> 00:27:04,520
האינדקס של הבקטס, זאת אומרת, האינדקס אייטם בבקטס, הוא בעצם מסמן את הערך מספר שאנחנו נרצה לשים ברשימה הממוזגת, אתם רואים? העבר הראשון זה תמיד האינדקס באין יומרית, והעבר השני זה הvalue שם, אבל ברשימת הופעות, במה שנקרא בבקטליסט, האינדקס הוא מייצג את הvalue של הoriginal list, והvalue בבקטליסט,

77
00:27:04,520 --> 00:27:34,520
מייצג את האפרנס קאונטר, זה בעצם אפרנס ליסט אם זה משהו שהוא מוכר לכם מדרגול קודם שניסיתי להעביר לכם, זה בעצם הרעיון. אז תביאו פקודה נחמדה ברשימות שיש בפייתון, אנחנו נגיד,הליסט שאנחנו בונים, תעשה לו אקסטנט, אקסטנט זה כאילו דרך בעצם לעשות משהו שהוא כמו אפנד ( systemic ) אבל ליותר מערך אחד, תראו מה אנחנו עושים, ליסט אקסטנט. ( ליש מערך אחד )

78
00:27:34,520 --> 00:27:53,300
עם מה? קאונט פעמים איברים, קאונט פעמים רשימה עם ערך יחיד NAV. וכך אנחנו בעצם עושים מספר פעמים תוספת של האיברים המתאימים מליסט, במקום מתאים שלהם.

79
00:27:54,500 --> 00:28:24,460
אז הנה אני עכשיו רוצה באמת גם להראות לכם את זה בקוד פייתון אמיתי, אז הנה תסתכלו כאן, יש לנו את פונקציית ה-Bucket Sort שלנו, אז פה בניית ה-Bucket List, פה בניית ה-Sorted List על ידי פקודת האקסטנד של רשימה, והנה כאן אנחנו מגדירים רשימה, מערבבים אותה בעזרת שאפל שמגיע מרנדום, ומריצים על זה Bucket Sort, שולחים רק את הליסט ואת המקסימום של הליסט.

80
00:28:24,460 --> 00:28:53,880
אז הנה, אתם יכולים, עכשיו נריץ את זה, ואתם יכולים לראות בעבור עצמכם, זה עובד. עכשיו שימו לב שזה יכול להישבר למעשה, המימוש שכתבנו פה, יש לי תחושה שהוא עלול להישבר, אם נעשה ליסט שמכיל ערך שלילי, סתם דוגמה, אם אני משנה פה למינוס ארבע, עכשיו אני מנסה להריץ את זה, אז...

81
00:28:53,880 --> 00:29:03,120
אתם רואים שקצת שברנו את זה? למעשה, תסתכלו מה קרה תסתכלו מה קרה עכשיו שבע מופיע פה פעמיים.

82
00:29:03,120 --> 00:29:11,420
זה קצת מרגיש כמו מינוס ארבע זה מרגיש כמו העבר הרביעי מהסוף נכון? אז כן שברנו קצת את המימוש, אז שימו לב.

83
00:29:11,420 --> 00:29:31,400
שימו לב, bucket list, bucket sorting, יותר נכון, עובד, יש לכם ערכים קצת יותר טריוויאליים ואתם יודעים מה המקסימום. אוקיי, זה היה bucket sorting. טוב, אז בואו נתרגל טיפה, דברים שקשורים במיונים.

84
00:29:31,400 --> 00:30:01,380
מבקשים איתנו לכתוב פונקציה שהיא מקבלת רשימה של מחוזות והיא ממעטת את הרשימה הזאת לפי אורך המחוזות. זאת אומרת, המחוזת הקצרה ביותר תהיה בהתחלה, הארוכה ביותר תהיה בסוף. לי זה נשמע פה כמו פשוט רשימה, ואני אתייחס לא לערכים של הרשימה, אלא ל-length של הערכים ברשימה.

85
00:30:01,380 --> 00:30:30,800
ולפי זה אני אמיין, אם ככה, אני נניח שאני לא יודע מה טווח הערכים, נניח שאין לנו מושג, אז הדבר הבא בתור, הכי טוב, זה לעשות סורטינג, שבו אני לא יודע כלום על הרשימה. כלומר, מיון בסיבוכיות אין לו גן, מרג' סורט, אז מה שאני יכול לעשות, זה וריאציה על מרג' סורט, שתעשה לי את זה.

86
00:30:30,800 --> 00:30:59,960
לפי אורכי המחוזות. זה מה שנניח הייתי רוצה לעשות. אבל דווקא את הפתרון הזה אני לא אראה לכם, מקסימום תפתרו את זה ככה בעצמכם. אני אראה לכם פה דווקא פתרון בצורה הפחות יעילה, לשנות את ה-Bubble Sort. אז הנה כאן אתם רואים שינוי מאוד מאוד קטן על הקוד של Bubble Sort. מה שינינו בסך הכל?

87
00:30:59,960 --> 00:31:29,140
במקום להשוות את ה-Value של העבר ה-J וה-J פלוס אחד ברשימה, אני פשוט משווה את ה-Length שלהם. זה הכל. כל השאר זה pure Bubble Sort. והנה, יש לי פה אפילו קוד להראות לכם את זה בתור דוגמה, אז תסתכלו על ה-Bubble Sort המודיפייד הזה כאן. ואיך אני בודק את זה? אני מגדיר פה איזשהו מחוזת שהיא פשוט משפט.

88
00:31:29,140 --> 00:31:58,560
This sentence will be separated into its words, and a list of strings is going to get sorted. אז מה אני עושה? קודם כל אני מדפיס לכם את זה על המסך שתראו את זה. אז אני נעזר בפונקציית ספליט, שהיא עובדת על סטרינגים, ומה שהיא עושה? היא עושה בדיוק מה שאתם חושבים שהיא תעשה. היא תפצל את המחוזת הזאת לרשימה של כל התתי סטרינגים שמופרדים על ידי רווח.

89
00:31:59,380 --> 00:32:13,640
ואז כמובן זה לא ממויין, אני אפילו עושה איזה שאף אל כדי ממש להחביד על זה, ואז אני שולח את זה לפונקציה צורט סטרינגס. אז הינה, נריץ את הסל הזה ותראו עבור עצמכם.

90
00:32:13,640 --> 00:32:41,400
This sentence will be separated, בלה בלה בלה, הנה הגרסה הלא ממויינת, אז אתם רואים את המילים בצורה לא ממויינת לפי אורך שלהם, ואז אחרי המיון אתם רואים פתאום מילה של אות אחת, מילה של שתי אותיות, שתי אותיות, שתי אותיות, אחר כך שלוש אותיות, ארבע אותיות, וכן הלאה וכן הלאה, עד המילה ספרייטד הכי ארוכה. נו, הייתי אומר שזה עובד, לא? חביב, חביב.

91
00:32:41,400 --> 00:33:11,160
אתם יכולתם אגב לממש את זה בעזרת מרד סורט. אוקיי, בואו נסתכל על תרגיל הבא בתור. מבקשים מאיתנו לכתוב פונקציה שהיא מקבלת שתי רשימות שהן כבר ממויינות, והפונקציה רק בודקת אם הרשימות האלה זרות, זאת אומרת שאין להן שום מעיוור משותף. אז סתם דוגמה, רשימה של 1-2 ורשימה של 3-4 ממויינות, וזרות.

92
00:33:11,160 --> 00:33:40,220
וזרות? מצד שני? 1, 2 ו-2, 3 לא זרות. ומה דורשים מאיתנו? סיבוכיות זמן של O של M פלוס M. כלומר, דורשים מאיתנו שהפונקציה שאתם תבנו, היא ייקח לה רק, נכון ליותר, טרברס על הרשימה האחת, וטרברס על הרשימה השנייה. כלומר, אל תפעילו עכשיו.

93
00:33:40,220 --> 00:33:57,860
מיון של n לוג n, אלא אומרים לכם, תעברו מספר קבוע של פעמים על פני רשימה אחת, ומספר קבוע של פעמים על פני הרשימה השנייה, במילים אחרות, תעשו פעולה שהיא ליניארית בלבד על פני הרשימות.

94
00:33:59,940 --> 00:34:29,900
אם הצלחתם לזכור משהו מאיך שהראיתי לכם את המימוש של פונקציית המרג', אתם תקלטו שבעצם מה שאנחנו רוצים לעשות כאן הוא קצת דומה לפונקציית מרג'. אנחנו נרצה לעבור על פני שתי הרשימות, עם אינדקס רץ בשתיהן, ובסך הכל אנחנו נגיד, היי, יש פאול, אם לא יוצא שאיבר אחד קטן מאיבר אחר, אלא יוצא שאיבר אחד מרשימה אחת.

95
00:34:29,900 --> 00:34:59,900
שווה ממש לייבר אחר מרשימה אחרת. אז מה שאנחנו בעצם נעשה, אנחנו ניקח את המימוש של המרג' ונוסיף אלס, zאת אומרת,ידיוק כמו שראיתם, אבל יהיה לנו את הif שאומר עם יבר אחד קטן מיבר שני, יהיה לנו lcf שאומר עם יבר אחד גדול מיבר שני, אבל אם לא זה ולא זה, אז האלס שנשמע, יסכים עם יבר אחד קטן מיבר שני, יקר איתו לגמרי חברה, שחשוב לעצור בלטון מסדריך של לוח של חברה, אסף להנחית מלחינה.455

96
00:34:59,900 --> 00:35:29,900
שאר אומר, אם איבר הנוכחי ברשימה אחת שווה ממש לאיבר הנוכחי ברשימה שנייה, אז נחזיר false, אלה לא רשימות שהן זרות. וזהו. זאת אומרת, אתם ממש יכולים לראות את זה ברמה של הקוד. תסתכלו, הנה פונקציית discount of lists, תסתכלו עליה, יכול להיות שהיא ממש דומה לפונקציית מרג'?

97
00:35:29,900 --> 00:35:59,900
וכל ההבדל הוא שבמרג' לא עניין אותנו שווה או גדול מ ..רק עניין אותנו קטן. אבל פה אנחנו אומרים זה כן מעניין אותנו. אנחנו לא בונים רשימה חדשה, אנחנו רק עושים את המעבר על פני הרשימה.. רשימות המקוריות. וזהו. ו''הנה'', אני אפילו, ואני אתן כאן קוד לדוגמה שממש מטגים את זה, אני בונה רשימה אחת ורשימה שנייה על ידי

98
00:35:59,900 --> 00:36:29,900
להגריל חמישה מספרים בריינג'ר אנדומלי שבין 0 ל-30, זאת אומרת ואני גם ממיין את זה, קורא ל- function built-in ביפייתון שממיינת, המיון הזה הוא כנראה יהיה איפשהו בין n ל-n  נוגן, תלוי איך פייתון מממש את זה, והנה תראו שזה עובד. אז אני לוקח את שתי הרשימות האלה, בעצם אני יודע מה, אני אקח אותך למטה שוב. יא פחות הביא

99
00:36:29,900 --> 00:36:55,480
כן, הנה, אז ליסט 1 חמישה איברים האלה, ליסט 2 חמישה איברים האחרים, אבל מה אתם רואים? 7, 21, 26, יש פה הרבה חפיפות, לא? יש פה הרבה איברים שותפים, אז אני אריץ את זה שוב.

100
00:36:55,480 --> 00:37:25,060
רנסל, עדיין יש לי איברים שותפים, אני אריץ שוב, אני אריץ שוב, אני אריץ שוב, או סוף סוף, עכשיו נפלתי על הגרלות רנדומיות שבהן הרשימות האלה באמת זרות לחלוטין, אז עכשיו הליסט הן כן דיסג'וינטד. טוב, למה לא? אין שום סיבה שלא ניקח אלגוריתמים למיון ונשנה אותם קצת בשביל לפתור בעיות.

101
00:37:25,060 --> 00:37:55,060
אז, בואו נסתכל על בעיה הבאה בתור... וכפי שהכותרת נראית לכם כאן, זאת בעיה שלקרוכה ממקור מאוד מאוד חביב לבעיות שצריך לפתור במודעי המחשב כדי להיות חדים, מה שנקרא. אז, בואו נניח שאנחנו עכשיו עוברים לעולם של קטעים, אם אתם לומדים חדו"א אחד, או שכבר למדתם את זה בעבר, אז, זה יהיה להכיר לך טעות חדה גבוהה. איך אתם מתמידים לתרגם לרוצחים האלה שייתה כבר ...העת Java, והיית מישהו שצריך לעשות להם ביטקוק או, או בעיה איתך לגמרי מה שלומד את

102
00:37:55,060 --> 00:38:25,060
קצת מוכר הרעיון של כאילו קטע שזה פשוט כזה תחום או טווח של ערכים שמתחיל מנקודה אחת ונגמר בנקודה אחרת. או סתם דוגמאים, אם אתם ממש רוצים להבין, הנה דוגמא לקטע שלוש פסיק שש. זה קטע שמתחיל בשלוש ממש ונגמר בשש ממש ופה בפייתון אנחנו נתייחס לרשימה של שני עברים שנראית ככה בתור קטע

103
00:38:25,060 --> 00:38:49,360
כי זה הגיוני. כך אנחנו כותבים את זה במתמטיקה, ו...היי, יש לזה גם משמעות בפייתון, רשימה של שני איברים. אז אנחנו צריכים לכתוב פונקציה שנקבלת רשימה של קטעים. כלומר, רשימה של רשימות, כמו שאתם רואים, וברור לכם איך קטע מוגדר, האיבר הראשון קטן יותר מהאיבר השני.

104
00:38:49,360 --> 00:39:19,260
ומה הפונקציה צריכה לעשות? הפונקציה צריכה להחזיר, תקשיבו טוב, קצת קשה להסביר, הפונקציה הזאת צריכה להחזיר את המספר המינימלי של ערכים שמשותפים בין קטעים פה, כך שבסך הכל אנחנו נוכל לכסה את כל הקטעים שקיבלנו. אוקיי, מה זה בעצם אומר? תסתכלו כאן על רשימת הקטעים הזאת.

105
00:39:20,060 --> 00:39:49,160
הנה, אני ממש רוצה לכתוב לכם את זה כאן. יש לנו כאן קטע שמתחיל ב-10 נגמר ב-16, קטע שמתחיל ב-2 נגמר ב-8, קטע שמתחיל ב-1 נגמר ב-6, קטע שמתחיל ב-7 נגמר ב-12. בסדר? מה הרעיון? אתם רואים שנניח בקטע שמתחיל ב-1 ונגמר ב-6, יש...

106
00:39:49,160 --> 00:40:19,060
חפיפה בין הקטע שמתחיל ב-2 ונגמר ב-8. כי בעצם כל הדרך בין 2 עד 6 כולל, אז שני הקטעים האלה חופפים. אז אני יכול לבחור כל ערך, נניח, בין 2 ל-6, ואם אני אשים את הערך הזה על הציר ה-x שלי, הוא יהיה משותף לשני הקטעים האלה. אז זאת אומרת, זה בוודאות נקודה אחת שאני...

107
00:40:19,860 --> 00:40:47,740
ערך אחד שאני סופר. עכשיו תסתכלו על שאר הקטעים. הנה קטע שמתחיל ב-7 ונגמר ב-12. הוא גם משותף לקטע של 2 נגמר ב-8, אבל הוא כבר לא משותף לקטע של 1-6, נכון? מצד שני, ה-7 עד 12 בהחלט חופף בלא מעט ערכים, 10, 11 ו-12, עם הקטע שמתחיל ב-10 ונגמר ב-16.

108
00:40:47,740 --> 00:41:17,740
אז זאת אומרת, אני יכול לבחור x שווה 6 שתהיה משותפת בין שני הקטעים האלה, x שווה 11 שתהיה משותפת בין שני הקטעים האלה, וזו, זה בהכרח המינימום. מינימום ערכים נפרדים, שביחד הם מכסים לנו את כל הא�firויות, זאת אומרת, ביחד אני בעצם נגעתי בכל הקטעים שנתונים לי. יש גם דוגמת,

109
00:41:17,740 --> 00:41:47,740
אחרת שאולי גם תעזור לכם להבין, אם דוגמא אחת לא הספיקה. נניח יש לי קטע שמתחיל ב-1 נגמר ב-10, קטע שמתחיל ב-6 נגמר ב-7, קטע שמתחיל ב-8 נגמר ב-12. תסתכלו. הקטע של 6 עד 7 הוא מוכל לחלוטין בקטע של 1 עד 10. הקטע הזה פשוט אוכל אותו בפנים. אור בחיים. אז ברור לכם שנקודה או בש-6 או בש-7 אין להם איכות. זה

110
00:41:48,060 --> 00:41:51,080
היא מספיק טובה בשביל לחסות את שני הקטעים האלה.

111
00:41:53,060 --> 00:41:55,660
יש גם את הקטע שמתחיל ב-8 ונגמר ב-12.

112
00:41:56,080 --> 00:42:03,660
לצערי, אין לו חפיפה עם הקטע של 6-7 בכלל, אז אני חייב עוד דרך.

113
00:42:04,600 --> 00:42:16,460
ואז העוד דרך תבחרו, 8, 9 או 10. וביחד כיסיתם את הזוג הזה. ובסך הכל, בסך הכל כיסינו את כולם. אז...

114
00:42:16,460 --> 00:42:40,260
אני מקווה שאתם מבינים את הרעיון. הרעיון הוא, אנחנו רוצים לבחור ערכים, את המינימום ערכים שאפשר, כך שנחסה את כל הקטעים בסך הכל. כל עוד שיש חפיפות בין הקטעים, יותר טוב. אנחנו רוצים נקודות שהן מקסימום ניצול של חפיפות של קטעים. איך נעשה את זה? אז...

115
00:42:42,920 --> 00:42:50,200
אנחנו נרצה לעבוד בצורה שנקראת פתרון חמדני, גרידי באנגלית.

116
00:42:50,520 --> 00:42:56,920
זו צורת חשיבה וצורת פתרון בעיות שאתם תדקלו בה עוד יותר גם בקורסי המשך,

117
00:42:57,100 --> 00:43:02,560
שם בכלל ידברו איתכם על זה בצורה ישירה. פה אנחנו רק מציגים לכם את זה על הדרך.

118
00:43:03,980 --> 00:43:12,860
מה צורת פתרון הבעיות הזאת עושה? היא בעצם מחפשת את המקסימום רווח, מקסימום...

119
00:43:12,860 --> 00:43:25,540
התקרבות למטרת יעד בכל שלב, זאת אומרת כבר לשלב הראשון אנחנו נבחר בדבר שהכי יקרב אותנו ליעד הרצוי.

120
00:43:25,540 --> 00:43:42,600
זה לא בהכרח הדבר הכי יעיל, לא תמיד, לפעמים זה אפילו לא ייתן לנו את המינימום שאנחנו היינו רוצים, אבל עבור בעיות פשוטות מספיק זה דווקא יכול להיות אחלה שיטה. זה גם שיטה יחסית קלה לחשוב. מה...

121
00:43:42,600 --> 00:44:11,860
הנה איך זה נראה לדוגמה פה, אנחנו ניקח רשימת נקודות שנקבל, נמיין אותה לפי הנקודות התחלה של כל קטע, אז תסתכלו, הנה הרשימה שקיבלנו, ופשוט נמיין אותה לפי הסדר, מהקטן הגדול של הסטארט פוינטס של כל קטע, ואתם רואים את זה, 1 ואז 2 ואז 7 ואז 10. לא מדברים אתכם על האנד פוינטס, כן?

122
00:44:12,720 --> 00:44:18,040
למרות שבמקרה פה ספציפית, הם גם ממויינים, אבל זה לא היה המיון שלנו. אוקיי.

123
00:44:19,600 --> 00:44:34,820
עכשיו מה אנחנו עושים? אנחנו בעצם נבדוק לכל קטע, החל מהקטע השני, האם אתה חופף איפשהו לקטעים שהגיעו לפניך?

124
00:44:35,640 --> 00:45:04,580
שימו לב, אני אומר קטעים, לא רק לקטע הקודם, למה? כי אני רוצה לחפש רצף של חפיפות שבהן כל הקטעים חופפים אחד לשני, ואם אני מוצא קטע שהוא שובר את הרצף חפיפות הזה, אז אני אגיד, טוב, אין ברירה, אני מגדיל את הקאונטר שלי של כמה ערכים נפרדים אני צריך בשביל להשיג את הכיסוי הזה. אז הנה היגיון פה.

125
00:45:04,580 --> 00:45:28,740
נניח, אני אסתכל על קטע 2-8, אני שואל אותך, האם אתה התחלת לפני הסוף של, או פה ספציפית, לפני נקודת הסוף המינימלית הנוכחית, אז פה אנחנו רק מתחילים את הפתרון, אז נקודת הסוף המינימלית היא פשוט נקודת הסוף של הקטע הראשון.

126
00:45:28,740 --> 00:45:58,700
אז 2 אכן מתחיל לפני 6, יופי, זה מעולה, אז מה אני עושה? מבחינתי עכשיו שני הקטעים הראשונים חופפים, ואני גם על הדרך אומר, מינימום, נקודת הסוף המינימלית עכשיו היא המינימום שבין המינימום הקיים לבין הקטע הנוסף שהוספתי עכשיו. עכשיו 2-8 נגמר יותר רחוק, אז המינימום נשאר 6.

127
00:45:59,520 --> 00:46:28,680
ואני ממשיך, עכשיו אני אומר, 7 עד 12, האם 7 אתה מתחיל לפני נקודת הסוף המינימלית שהייתה ליד עכשיו? לא, אם ככה מבחינתי זה אומר שאני מגדיל את הקאונט, ואני אומר שעכשיו הנקודת סוף המינימלית החדשה היא מתחילה ממך והלאה, וככה אני ממשיך.

128
00:46:28,680 --> 00:46:51,320
את התהליך, 10 עד 16, האם אתה מתחיל לפני המינימום הנוכחי, 12? יופי. וסיימתי. זאת אומרת, לפי האלגוריתם הזה, האקאונט שלי הוא 2. 1 בגלל הזוג הראשון ו-2 בגלל הזוג השני, ככה זה יצא. ובואו תראו איך הפתרון הזה נראה.

129
00:46:51,320 --> 00:47:21,200
אני בונה את הפונקציה שלי, היא מקבלת רשימה של אותם קטעים, אני ממיין את הקטעים האלה ממש לפי מפתח ספציפי. אתם רואים פה דוגמה לפונקציית למדה, אבל מה זה פונקציית למדה אם הספקתי משכוח? זה לא אומר הרבה, אני בסך הכל אומר, מפתח המיון שווה למה? לכל x, או כאילו מה זאת אומרת לכל x?

130
00:47:21,560 --> 00:47:51,080
מפתח המיון שלי הוא פשוט לפי האיבר באינדקס הראשון של כל איבר ברשימת פוינטס. אז זה בסך הכל דרך מאוד מאוד מסובכת להגיד, למיין את רשימת פוינטס, לפי הvalue של האיבר הראשון של כל איבר ברשימה. עכשיו, לא להתבלבל.

131
00:47:51,080 --> 00:48:20,000
בבקשה, אם נניח זאת הרשימה שלנו, אז כל x, זאת אומרת כל איבר ברשימת פוינטס, המפתח הוא x באינדקס 0. אז נקודת ההתחלה. כלומר, מה שאתם רואים פה, זה בדיוק משיג את המטרה שכתובה כאן, להתחיל מלמען לפי ערכי הקצה ההתחלתי. זה בדיוק מה שהפקודה הזאת עושה.

132
00:48:20,000 --> 00:48:44,700
הנה כתוב כאן sort בסוגריים key שווה, מה המפתח? תוצאת פונקציית הלמדה הזאת. per איבר x זה ממש כמו for item in list, בלה בלה בלה. אז per איבר x פשוט תחזיר את הvalue של האינדקס הראשון שלו. אוקיי, עשינו את המיון. אז אנחנו אומרים, count מתחיל מ-1, צריך לפחות נקודה 1.

133
00:48:44,700 --> 00:48:55,400
הסטארט שלנו כרגע, מקום התחלת ההשוואות שלנו, של חפיפו קטעים, מתחיל מהקטע הראשון, points באינדקס 0.

134
00:48:55,400 --> 00:49:12,840
הטופ שלנו, המינימום שאנחנו צריכים עכשיו להשוות אליו, הוא בכלל, כמו שאתם רואים פה, סטארט באינדקס 1, כלומר, כמו שאמרנו אחרי המיון, רגע, איפה המיון? הנה.

135
00:49:12,840 --> 00:49:42,320
זה, כל הקטע הזה, זה סטארט, וסטארט באינדקס 1, זה הסוף של הקצה הראשון. זה כאילו, זה הקצה הסופי של הקטע הראשון. זה ההגדרה הזאת. ועכשיו אנחנו אומרים, לכל אינדקס בריינג' שמתחיל ב-1 ונגמר עד סוף ה-points, זאת אומרת, לכל שאר הקטעים, נגיד, אם הקטע הנוכחי, כלומר, points באינדקס,

136
00:49:42,320 --> 00:50:12,160
מתחיל, תראו את זה, אם הקטע הנוכחי מתחיל אחרי הטופ שהגדרנו, אחרי הנקודת, הקצה הסופי המינימלי, אז אנחנו אומרים אין ברירה, צריך להגדיל את קאונט, ואז מתחילים את ההשוואות שלנו, זאת אומרת, רואים את סטארט, מתחילים את ההשוואות שלנו בנקודה הבאה בתור. למרות שעכשיו כשאנחנו חושבים על זה,

137
00:50:12,560 --> 00:50:42,000
כן, אנחנו צריכים את סטארט, אז אתם רואים, הסטארט שלנו בעצם הופך להיות מהקטע הבא הראשון שאנחנו מתחילים לבדוק ממנו והלאה, אז אנחנו מגדירים סטארט ב-points אינדקס, זה שכבר התחיל יותר מאוחר מהסוף המינימלי, ואז מגדירים סוף מינימלי חדש, זה פשוט הקצה הקטע הנוכחי, וככה האפורה זה ימשיך. אחרי שסיימנו אגב את האיף הזה, בלי קשר,

138
00:50:42,000 --> 00:51:12,000
אנחנו אומרים, הקצה הסופי המינימלי הנוכחי הוא המינימום בין מה שיש לנו כבר עכשיו לבין הקטע שעברנו עליו כרגע. זה בעצם כל המימוש הזה ו-return count בסוף זה בדיוק מה שדיברנו עליו כאן. וכמו מקודם, הנה הפונקציה. אז פה אתם רואים את הפונקציה כתובה בדיוק כמו

139
00:51:12,000 --> 00:51:42,000
כמו שראיתם במצגת, וכאן אפילו בניתי כמה רשימות לדוגמה של פוינטס. אמרנו ששני הפוינטס הראשונים יחזירו שניים, ואפילו רק בתור sanity check, bניתי גם רשימה של פוינטס שאין חפיפה ביניהם. יש פה כאילו שלושה אינטרבלים נפרדים, שלושה קטעים, אז זה אמור להחזיר שלוש. אז בואו נעריץ פה run cell, ובואו נראה מה הוא מחזיר לי.

140
00:51:42,000 --> 00:51:44,960
רגע שנייה, פה, הנה.

141
00:51:45,840 --> 00:51:52,140
הנה פוינטס 1, הנה פוינטס 2, ופוינטס 3 כמו שאתם רואים. אנחנו פסכים 3.

142
00:51:52,900 --> 00:52:02,220
אז, אם אתם רוצים, אתם יכולים לשחק עם הקוד הזה, לראות שזה עובד לכם גם עבור רשימות אחרות. וזהו, עבור השאלה הזאת.

143
00:52:03,040 --> 00:52:11,440
עכשיו, נעבור לשאלה האחרת, שאלה 4, שגם היא לקוחה ממקורות טובים באינטרנט, נקרא לזה ככה.

144
00:52:11,440 --> 00:52:41,380
אנחנו צריכים לכתוב פונקציה, שגם, מקבלת רשימה של קטעים, בדיוק לפי הגדרה שראינו. ועכשיו, הפונקציה הזאת, היא תגיד מה, מה המספר המינימלי של קטעים, שאנחנו צריכים למחוק, כדי שכל מי שנשארים ברשימה, הם קטעים שמזרים לחלוטין, כלומר, עם 0 חפיפה. אז תסתכלו, נניח שיש לנו רשימת הקטעים הזאת, 1 עד 10, 2 עד 3, 4 עד 5.

145
00:52:41,380 --> 00:53:11,380
76789, אתם מסתכלים על זה ואתם כזה. הקטע 1 עד 10 חופף לכולם אם נעיף אותו נשאר עם שאר הקטעים שהם לא חופפים בכלל. איך נממש את זה? אז האמת שגם פה אנחנו יכולים לגשת לזה בגישה חמדנית וגם פה אנחנו יכולים למ�יין את הקטעים. האמת שפה גם אפשר

146
00:53:11,380 --> 00:53:41,380
לנסות למיין את הקטעים לפי נקודת ההתחלה, ואז לפתור את זה בצורה מסוימת, או מה שאנחנו נבחר, למעין את הקטעים האלה דווקא לפי נקודת סוף. אתה יודע שמה שאנחנו נעשה, אנחנו נמיין אותם הפעם שה-Key שלנו, אם אתה כבר רוצה להסתכל על פונקציית הלמבד, יהיה באמת לפי נקודת הסוף של כל קטע, ואז אם אנחנו נעשה את זה אנחנו למעשה נשאיר הכי הרבה מקום כביכול לקטעים הבאים בתור dysfunctionLe investigationLiving Grup He surpass  42 cœurי דמי שאתה מתקדם מרפאה ומשמעי חסום של מינוקסי צב�

147
00:53:41,380 --> 00:53:51,860
מרווח שאנחנו נשאיר בין הקטעים, אחרי המיון הזה, אז זה בעצם אומר שאנחנו נצטרך להסיר פחות קטעים בשביל לקבל חוסר חפיפה.

148
00:53:51,860 --> 00:54:02,460
ואם לא הבנתם כלום מזה, זה בסדר. בואו נראה את הפתרון ונראה אם אנחנו מבינים אותו. אז, נגדיר

149
00:54:02,460 --> 00:54:10,860
non-overlapping intervals, יקבל רשימה של הקטעים, ונגיד ככה, נתחיל עם שני דברים, previous שווה אפס,

150
00:54:10,860 --> 00:54:30,720
counter שווה 1, זאת אומרת פה כאילו אנחנו מניחים שאנחנו צריכים להתחיל, בוא נגיד את זה ככה, לשמור, להעיף, אתם כבר תראו את המשמעות של הפונקציה הזאת, לאט לאט. נתחיל את המבט הזה לאחר כך.

151
00:54:31,920 --> 00:54:40,160
אינטרבוס נקודה סורט, עכשיו נמהן את זה לפי נקודת סוף, אוקיי. נגדיר n, מספר הקטעים, אוקיי.

152
00:54:40,160 --> 00:55:10,060
עכשיו נתחיל, נסתכל לכל שאר הקטעים, מקטע באינדקס 1 עד הסוף. נגיד כזה דבר, אם הקטע הנוכחי, זאת אומרת החל מהקטע השני והלאה, הקטע הנוכחי, מתחיל לפחות איפה שהקטע הקודם נגמר, אז מה שאנחנו צריכים...

153
00:55:10,060 --> 00:55:39,760
לעשות, אנחנו יכולים להגיד שעכשיו הקטע הקודם הופך להיות הקטע הזה, כי מכאן ועל אנחנו בעצם נמשיך, ונגדיר את הקאונטר. עכשיו זה קאונטר של כמה קטעים אנחנו יכולים לא להעיף דווקא, זאת אומרת כמה קטעים אנחנו יכולים לחסוך.

154
00:55:39,760 --> 00:56:09,760
כאילו מה הרעיון? הרעיון הוא זה בסדר בשבילנו שהקטעים יגעו בקצה אחד של השני, אנחנו רק לא רוצים שתהיה חפיפה ממש נוראית. זאת אומרת, הניח קטע שמתחיל באחד ונגמר בשלוש, ואז קטע אחר שמתחיל בשלוש ונגמר במקום יותר מאוחר, אז אתם רואים מה שקורה פה. אנחנו אומרים, אם קטע הנוכחי, הוא מתחיל לפחות, איפה שקטע

155
00:56:09,760 --> 00:56:20,960
הקודם נגמר או יותר מאוחר מזה, אז זה בסדר, זאת אומרת, הנה קטע שלא צריך להעיף כי זה בסדר, אין חפיפה, אז אנחנו מעדכנים את ה-previous, אומרים, סבבה,

156
00:56:21,040 --> 00:56:39,680
ה-previous עכשיו יהיה הנוכחי, לא צריך להתעסק בקטעים קודמים שהם כבר נגמרו במקומות שהם סבבה, לא צריך להעיף משם, ונגדיל את הקאונטר של כמה שלא צריך להעיף, מה הרעיון? הקאונטר הזה גדל וגדל והוא לא גדל עבור קטע שכן צריך להעיף,

157
00:56:39,680 --> 00:56:50,980
ואז בסוף אנחנו מחזירים את מספר הקטעים, פחות מספר הקטעים שהם סבבה ולא צריך להעיף, ונקבע את מספר הקטעים שכן צריך להעיף.

158
00:56:50,980 --> 00:57:07,760
נשמע מתוסבך, לא? יש מצב. בכל מקרה, כמו כל שאלות כאן בתרגול, כתבתי כאן את הקוד של השאלה, וגם לקחתי את אותן הרשימות הקטעים פה,

159
00:57:07,760 --> 00:57:21,640
ואנחנו יכולים עכשיו לנסות להריץ עליהן את הפונקציה, ובואו נראה מה מספר המינימלי של אינטרבל שצריך להעיף עבור כל רשימת הקטעים, ונראה אם זה עובד, אם זה כמו שצריך להיות.

160
00:57:21,640 --> 00:57:37,660
אז נניח, הנה רשימה כאן, 1 עד 6, 2 עד 8, פה יש חפיפה. אז אם אנחנו נעיף את 2-8 לדוגמא, נכון? לפי איך שהפונקציה תעבוד, אנחנו נראה ש-2-8 הוא לא טוב.

161
00:57:37,700 --> 00:58:07,240
ביחס ל-1-6, אז כאילו נעיף אותו, ואז נעבור לאבא בתור, 7 עד 12 הוא כן טוב, הוא בסדר, אז עכשיו אנחנו נעדכן את ה...זוכרים? אנחנו מעדכנים את ה-previous להיות עכשיו האינדקס של הרשימה הזאת, ועוברים הלאה. משווים את הרשימה, את הקטע בין 10 עד 16, והוא כן חופף, אז זאת אומרת צריך להעיף אותו. אז פה באמת שתיים. אבא בתור.

162
00:58:07,240 --> 00:58:37,180
פה אתם רואים, 1 עד 10, עכשיו יש לנו 6 עד 7, אז מה אנחנו נעשה? תסתכלו, אנחנו מסתכלים על 1 עד 10, הרי אתם מסתכלים על סיפור פה, נכון? 1 עד 10, 6 עד 7, 8 עד 12. אז אל תתבלבלו, אנחנו ממ�יינים את זה, לפי נקודת הסוף, אז לא דווקא לפי נקודת ההתחלה, זה מציל אותנו.

163
00:58:37,180 --> 00:59:07,180
כי אם אנחנו נאמן את זה לפי נקודת הסוף, השש עד שבע יהיה בהתחלה, הוא ייחסך, ואז האחד עד עשר ייראה בתור אחד שהוא חופף, ואותו אנחנו נעיף ונשמור את השמונה עד שתעשרה. אז רק אחד, ופה, טוב, זה בייסט קייסט סנאריו, אף אחד בינינו חופף, לא נעיף אף אחד, אז כמו שאתה אומר, וזה עבד, זה עבד לא רע. יפה, אוקיי. אפשר להגיד שדיברנו

164
00:59:07,180 --> 00:59:37,180
על מיונים, עכשיו בואו נעבור לדבר על משהו קצת אחר, על דיקשונרי, מילון, זה קטע כזה בפייתון שיכול להיות ממש נוח לנו כשאנחנו רוצים לשמור כמה נתונים שקשורים אחד בשני, בצורה מסודרת. סתם דוגמא, נניח שאני רוצה לשמור רשימה של סטודנטים ולכל סטודנט יש לו את השם שלו, נניח צינור.

165
00:59:37,180 --> 01:00:07,180
ציון שלו באנגלית וציון במתמטיקה. אז דרך פשוטה לעשות את זה בפייתון היא בעזרת ה..יואלד לקרוא זה אובייקט שהוא דיקשונרי. איך זה עובד? דיקשונרי דרך אגב הם מוגדרים בעזרת סוגריים מסולסלות. אז זה כבר קטע סינטקטי כזה חדש. אם ראיתם מקודם סוגריים רובעות, סוגריים עגולות. אז תכירו סוגריים מסולסלות. אקי..תראו איך נגדיר

166
01:00:07,180 --> 01:00:37,020
נגדיר סטודנט שווה, סוגריה מסולסלות, זאת אומרת סטודנט הולך להיות אובייקט מסוג דיקשונרי, ואיך דיקשונרי עובד? אנחנו אומרים ערך כלשהו משמאל, אז בואו נניח סטרינג, כי אנחנו רוצים שם, אז אנחנו אומרים name, נקודתיים, ואז value, זאת אומרת value של ה-name, אלון, value של n, המקף גרייד יהיה 90.

167
01:00:37,020 --> 01:01:06,980
value של math, מקף גרייד, יהיה 100. אז הנה דרך בשבילנו, כי אז כשאנחנו נגדיר אינדקסים, אנחנו נוכל, סליחה, מה זה אינדקסים? כשנגדיר דיקשונריז, כשנגדיר מילונות, אז אנחנו נוכל לגשת לערכים במילונות, לא דווקא עם אינדקס, אלא לפי שם השדה, במקרה שלנו, name, אין גריידו, מה זה?

168
01:01:06,980 --> 01:01:36,980
או איך שנגדיר את זה. וכמובן אנחנו יכולים להגדיר מילון אם אנחנו יכולים לבנות רשימה עם כמה מילונות. תסתכלו על זה. עכשיו אנחנו בונים רשימה סטודנטס =, אתם רואים רשימה כי סוגריהם אורבעות שלושה מילונות נפרדים מילון אחד עם הערכים שראיתם מקודם. נעים אלון N-Grade 90-MathGrade 100. עוד מילון ניר עם ציונים שלו עוד מילון הזה. וקיצוניות שלו וחמופה שלו השל טובה ברכונות שלו והפשרות שלו בגלל שהם מלאים

169
01:01:36,980 --> 01:02:06,980
לונדן, האמציוני משלה. ואז איך אנחנו יכולים להגש לזה? אז תראו, בגלל שגזרנו את סטודנטס פה בתור רשימה, אז אנחנו צריכים לכתוב פרינט סטודנטס באינדקס אחד, כלומר, העבר השני, זה באמת יתפיס לנו כאן את הניר הזה. ואין אני רוצה עכשיו להראות לכם איך זה נראה בפייתון בוא נעבור לדקשנרי, אז הנה פה יש פה יש לנו רשימה של דקשנריס וכאן

170
01:02:06,980 --> 01:02:32,780
אני מדפיס את, האיבר השני ברשימה. Run Cell, אני רוצה שתראו גם. בבקשה.uminclf.c respons.png (  ) let's print atricodectionary נקודתיים ואז זה מה שמודפס ואתם רואים שהוא ממש מדפיס לכם את הדיקציונרי ( ) as is , שדה name, ערך  , סדה n-grade, ערך 80 . sdN-grade, ערך 25

171
01:02:33,680 --> 01:02:42,620
כן, אבל אנחנו לא רוצים עבודה עם אינדקסים, אנחנו רוצים לגשת לסטודנטים לפי השם שלהם, איך היינו עושים את זה?

172
01:02:43,160 --> 01:02:54,400
אז עכשיו אנחנו נבנה מילונות בתוך מילון, זאת אומרת, מה שנקרא נסטד דיקשינריז. איך נעבוד עם זה? תסתכלו.

173
01:02:54,400 --> 01:03:24,340
נגדיר סטודנט בתור מילון, ועכשיו במילון הזה יש שלושה מפתחות במילון, מה שנקרא, שלושה ערכים במילון. נניח, נגדיר אלון, והערך שלך יהיה בעצמו מילון עם אינג גרייד 90, מאט גרייד 100. נגדיר עכשיו, כי איך היה? ניר.

174
01:03:24,340 --> 01:03:54,240
עם מילון, אינג גרייד 80, מאט גרייד 25, וכן הלאה, וכן הלאה. כאילו, מה הפואנטה? הפואנטה היא, יכול להיות, לא יודע, אולי אפילו לא השתמשתי במילה כי כמו שצריך. אני מנסה להגיד לכם, שאם אנחנו נגדיר מילונות בתוך מילון, אז יכול להיות לנו גישה יותר נוחה לדברים שבתוך המילון. משהו שהיה הרבה יותר נוח. כי עכשיו תראו, אם אני אריץ לכם את זה, בואו תראו כמה שזה יותר נוח. הנה. תראו.

175
01:03:54,240 --> 01:04:24,240
טעוק כאן, יש לנו פה הדפסה, אנחנו רוצים להדפיס את מה שיש עבור ניר, אז תראו מה קורה כשאנחנו מריצים את זה. הוא מדפיס לנו בדיוק את המילון שקורספונטס במה שנקרא לניר, זה הרעיון במילון, הרי איך מילון בפייתון עובד? אתם אומרים ערך, במקצועות של הניר האוררך של המילון של מטרסקיעות

176
01:04:24,240 --> 01:04:53,780
איזושהי מחוזת, מה המשמעות שלה? התוכן הזה, פה ספציפית התוכן עצמו הוא מילון, כן? כי בפנים ה-N-גרייד הוא מתורגם להיות ה-value הזה, וה-Math-גרייד מתורגם להיות ה-value הזה. זה פשוט צורה מאוד מאוד נוחה, לשמור ערכים בצורה מסודרת, עם סוג של, אתם יודעים, קשר, עם קונטקסט, זה כלי ממש חזק בפייתון.

177
01:04:53,780 --> 01:05:23,780
אז יש לנו כמה דרכים להתעסק עם מילון ובעצם אני רוצה להראות לכם את זה פה בפייתון, אז בואו תראו. אנחנו יכולים להתחיל מילון רק, אנחנו יכולים כמו שאתם רואים להתחיל מילון ככה נניח refract להילם מילון עבור brand הערך שלך יהיה forward ואז נניח אם אני אריץ את ה-print הממילון הזה באינדקס brand מה זה אינדקס?

178
01:05:23,780 --> 01:05:53,780
מפתח ברנד אז הנה אתם רואים, אני אסתכל על זה, אתם רואים? תסתכלו על זה ככה. זה מילון והוא עובד לפי סטרינג מפתח סטרינג. זאת אומרת עבור סטרינג מסוים הוא יביא לכם את הסטרינג שהוא ממופה אליו.אז אם היינו מריצים את זה, זה לא צריך להפתיע אתכם, הוא היה מטפיס את הערך של הברנד הזה, את האפור. עכשיו, מה קורה אם היינו מנסים להריץ עכשיו. ארית pain מספר אינסטינקטון סטרינג מספר אינסטינקטון פר נמיה סטרינג. אין נהיה הספק של זה? מקום ש

179
01:05:53,780 --> 01:06:08,000
דיס דיקט אבל במפתח שלא קיים שם זאת אומרת דיס דיקט במקום פרייס אבל אין מפתח שקוראים לו פרייס בדיקט הזה אז תראו אני עכשיו הנה רגע אני גם משקית את זה.

180
01:06:09,000 --> 01:06:39,000
הופה, תראו. מריסת עשה לזה? אז ככה, מה קרה? הוא כן הריץ את הפרינט הזה: This date במקום ברנד, הוא הדפיס את פורד, כמו שאתם רואים, זה הרעיון, אנחנו שואלים, מה הערך שממופה למפתח ברנד? הוא הדפיס אותו, ואז, ניסיתי להדפיס מה הערך שממופה לערך פרייס... אבל... מה שפייתון היה נותן לי, הוא היה נותן לי "key error", כלומר שגיאת מפתח, כי זה לא נמצא במפתח.

181
01:06:39,000 --> 01:07:09,000
למילון, זה הקטע. עכשיו, אפשר להוסיף משהו למילון. עכשיו אני אומר דיסט-דיקט במופתח מודל שווה מוסטיינג. אז אם אני עכשיו אריץ את זה, תראו מה קרה. הוספנו משהו למילון, היה לנו את... במפתח בראנד את הערך פורד ועכשיו הוספנו מפתח ואת הערך שלו.

182
01:07:09,780 --> 01:07:16,200
לידי אופרטור השמה, וככה זה עובד. מילון חביב.

183
01:07:17,620 --> 01:07:23,600
יש לנו גם דרכים לעבור באיטרציות הפניים, מילון.

184
01:07:23,600 --> 01:07:37,000
אז בואו תראו כאן דוגמה. כאן אנחנו מגדירים מילון של מילונות, זה למה אנחנו חוזרים להגדרה הזאת. ועכשיו תראו מה הקטע. נניח, for name, שזה סתם.

185
01:07:37,000 --> 01:08:06,900
מילון המעילונות שלנו, סטודנטס, עכשיו תראו אנחנו עובדים עם נקודה, קיז סוגריים, מה זה בעצם אומר לנו, זה יסתכל לנו על המילון סטודנטס, למילון זה שלושה קיז בדיוק, קיז בשם אלון, קיז בשם נירב, קיז בשם דנה. אז כשאני כותב את המילון הזה, נקודה קיז סוגריים, זה בעצם פונקציה על מילונות שתחזיר לי רשימה של המפתחות.

186
01:08:06,900 --> 01:08:36,900
זה כאילו כמו רשימה של שלושה סטרינגים, הלא ניר דנה, ופה אני אומר 4 אייבר ברשימה הזאת, תדפיס, אז תראו מה קורה כשאני מריץ את זה, הנה אני אעשה ראנס על פה, אז תסתכלו, הנה, פה למעלה, Let's print the names of students in this dictionary, הוא ממש מדפיס, הנה אתם רואים, לפי הפרינט הזה, פרינט נאם, פשוט מדפיס את השם ממש, As is, זה עלול לעד 195 התוכחות

187
01:08:36,900 --> 01:09:06,900
זה הפור הזה. אוקיי, יש עוד דרך. מה אם אני רוצה דווקא values מסוימים, אז תסתכלו. עכשיו אני אומר for משתנה in students.values, אז ברור לכם מה זה keys, מה זה values. keys זה המופתחות, זה משמאל, תקראו לזה כותרת אם אתם רוצים, זה פשוט המפתח שאומר, היי, המשמעות שלי היא values.

188
01:09:06,900 --> 01:09:29,020
אז אני לא יודע אם אתם שמים לב אבל הvalues פה הם מילונות בעצמם אז כשאני אומר פה students.values זה כאילו רשימה של מילונות, אני בעצם, זה בעצם קצת דומה להגדרה שאתם ראיתם פה האמת, זה קצת דומה לזה. אז בואו נסתכל על זה חזרה.

189
01:09:29,020 --> 01:09:58,900
אני אומר for data in students.values, זאת אומרת לכל אחד מהמילונות שנמצאים כאן, אני עושה print של הדאטה באינדקס end grade, זאת אומרת אופרטור סוגריים רובעות מזהה פה ספציפית את ה-end grade הזה בתור key, ואני בעצם רוצה להדפיס את הvalue.

190
01:09:58,900 --> 01:10:28,320
שממופה ל-key end grade, ואני עושה את זה כאן לכל אחד מהמילונות האלה, במילים אחרות, אני הולך להדפיס פה 90, 80 ו-85. בשלוש שורות נפרדות, כן? כי זה פרינט אחרי פרינט אחרי פרינט. ואם אתם לא מאמינים לי, תסתכלו, הרצנו את הסל הזה, עכשיו אני הולך להסתכל על החלק הזה, אני אעשה פשוט סקרול דאון, היי, זה לא בדיוק מה שאמרנו.

191
01:10:28,320 --> 01:10:58,320
9885, זה בדיוק איך שזה עובד, אז ראיתם, עכשיו אתם בכלל כבר חזקים, אתם יודעים מה זה, אתם יודעים שיש לכם מילון, אז מילון נקודה keys מחזיר לכם רשימה של המפתחות של המילון, ומילון נקודה values יחזיר לכם רשימה של הvalues של המילון, שכל value b מופיע ל-kיה רלוונטי שלו. ראיתם? ופה בכלל הדפסנו values.

192
01:10:58,320 --> 01:11:28,320
בתוך value כי שוב מילונות בתוך מילון זה כבר מתוחכם הדבר הזה. אפשר כמובן, לעשות מעבר שהוא קצת איניומרטיב כי מה קורה כשאנחנו עושים מילון נקודה אייטמס. אז אנחנו מקבלים פה זוג. אנחנו מקבלים פה טפל. התגעגעתם לטפל? אנחנו מקבלים פה טפל ש..

193
01:11:28,320 --> 01:11:46,920
משמאל זה כי ומימין זה ואליו אז פה אנחנו בעצם משלבים את מה שראיתם פה בנפרד. עכשיו אני אומר for name seek data in the students.items הסוגריים. זאת אומרת, אני אקבע פה עכשיו טאפל של של של כי וואליו, עכשיו אני מדפיס.

194
01:11:46,920 --> 01:12:15,520
קי got value ספציפי, או יותר נכון value בתוך value ספציפי, כן? כי זה מילון בתוך מילון. עכשיו אני מדפיס שם קיבל את הציון שלו באנגלית in English. אתם רואים איך זה עובד. זה ה- keys, זה ה- name. ועכשיו אני נכנס לתוך הדאטה, לתוך הדאטה, בקי end grade. אז זה מה שיך לקבל. אתה מקבל הדפסה שנראית מאוד יפה.

195
01:12:15,520 --> 01:12:44,220
ואני אפילו קראתי לזה let's use enumerate, כי זה פשוט נראה כמו enumerate. אז הנה, אתם רואים? רק שזה לא בדיוק enumerate, זה זה אייטם סוגריים של דיקצ'ינרי. הנה. return a set like object providing a view on the deck's items. ממש ככה, זה מרגיש כמו טאפל. אז הנה. along got 90 in English, near got 80 in English, down got 85, אתם רואים? דרך בואו מסודרת. אז תראה.

196
01:12:44,900 --> 01:13:05,900
אז תראו, nested dictionaries, חביב. דרך אגב, מילון הוא muteable, אז ראינו רשימות שהן muteable. מה אנחנו יכולים לעשות עם מילונות אז? אוקיי, לא אופרטור פלוס שווה.

197
01:13:06,680 --> 01:13:36,680
אנחנו יכולים לקחת dictionary ולעשות לו פלוס שווה עם עוד dictionary אבל זה לא יעבוד. אתם יכולים אפילו לראות פה, לדוגמא, הולך פה על muteability. כתבתי את זה ב-try except, את האופרטור פלוס שווה, אבל.spoiler, אופרטור פלוס שווה, doesn't work with dictionary. אוקיי, זה לא ילך.בסדר. אבל, בטוח שיש לי דרך כן לשנות dictionary.איך אני כן יכול?

198
01:13:36,680 --> 01:14:06,680
לשנות ערך או להוסיף ולשנות או משהו, יש דרך בעזרת פקודת update, הנה אתם יכולים אפילו ממש לראות פה בפייתון, הנה update, אתם יכולים להוסיף  Com, להוסיף values, זה ממש מתודה לדיקצ'ונרי, כמו שאתם רואים כאן זה כותב פה הרבה דברים כי זה מראה לכם את כל הפרמטרים, כל הארגומנטים, כל האיתרר... בלה בלה בלה, לא מאוד מסובך, תראו מה אני עושה פה, אני עושה...

199
01:14:06,680 --> 01:14:36,680
Update. Update בקי שקוראים לו רון. אין מפתח כזה. אז זה יוצר מפתח כזה. והvalue הולך להיות רשימה ריקה. אז הנה. אני מריץ את זה. והנה ה-ID זה. need any משהו? חסרי לי פה משהו בפרינט. אני אוסיף עוד משהו. אני עושה. Here's the updated version of

200
01:14:36,680 --> 01:15:06,680
פסיק סטודנטס תדפיס לי את הדבר הזה ראנסל והיי, זה בדיוק מה שציפינו הוא מדפיס לנו, הוא מדפיס לנו את הדיקשונרי המלא הזה? אז קי אלון עם ה-value שלו, קי ניר עם ה-value שלו, קי דנה עם ה-value שלה וקי חדש רון עם ה-value שלה, אוקיי וקי חדש רון עם ה-value שלה רק לו להפגור...

201
01:15:06,680 --> 01:15:28,340
לא, משימה ריקה, אה, דרך אגב, Update ממש מראה לכם את המיטביליות של דקצ'ינרי בגלל שאני הדפסתי את אופרטור ID לפני ואחרי, והתוצאה היא בדיוק אותה מספר, אז זה ממש מראה לכם את המיטביליות של דקצ'ינרי, מגניב?

202
01:15:31,780 --> 01:16:01,760
אוקיי, אז בואו נתרגיל טיפה דקצ'ינריס, מבקשים איתנו לכתוב פונקציה שמקבלת איזשהו טקסט ממש ממש ממש ארוך, ומה שהפונקציה תעשה היא תבנה דקצ'ינרי, מילון, מה, איך המילון זה ייראה? כל מילה בנפרד שמופיע בטקסט, אז היא תהיה קי, והוואליו של הקי הזה יהיה כמה פעמים המילה הזאת.

203
01:16:01,760 --> 01:16:29,660
הופיע בטקסט, אחרי זה מבקשים איתנו למיין את המילון לפי המילה הכי פופולרית, זאת אומרת מהגדול לקטן, למיין את הvalues, זאת אומרת, למיין את ה-keys של המילון לפי הvalues, מגדול לקטן, ואז בסוף מבקשים איתנו להחזיר איזשהו סלייס רשימה כזה של העשר מילים הכי פופולריות. איך נגש לכזה דבר? אז בואו נסתכל על זה.

204
01:16:29,660 --> 01:16:59,660
בואו נגדיר פופילאר וורדס שהוא מקבל מגה מסיב סטרינג, אז מה אנחנו נעשה? נגדיר וורדס תהיה רשימה, והתוכן שלה יהיה כל הסטרינגים הנפרדים בטקסט שמפוצלים לפי ספייס, זה אגב הדיפולט ספליט, כן? ...,אז וורדס הולך להיות רשימה של כל המילים, לתוך הטקסט הזה, איך שפוצלנו לפי ספייס.

205
01:16:59,660 --> 01:17:29,660
בדיקציונרי חדש, בשם קאונטס. עכשיו, לכל מילה ברשימת המילים, יש כאן איף שאנחנו חייבים לעשות. תראו מה, איתא אומרים אם מילה כלשהי לא נמצאת ברשימת המפתחות שבדיקציונרי קאונטס, ודייך אגב, הגדרנו את קאונטס ל-3.39 בתוךן למליציה ומכירה. ולמשמעות של הקשורנריות שלטרן, שלטרן שבחינת המילים של לימ הזה (דא קט גול גול גול) אתה יכול להסביר מה שצריך (צריך מליציה מגיעה), ‫זל תגיד שאתה יכול להתעורך, ואתה יכול לס

206
01:17:29,660 --> 01:17:59,660
להיות דיקשונרי ריק, כמובן שאין לו שום קיז כרגע. אז אנחנו בונים כזה קיא. אנחנו אומרים קאונץ, באינדקס, הוא היה את הנכון, קאונץ, באינדקס, אני אומר אינדקס פעם שנייה, זה מדהים, זה בגלל השעה, אני מקליט את זה בחמש ועשרים בבוקר. סליחה. המילון קאונץ במפתח word, המילה הנוכחית, שווה 0.

207
01:17:59,660 --> 01:18:29,660
זאת אומרת, אנחנו לוקחים את המילון קאונט, מוסיפים לו מופתח,שזה המילה נוכחית, ומוסיפים לזה ואליו, 0. מה קורה אם לא היינו עושים את ההעיף הזה? אז היינו כאילו מנסים לעשות פלוס שווה על מופתחות שלא קיימים, וראינו, אני לא יודע אם אתם זוכרים, ראינו שאי אפשר לקחת מילון ולעשות לו פלוס שווה.

208
01:18:29,660 --> 01:18:59,660
זה לא עובד, אז היינו חייבים להוסיף בצורה אקספליסט ככה, היינו צריכים להגדיר מילון במפתח, כך מפתח חדש שווה 0, זה מה שגורם לכל הסיפור הזה לעבוד, אוקיי, אז לכל מילה ברשימת מילים, אם ןיא לא קיימת במילון, נוסיף אותה למילון ו-value 0, עשינו את זה?

209
01:18:59,660 --> 01:19:10,880
יופי, בין אם הייתה את המילה או בין אם לא, עכשיו שווידנו שיש אותה, נגיד מילון במפתח word value שלך פלוס שווה 1.

210
01:19:11,520 --> 01:19:25,940
וככה אנחנו בעצם במילון מוסיפים פלוס 1 לפרנס של המילה, ואנחנו פשוט עוברים לכל מילה ברשימת המילים, כשפיצלנו את הסטרינג. סיימנו את זה, מדהים, מה נעשה?

211
01:19:27,100 --> 01:19:57,060
אנחנו נעשה פה מה שנקרא pick python, let's python this stuff, איך? תסתכלו, ניקח את כאונטס, את האאיטמס של המילון, זאת אומרת, נקבל עכשיו רשימה של כל האאיטמס של המילון, עכשיו תראו את הקטע הזה, אנחנו אומרים, נמיין את רשימת, ככה, ניצור רשימה מתוך כל ה...

212
01:19:57,060 --> 01:20:26,860
אייטמס שבמילון, שזה גם ה... זה הולך להיות רשימה שהיא קצת כמו סטס כזה, כאילו רשימה של... מרגיש כמו טאפלס, נכון? כי אתם זוכרים מה קרה באאיטמס, אייטמס נותן לנו גם קיא וגם ואליו, אתם זוכרים? הנה, אני הולך איתכם אחורה, אתם רואים? מילון נקודה אייטמס נותן לכם גם את הקיא, גם את הוואליו, זאת אומרת, זה קצת כמו טאפל, קצת כמו רשימה...

213
01:20:26,860 --> 01:20:56,440
כשלעצמה העבר באינדקס 0 זה ה-Kי והעבר באינדקס 1 זה ה-value. למה זה טוב? עכשיו תסתכלו, נגיד רשימה של סטים של קי וואליו, רשימה, נמיין אותה לפי איזה מפתח? אתם רואים פה שוב? למדה x נקודתיים x באינדקס 1, כלומר נמיין את רשימת.

214
01:20:56,440 --> 01:21:26,040
כל הרשומות במילון לפי ה-value אבל ברברס. זאת אומרת מיון מהגדול הקטן. סיימנו את כל זה, ניצור מזה דיקצ'ונרי. זאת אומרת לקחנו דיקצ'ונרי, פירקנו אותו לרשימה של שמות ורשימה של מפתחות וערכים.

215
01:21:26,600 --> 01:21:39,160
מיהנו את זה עכשיו מהגדול הקטן, לפי הערכים, ואז בנינו את זה מחדש כרשימה, וזה מה שעשינו לקאונטס, אז מקווה שלא הלכתם לאיבוד, כן?

216
01:21:41,440 --> 01:22:02,740
ובסוף, מה התבקשנו? גם להחזיר את הרשימה של הטופ 10, אין בעיות, נחזיר ליסט של המילים, זאת אומרת ה- keys של הקאונטס, בסלייס שמתחיל ב-0 נגמר בתשע כולל, אוקיי? טופ 10 וורדס.

217
01:22:03,940 --> 01:22:33,880
ואם כל זה נהיה לכם מאוד מאוד מטוסבך, אז אני מסכים איתכם, אבל בואו תראו את זה עובד בכל מקרה, אז קודם כל, תראו את הסטרינג, עכשיו בכלל, מה שאתם רואים כאן זה קונטקסט פייטוני, אני מגדיר משתנה בשם טקסט שווה, 3 3, זאת אומרת, יש פה 3 מרכאות, 3 מרכאות, ואז, תראו את זה, כל שורה 233, זה כל הטקסט המסך.

218
01:22:33,880 --> 01:23:03,880
cvy הזה, בלי enter אחד, בלי מעבר שורה אחד, כל זה, ואז אני סוגר את זה בשלוש מרכאות. כל זה, זה טקסט סטרינג אחד, בלי backslash n אחד, כל זה. הייתי צריך להפעיל הגדרה ב vs-code שקוראים לה wordwrap רק כדי שאני אוכל לראות את כל זה עובר לשורה הבאה, כי בלי wordwrap... 62317 על ידי כבור רוטבולנס

219
01:23:03,880 --> 01:23:33,880
אז פשוט, אתם רואים את זה? כל הטקסט בשורה אחריה והייתי צריך לגלול עד הסוף ימינה, אני לא אוהב את זה. על צד, לא? לא של ה... של הplay שלי, תדע? word wrap. תדע. אוקי. אה, דרך אגב, הפעלתי גם word wrap פה ב... Output Console, במקרה שלא יודעת אם למה אני רואה את זה. אתם גם יכולים, אתם יכולים לחפש בגוגל הזה, זה לא, לא קריטי, בכל מקרה.

220
01:23:34,540 --> 01:23:47,940
אז אני אומר, אנחנו הולכים לקחת הטקסט הזה, אני מודפיס אותו, ואז אני קורא לה פונקציה פופיולר וורדס. תראו איך היא עובדת כמו שהסברנו במצגת.

221
01:23:47,940 --> 01:24:01,520
forward in words, נוודא שזה קיים בדקצ'נרי, נגדיל את הנוכחות שלו, ואז ניקח את כל האייטמים, זאת אומרת, קיז וווליוס, נמיין אתכם לפי.

222
01:24:01,520 --> 01:24:18,540
ערך הוואליו עצמו, מהגדול הקטן, ניצור מזה בחזרה דקצ'נרי, הנה אתם רואים, זה בונה דקצ'נרי, ונזיך חזרה ליסט כזה של עשרה מילים שהופיעו הכי הרבה, בואו נריץ את זה.

223
01:24:18,540 --> 01:24:32,540
רנצל, הנה, הנה, the very very long text we'll use is this. ואז בלה בלה בלה בלה בלה בלה כל זה.

224
01:24:32,540 --> 01:24:46,740
אוקיי, מה העשרה מילים שהופיעו יותר הרבה? כמו שאתם רואים זה עשרה מילים שהייתם מצפים שיופיעו יותר הרבה. to, of, and כל המילים הקישוריות. the, who, והוא, reference?

225
01:24:46,740 --> 01:25:16,440
אה, pleasure pain a is that. נו, אני מקווה שאתם מאמינים שזה עובד, אם לא, אתם מוזמנים לבדוק את זה, הקוד זמין לכם במודל. מדהים. dictionary. בוא נעשה עוד משהו קטן עם dictionary. נכתוב פונקציה שנקבלת שתי רשימות, רשימה אחת היא תאכיל שמות של פירות, ורשימה אחרת תחזיר, היא כאילו, יהיה למחירים, ואנחנו פשוט צריכים לבנות מילון.

226
01:25:16,440 --> 01:25:46,440
שבו המופתח הוא שם פרי וה-value הוא מחיר הפרי. אז אנחנו יכולים לעשות את זה בדרך הקשה, שזה לקבש שתי רשימות, לבנות dictionary rack ואז לכל טאפל שלset fruit וprice בזיפ שבונה לנו טאפל מתוך כל זוג האיברים המתאימים ליסט 1 וליסט 2, נגיד הדקצ'ונרי פרוץ במופתח סט רופט, שפוקס שנחנו עכשיו מגדירים לסט

227
01:25:46,440 --> 01:26:16,440
הvalue שלך יהיה הפrice ואז נחזיר את הדיקצ'ינרי. כמו שאתם רואים זה איך שזה יעבוד. אבל אתם, ספוילר, אתם ראיתם את ה�רדיקט שבונה דיקצ'ינרי ממה שאתם נותנים לו, אז כן, אנחנו יכולים פשוט להגיד, תעשו zip לליסט 1 ל-2, זאת אומרת כל זוג האיברים בהתאמה.

228
01:26:16,440 --> 01:26:46,440
יהיה מסודר עכשיו ביחד, יופי. תבנו מזה דקציונרי. קי, ואליו, פר זוגי ורים. וזה לא צריך לחפתי אתכם, זה עובד. אז הנה, תראו, יש לי פה עוד שתי פונקציות, הקומביין הארוכה יותר והקומביין הקצרה, בדיקט של זיפ של, הנה שתי רשימות, נבנה אותן בשתי הדרכים השונות ונדפיס אותן. זה לא מפתיע, זה ירוץ בדיוק את הדבר.

229
01:26:47,440 --> 01:27:17,440
אז היי, אנחנו מגיעים לשדה. איזנה נאיז. ועכשיו נעבור. לנושא האחרון, של התרגול הזה, רשומות. כתוב פה רקורד. אולי במקומות אחרים, אתם תכירו את זה, במבוא למדע ממחשב בתור סטרוקט. כאילו בקטע של אובייקט, או פשוט בקטע של כזה במרכאות משתנה, שיש לו שדות, שכל שדה הוא בעצמו משתנה.

230
01:27:17,440 --> 01:27:26,140
עכשיו זה שראיתם עכשיו דיקשונריז זה די, די פחות או יותר נתן לנו כבר את המשמעות שחיפשנו.

231
01:27:26,260 --> 01:27:39,340
אז באמת נניח שאנחנו רוצים לשמור, לא יודע, רשימה של, נניח סטודנטים, אבל לכל סטודנט יש באמת שם ציונים בכמה קורסים, אז זאת אומרת, זה הרעיון.

232
01:27:39,400 --> 01:27:51,320
כל סטודנט הוא כאילו נקרא לו אובייקט גדול כזה, או מה שזה לא יהיה, ויהיה לו שדות, כמו שאתם רואים, שם ציון כזה, ציון כזה, זה כאילו נקרא לזה שדות נפרדים.

233
01:27:52,000 --> 01:28:09,340
אז למה בעצם אני חותר? אני מנסה להגיד לכם שבעולם מדעי המחשב, מילון בפייתון זה נחמד, יש תבנית אחרת לקונספט הזה של רשומה, של סטרוקט, של אובייקט, לא בהכרח מדבר איתכם על אובייקט בזיכרון של פייתון, אלא.

234
01:28:09,340 --> 01:28:38,900
למונח אובייקט, המונח המדעי מחשבי, אז בשביל לתת לכם מבוא לזה, אנחנו נעזר במודול דאטה קלאסס, מה זה דאטה קלאסס? תחשבו על זה בתור מחלקה, בתור קלאסס, שכאילו נועד לשמונה נתונים. עכשיו יש פה כוכבית, תראו, הקונספט הזה של.

235
01:28:38,900 --> 01:29:05,260
קלאס, של אובייקט, זה כבר. מביא אותנו לנושא של אובייקט אוריינטד פרוגרמינג, אבל זה קורס המשך בשבילכם. אנחנו לא ניכנס עכשיו, ספציפית, לרעיון הזה, שזה גם קורס שאם אני לא טועה אתם תלמדו אותו בכלל בג'אווה, בשנים קודמות הוא נלמד בc++ אבל אותו קונספט כללי.

236
01:29:05,260 --> 01:29:35,180
אז כאן אנחנו רק מביאים לכם את המודול, את הקטע הזה דאטה קלאסס בפייתון, בשביל רק להראות לכם דוגמה לאיך זה נראה. אז בואו תראו. בעיקרון, בחיים האמיתיים, בעולם התכנות, הרבה פעמים אנחנו נצטרך מה שנקרא לו משתנים מורכבים, זאת אומרת משתנים במרכאות, שיש להם בפנים.

237
01:29:35,420 --> 01:30:03,460
משתנים, וזה זה החלק שמשנה, זאת אומרת כל משתנה מורכב כזה, כל קלאס כזה, יהיה לו שדות, ולכל אחד מהשדות שלו יהיה לו את המשמעות שלו, ובהרבה הרבה הרבה מקרים, אנחנו נצטרך את הסדר הזה, אנחנו נצטרך את הארגון הזה, שיש לנו ככה אובייקטים מורכבים כאלה שיש להם שדות, ופה אתם רואים דוגמה אחרת, למה שאתם ראיתם מקודם במילון, אז נגדיר קלאס, שוב.

238
01:30:03,460 --> 01:30:33,020
אנחנו לא נתעמק בנושא של קלאס יותר מדי, זה באמת רעיון שהוא שמור לקרוס המשך, אבל עדיין תהיו איתי, זה לא מאוד מסובך, בעיקר אחרי שראיתם עכשיו מילון דיקשונריס. אז נגדיר קלאס, אתם רואים פה כתוב שטרודל דאטה קלאס, פשוט תזרמו איתי, בסדר, זה פשוט חלק מהמודול דאטה קלאס, זה מאיך שדאטה קלאס עובד בפייתון, זה ספציפית קטע כזה, תתעלמו. אני פשוט אומר, נגדיר.

239
01:30:33,280 --> 01:31:02,860
קלאס, מסוג סטודנט, ומה יש לו? שלושה, יש לו שלושה שדות, עכשיו פה ספציפית, דאטה קלאס דורש שלכל שדה, אנחנו נכתוב סוג המשתנה, שהשדה הזה אמור לייצג, זאת אומרת, כשאני מגדיר סטודנט עם שלושה שדות, נאים, אינגר גרייד ומאף גרייד,

240
01:31:02,860 --> 01:31:31,720
אני אומר בצורה מפורשת, נאים נקודתיים, str, אינגר גרייד נקודתיים, אינט, מאף גרייד נקודתיים, אינט, אני אפילו כותב לו דפולט ואליו, כמו שאתם רואים, לא חובה, אבל כן חובה שאני אכתוב את הסוג משתנה, למה זה טוב? תראו, אתם כבר יודעים שפייתון, בעקרון מאוד מאוד מוטאבילי בקטע הזה, ומבחינת פייתון, שמשתנה זה לא דבר קדוש.

241
01:31:31,720 --> 01:31:41,260
או סליחה לא שם משתנה כן דבר במרכאות קדוש אבל סוג התוכן שבפנים לא כזה קדוש לא כמו בספות תכנות אחרות.

242
01:31:41,260 --> 01:31:48,060
אבל פה בדאטה קלאס מכריחים אתכם ממש סינטקטית מכריחים אתכם לכתוב סוג המשתנה.

243
01:31:48,060 --> 01:32:01,620
כדי לפחות תדעו מה הפואנטה של כל שדה. למה למה הוא נועד לאיזה סוג של ערך הוא נועד. אז בואו נסתכל על זה. בהנחה שהגדרנו דאטה קלאס מהסוג הזה.

244
01:32:01,620 --> 01:32:23,020
אנחנו יכולים להתחיל כאלה קלאסים, ליצור משתנים מסוגים של הקלאס שהגדרנו. אז תראו נגדיר סטודנט 1 שווה קלאס סטודנט ונהתחיל אותו עם שם אלון, אינג גרייד 95, מאט גרייד 100.

245
01:32:23,020 --> 01:32:52,940
אנחנו יכולים להתחיל סטודנט, קלאס סטודנט, עם השם ניר, עם אינג גרייד 100, וזהו, ואז הדיפולט ואליו של מאט גרייד ייכנס לכאן. אז אם באמת נתפיס עכשיו, נעשה פרינט סטודנט 2, זה פשוט הולך להתפיס לנו את כל הקלאס הזה. סטודנט סוגריים, נעים שווה ניר, אינג גרייד שווה 100, והמאט גרייד הדפולטיבי 80. בואו נראה, אשכם את זה גם פה בווי אס קורד.

246
01:32:52,940 --> 01:33:22,860
אני רוצה להאמין, יש לכם, אז הנה, תסתכלו איך אנחנו יכולים להדפיס, וגם ספוילר קטן, איך אנחנו יכולים להדפיס ציון, לא ראיתם את זה, איך אנחנו יכולים להדפיס נניח עכשיו שדה ספציפי של הקלאס הזה, של מישהו, אז אני עושה פרינט סטודנט 1, הנה הוא, נקודה מאט גרייד, השדה המאט גרייד. זהו.

247
01:33:22,860 --> 01:33:28,140
אז זה באמת הולך להדפיס את ה-value שם, אז הנה עכשיו אני רוצה להראות לכם את זה ב-VS-Code.

248
01:33:28,880 --> 01:33:48,280
Run cell, אז הייתה פה את ה-import של ה-data class, הגדרנו את הstudent, הגדרנו student1 וstudent2, הדפסנו student2, הנה הוא, הדפסנו שדה ספציפי משטudent1, הנה ה-value, עובד כמו שציפינו.

249
01:33:48,560 --> 01:34:18,300
עכשיו, הקטע הזה בדאטה קלאס בפייתון זה שאומנם הוא מכריח אתכם, הוא מכריח אתכם לכתוב בהגדרה של הקלאס, הוא ממש מכריח אתכם לכתוב בהגדרה את סוג המשתנה, כמו שמעתי לכם מקודם, טיפוס המשתנה לא נאכף, פייתון לא הכל קדוש, אז תראו קטע, student1 וstudent2.

250
01:34:18,820 --> 01:34:47,880
1.1, 95% מה זה 1.1, לא אמרנו שזה צריך להיות סטרינג? אז פייתון לא התנגד, תסתכלו. הנה אני אעשה פה קליר, פייתון זה a bit too flexible, אנחנו יכולים לכתוב את זה וזה יעבוד, יריץ את זה, run cell, הנה 1.1 הזה, 1 פסה עבד. עכשיו, יותר גרוע, מה עוד קורה? אפשר אפילו,

251
01:34:47,880 --> 01:35:16,860
תסתכלו, אפשר לקחת קלאס כזה, אפשר אפילו לכתוב משתנה מסוג קלאס ספציפי, נקודה, שדה שלא קיים, שווה ערך כלשהו. ואתם יודעים משהו? זה עובד, וזה אפילו לא יודפס. זאת אומרת, זה אפילו לא יהיה שם. אתם קולטים את השיטוט הזאת, תראו, הנה, שוב, זה הקלאס student, עכשיו נגיד.

252
01:35:16,860 --> 01:35:46,860
סטודנט 2 נגדיר אותו ככה ואז סטודנט 2 נקודה שדה שלא קיים שווה טרו ונדפיס זה לא ידפיס את השדה הזאת. אז אני יודע, זה נראה מוזר. למה אתה מלמד אותנו, שימוש במודול שאפילו לא עובד בצורה קשוחה? אז התשובה היא: אנחנו מלמדים אתכם פה את הצורה הזאת של data class, נהו רק כדי לראות בצורה ויזואלית איך הרעיון של

253
01:35:47,260 --> 01:36:07,500
רשומה של סטרוקט יכול לראות בשפת תכנות, עכשיו אם היינו לומדים פה משהו כמו C, אז ב-C הדבר הזה היה עובד בצורה הרבה יותר נוקשה ושעובדת, אבל בסדרנו, אנחנו לומדים פייתון, אז לומדים גם אידיוסינקרטיות כזאת, בסדר.

254
01:36:07,500 --> 01:36:36,580
לא ביג דיל, אנחנו בעיקר רצינו לראות כאן שתי דרכים שונות, לראות דרך לשמור מידע וסדות לאותו מידע, זאת אומרת מישהו ומידע שקשור אליו, בתור דוגמה. אז יש לנו כאן תרגיל שממש מבקש מאיתנו לפתור את זה בשתי דרכים, גם אם זה לא כתוב פה.

255
01:36:36,580 --> 01:37:06,220
הוא אומר לנו תכתוב פונקציה שנקבלת רשימת סטודנטים, והפונקציה מדפיסה את שמות של כל הסטודנטים שממוצע הציונים שלהם 185. ואנחנו יכולים לממש את זה בשתי הדרכים, צורה של דיקצ'ינרי וצורה של דאטה קלאס. ואתם רואים פה פתרון שעושה את זה לשניהם. אז נניח, אם היינו עובדים עם רשימה של דיקצ'ינריס, מהסוג הראשון דרך אגב, לא מהסוג השני, זאת אומרת, סוג הראשון התכוונתי.

256
01:37:06,220 --> 01:37:36,220
זה רשימה שמכלה דיקצ'ונרי, קיא ואליו, קיא וואליו, קיא וואליו, זאת אומרת רשימה של שלושה דיקצ'ונריז, לא דיקצ'ונרי של דיקצ'ונריז. אז איך תרגיל לזה נראה? פשוט מאוד. אנחנו עוברים על הרשימה, פור סטודנט ברשימת הסטודנטים, נגדיר אבלג' שווה סטודנט נוכחי בקיא, אין גריד

257
01:37:36,220 --> 01:37:51,220
אז תביא את הvalue שמה, את הvalue של הסטודנט הנוכחי בכי n grade ועוד הvalue של הסטודנט הנוכחי בכי math grade חלק כ-2 אז כאילו נחשב בממוצע, ובממוצע גדול משוני ב-5 נתפיס את השם שלו.

258
01:37:51,220 --> 01:38:20,220
אוקיי, באותה מידה, אנחנו יכולים לעשות את זה לפי הדאטה קלאס שלך שבדיוק עכשיו ראינו, למדנו, שבתכלס אם אתם עוד פעם רוצים לדעת אבל למה דאטה קלאס, מה זה עוזר? התשובה היא כי הסינטקס של דאטה קלאס מזכיר קצת את הסינטקס של קלאסים אמיתיים שאתם תכירו בתכנות מונחי עצמים בהמשך הדרך. זה למה? רצינו שתראו משהו שייראה לכם דומה אחר כך.

259
01:38:20,220 --> 01:38:49,920
אז פתרון בדאטה קלאס די פשוט. for סטודנט ברשימת הסטודנטים נגדיר average שווה סטודנט נקודה end grade ועוד סטודנט נקודה math grade כל זה חלק כ-2. ואז אם זה ממוצע ב-185 אתה ספרינט סטודנט נקודה name. אז זה לא קודם כל מורכב ובאמת אם אני עכשיו אביא אתכם לפתרון השאלה אתם תראו למעשה.

260
01:38:49,920 --> 01:39:19,820
שרוב הקוד כאן זה רק להביא את כל מה שדרוש כדי שזה ירוץ אז אני מביא את הדאטה קלאס מביא את ההגדרה של סטודנט. מביא רשימה של סטודנטים בדיקצ'נריז. יוצר רשימה של סטודנטים בדאטה קלאסים. אפילו עושה פה Enter כי אני רוצה שזה יראה לכם אותו דרך. ככה אתם רואים סטודנט של זה סטודנט של זה סטודנט של זה.

261
01:39:19,820 --> 01:39:31,620
ואז אני מריץ את שתי הפונקציות השונות על שני מביני נתונים השונים. אגב, מבט חטוף, בוא נראה. מכאן היא ממוצע של יותר מ-85.

262
01:39:31,620 --> 01:39:59,320
האלון הזה כן, הניר הזה לא, דנה הזאת כן, הלאה. שרון הזה כן, ירון. בוא נראה, 100 וגם 80 אמרנו דפולט ואליו אז יהיה 90 אז גם ירון כן, דוב לצערי לא אז בואו נריץ את זה. רנצל. אלון, דנה, שרון וירון. וואלה נכון? איזה קטע?

263
01:39:59,320 --> 01:40:29,320
אוף דקשנריז ואפילו דאטה קלאס בפייתון אתם תראו הרבה שימוש בדקשנריז אני מאמין יותר מאוחר כי דקשנריז פשוט מבנה נתונים בסיסי בפייתון שהוא גם איש מאוד דאטה קלאס לא יודע אם תיפגשו בו בהמשך הדרך אבל אתם עדיין תכירו תכנות מונחי עצמים זה כן ולבסוף סתם שאילך אביבה נגדיר דקשנריז

264
01:40:29,320 --> 01:40:51,040
את הקלאס מסוג קליינט עם שדה פרודקט מסוג רשימה נגדיר רשימה. עם מיבR יחיד מעחוזת שהערך של הזה מילק. עכשיו נגדיר, C1, אתה קלאס קליינט והוואליו שלך יהיה פשוט הליסט הזה.

265
01:40:51,060 --> 01:41:21,060
זאת אומרת, c1 הוא עכשיו משתנה מסוג קליינט עם הליסט הזה בתור ערך השדה שלו של פרודקטס. ואז אנחנו בסוף אומרים: c1.product, הליסט שלך, .append, אימוד עבר: קופי. ואז אנחנו נרצה להדפיס את הליסט הזה, רגע איזה ליסט? זה? או שc1? מה יקרה פה? תראו מה קרה! אמרנו c1 אתה עכשיו קליינט על...

266
01:41:21,060 --> 01:41:40,600
על גבי הליסט הזה, זאת אומרת, אתה עכשיו קליינט והליסט הזה הוא שדה שחשר פרודקט, זה אותו ליסט או שזה יהיה ליסט אחר, אובייקטים או אופרטו אי.די, הלו, מה יקרה פה, אז בואו תגלו. עכשיו הולך לשאלה 8, הנה היא. הנה הדאטה קלאס הגדרה שלו, הנה הליסט.

267
01:41:45,600 --> 01:42:12,980
בנינו את C1 להיות קלאס קליינט על גבי הליסט הזה ואז עשינו דרך C1 היה פנד לליסט שלו עם ה-string copy, ואז אנחנו רוצים להדפיס את ליסט מה יקרה? זה ישנה את ליסט. אז כן ליסט עכשיו קיבל את הקופי הזה.

268
01:42:14,260 --> 01:42:44,000
זאת אומרת במקרה שזה לא היה ברור, אני אפילו אוסיף לכם פרינט נוסף כזה, yes, that means that, עכשיו נכתוב, פרינט בסוגריים, ככה, listid is, פסיק id של ליסט, פרינט, עכשיו בסוגריים, and also, C1 נקודה.

269
01:42:44,000 --> 01:43:05,500
פרודקטס איי-די איז, הנה נסגור את זה. C1 נקודה פרודקטס, עכשיו כל זה אני מקיף ב-id. בבקשה, נריץ אותך. זאת ה-id.

270
01:43:09,240 --> 01:43:23,020
Well, the more you know. אמממ תודה רבה שנשארתם לכל התרגול הזה, שהקלטה שלו נגמרה ברבע לשש בבוקר. Oh god, what am I doing with my life? נתראה שבוע הבא.

