1
00:00:00,000 --> 00:00:12,080
היי, ברוכים הבאים לתרגול הרביעי של הקורס מבוא למדעי המחשב. נושא התרגול היום יהיה על רשימות, עוד קצת על מחרוזות, ואפילו מבוא לפונקציות.

2
00:00:12,080 --> 00:00:36,540
אם אתם זוכרים, בתרגול הקודם, אחד מהתרגילים שעשינו היה לחשב סכום של מספרים שאותם אנחנו קלטנו בלולאת ווייל כזאת של פקודת אינפוט עד לרגע שבו היה לנו מספר שלילי, זה שבר את הרצף ואז חישבנו ומצאנו את הסכום של כל מה שהיה חיובי בדרך לשם.

3
00:00:36,540 --> 00:00:41,380
אבל בואו נגיד את האמת. הרבה פעמים אנחנו רוצים לשמור.

4
00:00:42,020 --> 00:01:12,020
כמה דברים, זאת אומרת, אנחנו נרצה לא רק משתנה עבור ערך אחד, אלא נרצה אולי כביכול משתנה שיהיו לו כמה ערכים, אולי יש להם קשר, אולי יש סיבה, ובכן, בשביל כזה דבר, ובשביל שלל רב נוסף של סיבות אחרות, יש לנו רשימות אז הנה כאן אנחנו רואים דוגמה פשוטה לרשימה בפייתון, יש לנו רשימה שקוראים לה א..

5
00:01:12,020 --> 00:01:42,020
lst, והערך שלה הוא שלושת העברים הבאים, יש לה ערך אחד, ערך שתיים וערך שלוש, אז אוקיי, איך רשימה עובדת? מה אנחנו יכולים לעשות איתה? רשימה יכולה להיות רקע, זאת אומרת יכולים להיות לה כלום מעברים, האם לרשימה יש גודל מקסימלי כלשהו? הממממ,  האם רשימה יכולה או איליה בכלל להכיל ערכים מסוגים שונים, כלומר אם פה אנחנו יכולים לדוגמה של רשימה

6
00:01:42,020 --> 00:02:12,020
שיש לה את הערך אחד, אחר כך שתיים, אחר כך שלוש, ברור לנו שזה אותה סוג של ערכים. אבל אולי יכול להיות רשימה עם סוגים שונים של ערכים, כמו סטרינג, אינטג'ר, פלואוט, אז דבר דבר. קודם כל, רשימה בהחלט יכולה להיות ריקה, כלומר, יכול להיות לנו משתנה מהסוג ליסט, והוא יכול להיות ריק, וגם יכול לגמרי להיות

7
00:02:12,020 --> 00:02:42,020
לנו משתנה מסוג ליסט, והתוכן שלו זה איברים מסוגים שונים. אם אהה..אתם רוצים לראות את זה בעיניים, בוא תראו, אני פותח כאן פייתון, נגדיר. לדוגמה, אני אומר ליסט שווה רשימה רקע, ועכשיו אני רוצה להדפיס, ממש בליסט, אז כמו שאתם רואים, פקודת הפרינט הדפיסה לנו, רשימה רקע, עכשיו אני אומר, ליסט, אתה מכיל את האיבר 1, 3.2, ה..סטרינגס.

8
00:02:42,020 --> 00:03:10,480
היי, ובוליאן פולס, עכשיו אני אומר מה יש בליסט? בדיוק מה שאמרנו ותאמינו לו, אלו אכן ארבעה איברים שונים שהם כולם נמצאים ברשימה. עכשיו, זה כשלעצמו לא אומר לנו הרבה מה אנחנו יכולים לעשות עם ליסט? לדוגמה, איך ניגש לאיבר כלשהו ברשימה?

9
00:03:10,480 --> 00:03:40,480
אז אחד מהדברים שאנחנו עושים והאמת שלא רק בפייתון אלא בכמעט כל שפת תכנות שאתם יכולים לחשוב עליה, אנחנו נעזרים ברשימה מבחינתנו בתור בסיס, כלומר אנחנו רוצים לגשת לאיבר כלשהו ברשימה, אז נגיד רשימה סוגרי מרובעות מספר כלשהו, מה שנכתוב בסוגריים מרובעות זה כאילו האינדקס, זה האופסט, זה...

10
00:03:40,800 --> 00:03:45,280
מספר האיבר שמעניין אותנו כאן ספציפית

11
00:03:45,280 --> 00:03:57,480
אז אם לדוגמא היינו רוצים לגשת לאיבר הראשון של רשימה, לדוגמא ליסט, היינו באמת כותבים ליסט סוגריים מאורבעות, 0, מה הכוונה?

12
00:03:57,480 --> 00:04:10,240
אנחנו רוצים את האיבר באופסט 0 של הרשימה, וכשאנחנו כותבים את השם של הרשימה, אז הדבר הברור מאליו...

13
00:04:10,240 --> 00:04:39,840
זה שאנחנו מתייחסים לרשימה מהאיבר הראשון שלה, זאת אומרת רשימה פלוס 0 התקדמות, אז מבחינתנו ליסט באינדקס 0 זה למעשה האיבר הראשון של רשימה, אז הנה בואו נחווה את זה קצת על הבשור שלנו, נגיד באמת מה שכתוב שם ליסט שווה 1,2,3, ואכן זה המצב, ליסט באינדקס 0 זה האיבר...

14
00:04:40,160 --> 00:05:09,500
הראשון, ליסט באינדקס 1, זאת אומרת זה ליסט, ליסט פלוס אופסט 1, עכשיו כשאתם מסתכלים על זה, אולי נדלקה לכם איזושהי נורא, רגע, ליסט ואז פלוס אופסט, זאת אומרת באמת להגיד רשימה או שם של הרשימה או מה שזה לא יהיה, הכוונה היא בעצם כזה מבט שמתחיל מהאיבר הראשון, וזה נכון.

15
00:05:09,500 --> 00:05:39,020
ואולי יותר מאוחר כשאנחנו נדבר על זיכרון ודברים כאלה, אז בכלל אתם תחושו את זה בצורה אפילו יותר אינטואיטיבית, אבל בינתיים נשאיר את זה ככה, אתם רוצים לגשת לאיבר כלשהו ברשימה, אז אתם אומרים שם הרשימה, סוגריים מרובעות, מספר שזה כאילו מה שאתם מחברים לאינדקס, נקרא לזה למספר בתור של האיברים.

16
00:05:39,020 --> 00:06:09,020
אז מבחינתנו ליסט פלוס האינדקס 0, סליחה, ליסט באינדקס 0 זה פשוט העבר הראשון של ליסט ועוד מה שזה לא יש אתם כותבים כאן, מבחינת הסדר שלהם בתור. אולי אני גורם לזה הישמע מסובך מידי. איך לדוגמה היינו ניגשים לעבר האחרון, אז מה אנחנו יודעים? יש לליסט הזה שלושה איברים, זה באינדקס 0, אחר כך האיבר הבא בתור באינדקס 1, והאיבר

17
00:06:09,020 --> 00:06:39,020
האבר האחרון כאן הוא ב index 2 אז לחלוטין, אנחנו יכולים לכתוב את זה בדיוק כמו שראיתם list בindex 2 יביא אותנו לאבר האחרון כי זו רשימה של שלושה אברים אז ראיתם את זה? היה לנו את הליסט במקום 0, ליסט במקום 0 ועוד 1 זה 1 זה האבר כאן, ליסט במקום 0 ועוד 2 אז 0

18
00:06:39,020 --> 00:07:09,020
1,2 מיוביל אותנו לאיבר השלישי של הרשימה, אז זה חשוב, זה טוב וזה שימושי להבין את הספירה של האינדקסים. אז כרגע מה יקרה באמת אם נכתוב ליסט באינדקס 3? אני מזכיר לכם, האינדקסים של הרשימה הזאת, הם 0, 1 ו-2, מה יש ב 3? אז למעשה אין.

19
00:07:09,020 --> 00:07:39,020
הרשימה שלנו היא באמת באינדקסים שבין 0, 1 ו-2 ולכן אינדקס 3 הוא פשוט מחוץ לטווח, האינדקסים של הרשימה, זה לא נמצא ברשימה, אין לזה אינדקס ערעור כמו שפייתון כותב לכם. אוקיי, הגדרנו רשימה, אולי אנחנו רוצים להוסיף לאיברים, הרי לא בכך סיימנו את העבודה שלנו, מה נעשה? בפייתון ובהרבה ספורטיקנות אחרות…

20
00:07:39,020 --> 00:08:09,020
יש פקודות שעושות את זה קל מאוד, לדוגמה: הגדרנו את הליסט הזה ונניח שאנחנו רוצים להוסיף לו סתם דוגמה הליסט הזה איכשהו נוסיף לו גם את הערך ארבע, אז כמו שאתם רואים כאן במצגת אנחנו יכולים להגיד list נקודה append כלומר תוסיף בסוף את הערך ארבע, עשינו את זה ועכשיו כפי שאתם רואים ליסט מחשב רשימה של ארבעה איברים.

21
00:08:09,020 --> 00:08:23,700
אינדקס 0, 1, 2 ו-3, אם עכשיו אני אכתוב ליסט באינדקס 3, הינה הערך שבדיוק הוספנו. הפעם זה עובד.

22
00:08:24,900 --> 00:08:38,460
דרך אגב, הידעתם, אנחנו גם יכולים להוסיף לתחילת הרשימה, איך נעשה את זה? אני לא אגלה לכם עכשיו, אבל ככל שנמשיך את התרגול, אתם בהכרח תראו אופרטורים.

23
00:08:38,460 --> 00:09:08,360
אופרטורים ודברים שיאפשרו לכם להוסיף איבר להתחלה של הרשימה. אני אחזור לזה אחר כך. בינתיים, מה אם אנחנו רוצים לבנות רשימה חדשה שיש בה אלף איברים? ממש ככה, רשימה, בוא נגיד את זה ככה, אני רוצה עכשיו לבנות רשימה שהיא מורכבת בדיוק מאלף פעמים אפס. איך נעשה את זה? אז בואו תראו קטע מגניב. מה אם אני אומר, עכשיו, לייסט.

24
00:09:08,360 --> 00:09:36,460
list 1 שווה ל... תראו את זה, סוגריים מרובעות, 0. עכשיו, מה שאני כתבתי פה זה רשימה עם איבר 1, אני חוזר על זה שוב, זה רשימה עם איבר 1, והאיבר הזה שבפנים הוא 0. אני כותב את זה, כפול אלף.

25
00:09:36,460 --> 00:10:06,080
אז אני לא יודע אם אתם זוכרים מה שדיברנו על מחוזות בתרגול קודם, הקטע הזה של שירשור אחד אחרי השני, אחד אחרי וכולי וכולי, אבל אם אני אכתוב את זה, עושה פה Enter, ועכשיו אני אבקש מפייתון פשוט להגיד לי מה יש בליסט 1, אופה, אני אסגור את המגניפייר, תראו מה הוא פתח לי, הוא הדפיס לי רשימה, כלומר הוא פתח אותה בסוגריים מרובעות, ויש פה, תאמינו לו,

26
00:10:06,080 --> 00:10:35,380
אלף פעמים איבר בערך 0, יש פה באמת אלף פעמים איבר של 0. אפשר להגיד שככה בניתי רשימה שהיא אלף פעמים הערך 0. וטוב, פה אתם רואים שלוש נקודות, אבל במציאות פייתון לא התבייש, לפחות כאן הוא לא התבייש, ביקשתי ממנו את זה. עכשיו בטח אם אני אכתוב לו פרינט ליסט 1, אתם חושבים שאולי פה הוא כן יתבייש?

27
00:10:36,200 --> 00:10:46,700
לא, הוא לא הדפיס את כל אלף האפסים. טוב, עכשיו אתם יודעים, אנחנו בהחלט יכולים לבנות רשימה בהורך ענק, אם רק רצינו.

28
00:10:48,040 --> 00:10:57,260
ואתם ראיתם עכשיו כפול, אתם ראיתם מקודם אפנד, האם יש עוד אופרטורים לליסט? כן, בהחלט יש.

29
00:10:57,260 --> 00:11:08,580
אני חושב שהרבה מאופרטורים ראיתם בהרצאה, אבל אל תדאגו, לאורך התרגול אנחנו נראה עוד כמה אופרטורים, ובאופן כללי אתם תראו שיש הרבה דברים שאפשר לעשות עם רשימה.

30
00:11:10,580 --> 00:11:26,140
בואו נעשה ניסיונות עם רשימה, נניח שאנחנו רוצים ליצור רשימה שיש לה את המספרים הזוגיים שבין אחד לאלף, עכשיו כשאני אומר כזה דבר, אתם אולי נזכרים בריינג' נכון? הרי למדנו משהו על טווח.

31
00:11:26,140 --> 00:11:55,480
אם היינו מקבלים שאלה בתרגול הקודם שהייתה אומרת לנו תיצרו, כאילו תגדירו טווח של המספרים הזוגיים בין אחד לאלף, אז אתם אומרים אוקיי, אז המספר הזוגי הראשון הוא שתיים. אם אנחנו רוצים כולל אלף, אז אנחנו נרצה שהריינג' ייגמר באלף פלוס אחד, כן? ואומרים לנו כל המספרים הזוגיים, מלכתחילה אנחנו נעשה קפיצות של שתיים. ולמעשה...

32
00:11:55,480 --> 00:12:25,320
אנחנו יכולים להגדיר כזה דבר, אני יכול להגיד ריינג' שמתחיל בשתיים, נגמר באלף ואחד, לא כולל, קפיצות של שתיים. יופי. אבל מה הטייפ של כזה דבר, כן? הרי זה ריינג'. אבל מה אם אנחנו רוצים לקחת את הטווח הזה, ולהפוך אותו לרשימה? אז אני אגיד לכם כזה דבר, אנחנו נגדיר משתנה שיהיה, נאמברס שיהיה.

33
00:12:25,320 --> 00:12:55,320
גרסת ליסט של הריינג' הזה 2001-2000-2002 ועכשיו מה יש בנאמברס תראו זה כבר לא ריינג' זה רשימה ורק שיהיה לכם ברור מה זה טייפ של נאמברס הוא למעשה ליסט אז כך אנחנו יכולים להרים את זה (ובית רץ בריא להציע ולהוריד אותה) זאת

34
00:12:55,320 --> 00:13:25,320
חמיר טווח להיות רשימה. אז אולי כשלמדנו על טווח וחשבתם לעצמכם רגעאבל, זה רשימה, זה מערך, זה... אז... לא בדיוק, אבל ככה אנחנו יכולים להפוך את זה לרשימה, בעזרת אופרטור "המרה", לרשימה. עכשיו רשימות, אני בטוח שאתם לא שכחתם כל כך מהר כשעשינו - ליסט אחד היה שווה...

35
00:13:25,320 --> 00:13:40,100
רשימה שיש לה ערך אחד והוא 0 כפול 100. זה בעצם חיבור של רשימות, תאמין או לא. פשוט זה היה חיבור של רשימה עם עצמה אלף פעמים, אז בואו ניקח את זה

36
00:13:40,100 --> 00:13:55,220
לפלוס. מה קורה כשאנחנו עושים פלוס? אז תראו. זוכרים שאמרנו משהו על איך אפשר לחבר איבר להתחלה של הרשימה? אז אחת מהדרכים לעשות את זה, לא הייתה דרך היחידה, אבל אחת מהן..

37
00:13:55,220 --> 00:14:25,020
זה לעשות כזה דבר. הנה הרשימה שלנו ואנחנו אומרים רשימה, את עכשיו הולכת להיות הרשימה שמכילה את האיבר 4 ועוד מה שיש לך. ולמעשה כך אנחנו בעצם הוספנו איבר לתחלה של הרשימה. אז כמובן שלכם ראו הדבר הזה, הנה בואו רק ננקה לכם קצת את החלון. הדבר הזה עובד בהרבה כיוונים, כן? אני יכול להגיד.

38
00:14:25,020 --> 00:14:54,920
ליסט שווה לרשימה שמכילה את האיבר 1 ועוד הרשימה שמכילה את האיברים 2, 3, 4 ועוד מה אני יכול לעשות כדי שזה יראה לכם יצירתי? אני יכול להגיד ליסט של הריינג' של נאמר האיבר 5 עד 11.

39
00:14:54,920 --> 00:15:24,920
האם זה יעבוד לי? מה יש בליסט? הופה, הנה אחד מוגדר לנו פה, 2, 3 ו- 4, שזאת הרשימה שנתתי אותה כקבועה, מה זה קבועה? סליחה, נתתי אותה רשימה פה, ואז אמרתי, התוצאה של ליסט מתוך הריינגז של 5 עד 10 כולל, והנה זהו.אם אתה בריא לנפש מישהו, בזמן אני רוצה להראות אותו נמצא שאתה צריך להתרמקם ניו דוץ טיפה, מבחינה תייצד אותו וץ רק לקחת גם נחניה בגלל בתמונת חברתי של חוק או הכ‫צריך..מני לא שנאדם לבוא.הפורמון שאנחנו

40
00:15:24,920 --> 00:15:40,720
אני יכול להגיד עכשיו לייסט שתיים שווה באמת לליסט של ריינג של 11 עד 21 לא כולל, מגניב, ואז ליסט 3 שווה ליסט ועוד ליסט 2.

41
00:15:40,720 --> 00:15:49,060
האם זה יעבוד? כמובן שזה יעבוד. אז, כן. אנחנו בהחלט יכולים לחבר רשימות אחת את השנייה.

42
00:15:51,400 --> 00:16:16,080
מה לגבי אורך של רשימה? אולי אנחנו צריכים לדעת פשוט כמה מספרים יש ברשימה? אין בעיות? תגידו לי. הנה רשימה שיש לה את כל המספרים בין 1 ל-20. אז זה רשימה של 20 עיוורים, נכון? אז, לנג, שזה קיצור של לנגף, אורך, לן של ליסט 3, שווה 20. פשוט וקל.

43
00:16:18,900 --> 00:16:48,900
מה לגבי, האם האיבר כלשהו נמצא ברשימה? עכשיו תקשיבו, השאלה הזאת, יש לה הרבה יותר משקל ממה שאתם יכולים לדמיין. כי זאת שאלה של חיפוש. עכשיו, בשלב הזה של הקורס, עוד לא דיברנו על דברים מסובכים כמו מיון וחיפוש, אז אני רק אגיד לכם מראש, זה שאנחנו עכשיו הולכים לראות...

44
00:16:49,700 --> 00:17:00,540
במכורת אופרטור או פונקציה שעושה את זה בקלות, זה נחמד. אבל תדעו לכם שבמציאות זאת בעיה יותר מורכבת ממה שזה יכול להישמע.

45
00:17:00,540 --> 00:17:10,420
אוקיי, עכשיו שנתתי את הכבוד הדרוש, בואו נמצא, אם האיבר מסוים נמצא ברשימה, בפייתון זה קל מאוד. יש לנו את האופרטור אין.

46
00:17:10,420 --> 00:17:22,500
עכשיו, אתם בטח זוכרים את אין, כשכתבנו משהו כמו for i in, לא יודע, ריין של 1 עד 10, וכולי וכולי, אתם בטח זוכרים את זה, כן?

47
00:17:22,500 --> 00:17:40,380
זה כאילו הדרך שלנו לעשות לולאה לכל i, יהיה לנו אינדקס, בין הטווח הזה שמתחיל ב-1 עד כך, וגם בקיצור אתם זוכרים. אז לאופרטור אין יש הרבה שימושים. אז פה, אתם רואים לדוגמה, נתנו הגדרה לרשימה, ואז אמרנו תדפיס את...

48
00:17:40,380 --> 00:18:09,760
אם 1 נמצא בליסט, ואחד באמת היה בליסט, אז הוא התפיס true. פה, לדוגמה, 3, לא בליסט, הוא התפיס false. אז במקרה שלנו, אני יכול לכתוב, האם 7 הוא בליסט 3? כן, הנה 7. האם 30 בליסט 3? לא, הוא לא. אוקיי.

49
00:18:10,740 --> 00:18:39,740
עכשיו, ברור לנו שהרבה פעמים, אנחנו לא סתם נרצה רשימות קבועות, אולי אנחנו רוצים לשנות רשימה? זאת אומרת, לא רק להוסיף לאיברים, אנחנו רוצים לערוך ב-i ערך שיש ברשימה. רוצים לשנות משהו שיש בתוך הרשימה. לדוגמה, איך נוסיף 1 לאיבר הראשון? אז אנחנו יכולים בעזרת גישה.

50
00:18:39,740 --> 00:19:09,740
לעבר באינדקס ספציפי של רשימה? אז תסתכלו בליסט שלוש שלנו. מה אם אני רוצה דווקא להחסיר אחד מהעבר הראשון שם? אני אכתוב עכשיו ליסט שלוש באינדקס אפס מינוס שווה 1 אוקיי, והאם זה שמר את השינוי בליסט שלוש? וואלה כן, זה שמר. אז בואו רק...

51
00:19:09,740 --> 00:19:39,720
נחזיר אותו חזרה, נעשה לו פלוס שווה 1, הנה ליס 3, החזרנו אותך חזרה לחיים, איזה יופי. עכשיו, מן הסתם שהמינוס שווה פלוס שווה זה לא דרך היחידה, אני לגמרי יכול לעשות ליס 3 באינדקס 0 שווה ליס 3 באינדקס 0 כפול 0, מותר לי, ברור שאיפסתי לו.

52
00:19:39,720 --> 00:19:52,280
אוקיי, אוקיי, בוא נחזיר אותך להיות אחד. בסדר? אני מקווה שאתם כבר מצליחים לאט לאט לעקוב אחרי מה שאנחנו עושים פה, הוא לא פשוטות.

53
00:19:52,360 --> 00:20:09,380
נניח שאנחנו רוצים לכתוב קוד שקולט מהמשתמש את התו y או את התו n, כלומר התוכנית שואלת את המשתמש שאלה והמשתמש עונה yes או no, אז הקוד שלנו צריך להיות קוד פשוט, סתם לקלוט input מהמשתמש שלנו, והמשתמש אוהב את המזמין להוסתיר קוד פשוט לעצור האיזה הפרסם שלנו.

54
00:20:09,380 --> 00:20:39,000
מה משתמש, אם לא כתבנו y או n אז אנחנו נדפיס סמייל יצאו, זה לא קוד קשה, בעיקר לא אם יש לנו את האופרטור אין, כי מה שאנחנו יכולים לכתוב זה דבר כזה טריוויאלי, נגיד הסטרינג אנס שזה קיצור לאנסר הוא יהיה מה שהמשתמש יקליט באינפוט ששואל אותנו do you love python? ומה שאנחנו נגיד אם התשובה לא נמצאת

55
00:20:39,000 --> 00:21:09,000
ברשימה שמכילה את ה-character y או את ה-character n אז נדפיס smiley עצוב, אוקי אז אני מקווה שאתם מבינים למה זה עובד. נניח אני באמת אריץ את הקוד הזה שאתם רואים כאן - do you love python? אם אני כותב באמת את הטוב y אז מן הסתם ש-y הוא אחד מהאיברים שנמצאים פה כן? כי עכשיו כשאני לוחץ על ה-p y אז זה אומר שאני יודע רק שפתאום אני מאמינה שחכה שאני לא חושב שאני96 לא א�צם אופקיץ מישהו. תסתכל על רשות ה-fb שמידעו יותר-שמשמעתו נגלה מום שלאובן חדש שלך וממשיך למעלה

56
00:21:09,000 --> 00:21:39,000
הenter לא יישמר לתוצאה answer, enter זה שאני לוחץ על enter במקלטת זה רק יעצור את האינפוט אבל הקלטתי את y אז אני לוחץ enter וזהו הוא גמר. עכשיו אני אריץ את הקודש שוב אולי אני אכתוב לו n I don't like python אבל זה אחד משני איברים פה, אז הוא בסדר גמור עם זה עכשיו אני אקליד לו qwe yy

57
00:21:39,000 --> 00:22:09,000
והן לא נמצאים בסטרינג הזה. 죽זה עצוב. אני מקווה שתבינים, אנחנו כתבנו תווים על מקלדת, אם הם נמצאים, זאת אומרת אם משהו מהתווים של קלדמן נמצא פה, אז יופי. אבל אם לא, אז הדפסנו אסמיילי עצוב. האמת שיש גם דרך אחרת לעשות את זה. בערך, סוג של, מה שנקרא. עכשיו אנחנו אומרים, אם ה-answer הוא לא בתוך

58
00:22:09,000 --> 00:22:39,000
string yn אז אתם רואים כאן את ההבדל פה אמרנו רשימה עם שני תווים y וn פה אמרנו מכרוזת yn עכשיו בואו נריץ את הקוד הזה, אני עכשיו אריץ את זה פה בתוכנה מפרדת וגם פה אני אכתוב את אותו דבר בדיוק why התו成eline y הוא כן במכרוזת הזאת, נריץ את זה שוב n

59
00:22:39,000 --> 00:22:51,100
התו אין הוא כן במחוזת הזאת אבל בואו תראו הבדל חמוד, נניח שאני שוב אריץ את זה ופעם לכתוב

60
00:22:51,100 --> 00:23:19,660
yn, תסתכלו טוב כתבתי כאן את התו y את התו n ברצף כלומר אני הולך להזין את המחוזת yn. אבל היא כן בתוך ה-smiley העצוב הזה אז הוא לא ידפיס לי את הפרינטה, זאת אומרת, זה כן נמצא בתוך הסטרינג הזה אז הוא לא ידפיס את ה-smiley העצוב. מצד שני אם פה אם אני אקליד את ה-yn הזה.

61
00:23:19,660 --> 00:23:49,600
ראית מה? הוא כתב לי סמיילי עצוב. למה? כי הסטרינג yn הוא לא איבר בליסט הזה. אז מה שראינו פה זה דוגמה שצריכה קצת להדליק לכם אש קטנה של היי רגע. יש דברים קצת דומים עם מחזות ורשימות אבל דברים גם קצת שונים. יותר מאוחר בתרגול אנחנו נדבר על מחזות ואז אולי תבינו את זה יותר לאור.

62
00:23:49,600 --> 00:24:19,600
עומק. עוד דברים שאנחנו יכולים לעשות ברשימות זה כמובן אנחנו יכולים לעבור על פני רשימה זה אולי אחד הדברים הקלאסיים ביותר, אתם זוכרים שדיברנו על four בתרגול הקודם? אנחנו היינו עושים את זה עם ריינג' אבל בסופו של דבר נניח אנחנו רוצים לעבור על פני האיברים שנמצאים ברשימה אז אולי הקוד הכי אינטואיטיבי יכול להיות: הנה רשימה ונגיב: נניח

63
00:24:19,600 --> 00:24:49,600
לכל אייטם, לכל איבר בתוך הרשימה נדפיס את האיבר. באמת שזו כתיבה מאוד אינטואיטיבית. יש גם דרך אחרת לכתוב את זה למעשה, נגיד כזה דבר. לכל אינדקס בטווח שהוא בעצם אורך הרשימה. עכשיו אורך הרשימה פה כמה איברים? 1, 2, 3, 4, 5. זה כמו לכתוב פה ריינג' 5.

64
00:24:49,600 --> 00:25:04,260
ואני בטוח שאתם מבינים, ריינג' חמש, אני אכתוב לכם את זה פה בנוטפד, ריינג' של חמש זה בעצם המספרים 0, 1, 2, 3, 4.

65
00:25:04,820 --> 00:25:09,680
שזה בדיוק האינדקסים דרך אגב, אינדקס 0, 1, 2, 3, 4.

66
00:25:11,160 --> 00:25:20,520
ואז מה אנחנו אומרים? לכל אינדקס, בטווח הזה שבין 0 ל-4 כולל, נדפיס את איבר הרשימה באינדקס, אינדקס.

67
00:25:22,460 --> 00:25:40,700
אוקיי. למה אנחנו רואים את שתי השיטות האלה לעשות בעצם את אותו דבר בדיוק? אז תאמינו לו. אבל אחד מהדברים כאן הוא כתוב בצורה שהוא יותר חסכונית למחשב להריץ את זה.

68
00:25:40,700 --> 00:26:01,240
כלומר, אחד מהדברים פה, יותר, פשוט, יותר חסכוני, יותר ישיר, פחות בזבזני מבחינת כמה המחשב צריך לעבוד. יש לכם ניחוש? בעיקרון, התשובה לזה יכולה להיות מבלבלת.

69
00:26:01,240 --> 00:26:31,140
למעשה, היה כאן קטע קצר של כמה דקות בהקלטה של התרגול, שבו ניסיתי להגיד שהתשובה הנכונה היא הגרסה שבה אנחנו עושים איטרציה על הריינג' של האינדקסים, ואז עושים גישה בעזרת האינדקס לאיבר. אבל למעשה, נוצר ויכוח קטן על זה בקרב המתרגלים של הקורס, ועלו ספקות. איזו איטרציה באמת על פני רשימה?

70
00:26:31,140 --> 00:26:39,120
נותנת לנו את הגישה מהירה יותר, אז כפי שאתם ראיתם, האופציה השמאלית בשקופית הייתה:

71
00:26:39,120 --> 00:26:52,120
For Itemized overture ברשימה משהו. והאופציה האחרת שלנו הייתה: For Index ברAng של אורך הרשימה משהו.

72
00:26:53,160 --> 00:27:01,120
אבל אני רוצה שתסתכלו על שני הדברים שאתם יכולים אולי לראות כאן. זה העשרה כבר משהו.

73
00:27:01,120 --> 00:27:18,100
שאני אראה לכם, אבל זה תיקון טעות שנאמרה בביטחון רב בגרסה הקודמת של הקלטה. כפי שאתם רואים כאן, For Item ברשימה פה, בגרסה הספציפית הזאת של הקוד על המחשב שלהם, זה לקח 0.237 מילי שניות.

74
00:27:18,100 --> 00:27:48,080
לעומת זאת, להריץ For Index ברנג' שהוא אורך הרשימה, זה לקח 0.554 מילי שניות. ושימו לב שזה בכלל לא כלל את הפעולה של גישה לאייטם כלשהו ברשימה. אז אם אני ארד למטה, אנחנו נראה, הם ציירו פה גרף נחמד, שהם רואים את הגרסאות השונות של לעשות לולה.

75
00:27:48,080 --> 00:28:18,080
בעצם לעשות איטרציה על פני רשימה. עכשיו יש פה כמה גרסאות של דברים שאתם מכירים, כמה גרסאות שאתם לא, אינדקס זה פשוט האינדקס של איבר ברשימה, ואייטם זה בעצם הכוונה גישה לאיבר עצמו. מה שבעצם הכי חשוב לכם לראות, זה שלולאת ה4 שפשוט עושה אייטם ברשימה, היא בעצם עושה איטרציה באופן ישיר על איברים ברשימה, בעוד ש...

76
00:28:18,080 --> 00:28:30,100
איטרציה על פני ריינג' היא צריכה קודם כל לגשת ובעצם לקבל את הערך של כל איבר בריינג' כי ריינג'

77
00:28:30,140 --> 00:29:00,060
ואפשר לחשוב על זה בתור גרסה כזאת של זה לא באמת רשימה אבל מצד שני כשאתם רוצים לעשות איטרציה על פני ריינג' אתם חייבים בכל איטרציה לקבל ערך חדש לאיטרטור שלכם נכון? אם יש לכם לדוגמה ריינג' של 0 עד 5 אז הייתם צריכים לחשב כל פעם עכשיו אני מוצא מזה 0 ואז אני מוצא מזה 1 ואז 2 וכולי. אז בקיצור...

78
00:29:00,060 --> 00:29:22,040
אני רק רוצה להגיד, שזה לא בכך היה ברור מאליו איזו איטרציה הייתה מהירה יותר, ולמעשה ייתכן שדווקא איטרציה של four item in list עלולה להיות האיטרציה המהירה והיעילה ביותר, לפחות בפייתון, תדעו.

79
00:29:22,040 --> 00:29:52,000
יש עוד פעולות שאנחנו יכולים לעשות ברשימה, בעיקר בשפות נוחות כמו פייתון, אנחנו יכולים בעזרת פונקציות קיימות, בטח לקבל את האיבר המקסימלי ברשימה, או לבנות סכום מהרשימה, קל מאוד. נניח יש לנו רשימה פשוטה, שני איברים, אז בהחלט פונקציית מקס, תחזיר לנו את האיבר בערך המקסימלי ברשימה פה, מקס של ליסט, הנה הוא. או.

80
00:29:52,000 --> 00:30:22,000
יש אפילו פונקציית סאם, שהיא יודעת לקחת רשימות עם ערכים, בעיקר מספריים, כן, ולסחום לנו אותם. אז איך אנחנו דרך אגב יכולים בעזרת הפונקציות האלה לחשב מהר מאוד ממוצא של רשימה? אז התשובה היא פשוט מאוד, בואוסתכלו, נריץ פייתון, נגיד List שווה ל...

81
00:30:22,000 --> 00:30:38,020
המספרים שבין 1,2,3,4. פשוט המספרים בין 1,2,3,4. עכשיו אני רוצה את הממוצע, מה אני אעשה? האמת, לא כזה מסובך, אני אגיד:

82
00:30:38,020 --> 00:31:07,360
sum של list חלקי len של list. הרי, אני לא יודע אם אולי שכחתם, אבל ככה מחשבים ממוצע, סכום האיברים, חלקי מספר האיברים. וזה לא צריך להפתיע אתכם. 1 ועוד 2 ועוד 3, 6 ועוד 4, 10, 10 חלקי 4, 2.5. טוב, זה לא היה מסובך.

83
00:31:07,360 --> 00:31:37,360
עכשיו מגיע חלק קצת יותר כיפי עם רשימות סלייסינג, זה בכלל קטע כזה שפייתון עושה אותו לקל ולמשהו פשוט יש כלים מטורפים בפייתון tv ואני רק אכיר עכשיו חלק מהם. סתם דוגמא נניח שאנחנו רוצים תת רשימה, יש לנו שאלה איך אנחנו נשלוף את העברים? הזמן יקרה שבדיוק הושיגים רק פייתון וברוני, ונראה לנו רוצח לשמש ממנו זה זה חייב להיות הרבה יותר עבר רשימה שלנו. טת רשימה נסין רק לטת פייתון ולהשתמן גם בבבקשה בבקשה שלנו. איך ממשיך לגרום לנו ללקום את כל מה

84
00:31:37,360 --> 00:32:07,360
ביש המישור הזה. חלק מחדש בשיח קטן מתמח טוב ומשהו שנאחר לעצמך והצלחת לכך בדרה מסוימת, diminishley ובגלל הרעוע הזה המשך היום כאן נאהב צריך לעשות את זה בצורה שניה ו שמגיע שקט מגיעה לשלהם בכנות מלכתחילה שלנו לצרוך משכיל דואר אחד. ומשהו מה ביטחון שלך. ואז מה הייתה האפשרות לפי למצוקת המאורי שלך אנו צריכים להכיר מזה. ובלי שרבות זה דבר שאנחנו לא במעשה כי הצלחנו לפני כבר בזמננו אבן יהיו זוקיי בטבעות כל רגע. ושל מה האישום יש בעוד הקבוצה

85
00:32:07,360 --> 00:32:31,400
על ליסט את ה-operator slice ככה, זאת אומרת, ל�יסט סוגריים מרובעות 2.27, מה שאני רוצה שתדמינו בראש זה כזה דבר, בפייתון, אני כותב עכשיו ריינג' 2.7.

86
00:32:32,660 --> 00:32:39,740
אז כאילו, מה יש לנו בראנץ' של 2.27? יש לנו את 2, 3, 4, 5, 6.

87
00:32:39,740 --> 00:32:57,300
אז, פה, קרה לנו משהו מאוד דומה, בגלל שהליסט שלנו, אורגן, בדיוק כפי שהייתם מצפים... למצוא, לדוגמה, בראנץ'. אז מה קרה פה? אנחנו עשינו ליסט, עם האופרטור סלייסט הזה, 2.27, שזה אומר:

88
00:32:57,300 --> 00:33:15,740
הנה כאן עותק של הרשימה, ליסט, החל מהאינדקס השני, עכשיו שימו לב, אינדקס 0, אינדקס 1, אינדקס 2, עד ולא כולל האינדקס השביעי.

89
00:33:15,740 --> 00:33:27,140
כלומר, קיבלנו כאן רשימה עם הערכים מהאינדקס השני, עד ולא כולל האינדקס השביעי. זאת אומרת אינדקס 2.

90
00:33:27,140 --> 00:33:55,660
3, 4, 5, 6, הערכים האלה קופי לתוך רשימה חדשה, ולהקיבלנו אותה. וזה אגב אמור להזכיר לכם, שימו לב, זה לא העבר השני מהרשימה, זה לפי אינדקסים ורשימות וכולי, והאינדקס תמיד מתחיל ב-0, אז תזכרו את זה.

91
00:33:55,660 --> 00:34:25,300
אז יש לנו כאן בטקסט את מה שאמרנו, אמרנו מתי זה מתחיל ומתי זה נגמר, אני אומר לכם תיזכרו בריינג', פעולת הסלייס הזאת בעצם מחזירה רשימה חדשה, אז זה שכתבנו פה LST סלייס מה שזה לא יהיה, זה פשוט רשימה חדשה עם הערכים האלה, קופי שלהם, זה פשוט קופי. אז תנו דוגמא, מה היינו עושים כדי לקבל את האיברים 2?

92
00:34:25,300 --> 00:34:55,260
עד 7 כולל, אז התשובה היא, היינו עושים LST שמתחילים ב-2 ונגמר ב-8, כן? כי אז היינו מקבלים את 2, 3, 4, 5, 6 ו-7, לא מסובך. יש עוד הרבה דברים שאנחנו יכולים לעשות, אז בואו ניקח דוגמא אחרת, איך אנחנו יכולים לשלוף מהליסט הזה, את 5 האיברים הראשונים?

93
00:34:55,260 --> 00:35:25,260
נניח, מה היינו עושים? אז תראו קטע מגניב, אנחנו יכולים לעשות דברים עם אופרטור הסלייס, כולל להשאיר צדדים מסוימים של הנקודותיים, ריקים. אז אם פה אנחנו כותבים LST, סוגריים מרובעות, כלום עד לחמש. זה בעצם, אני רוצה ממש אפילו להתקים לכם את זה פה בפייתון, אני חושב שזה יעזור לראות את זה בעיניים. איזה, אני אומר פייתון, אני אומר,

94
00:35:25,260 --> 00:35:55,260
lst באמת שווה לק. אה, אני עצלן? אני פשוט lst שווה ליסט של ריינג' עד עשר. או, האמת, מה שעשיתי עכשיו, העצלנות כאן, היא תעזור לנו להבין.תראו מה כתבתי. אני אמרתי lst הולך להיות הרשימה של הטווח שמתחיל ב-0 עד 10, לא כולל 10. ועכשיו אם אני באמת אדפיס את ה-lst,

95
00:35:55,680 --> 00:35:58,260
היי, זה בדיוק מה ששומעים פה במצגת.

96
00:35:58,580 --> 00:36:13,980
אז אולי עכשיו זה עוזר לכם קצת להבין, כשאנחנו כותבים פה במצגת last בסלייס שמתחיל ב- bye רק, ונגמר ב- 5, זה בעצם להגיד, שימו לב,

97
00:36:14,180 --> 00:36:44,180
lst, slice שמתחיל ב-0 ונגמר ב-5, זה ברור לכם. זה קופי של הרשימה שמתחיל באינקס ה-0 ונגמר באינקס ה-4, כאילו 4 כולל, 5 לא כולל, אז זה לא צריך אותו דבר, אני פשוט אשאיר את זה רק. כי למה, זה כמו שהסברנו לכם על ריינג' ,אתם יכולים להשאיר את ההתחלה רקע וההנחה היא שאתם מתכוונים לאינקס

98
00:36:44,180 --> 00:37:14,180
כלומר, להתחלה, אותו דבר בדיוק. זה בעצם עונה לכם מה שכתוב כאן במצגת. איך היינו אגב מוצאים את ארבעת העברים האחרונים? אז אנחנו יודעים שהאינדקסים פה הם בין 0 ל-9 כולל, אז בואו נראה: אינדקס 9, 8, 7, 6. אז תראו, אנחנו יכולנו לכתוב ליסט בין האינדקס 6

99
00:37:14,180 --> 00:37:44,180
משהו כזה, בואי נראה, ליסט החל מהאינדקס 6 עד אינדקס 10, לא כולל. אוקיי, זה עובד כי אין אינדקס 10 בליסט אבל כן יש אינדקס 9. עכשיו, אני הולך לעשות פשע. מה אם אני משאיר את הצד שלימין לנקודתיים ריק? אההה, אני לא מאמין. לעשות את זה עדיין לבד.

100
00:37:44,180 --> 00:38:06,080
למה? כי אופרטור סלייס יודע להבין את זה, כמו שכששארנו את המשמאל על הנקודתיים האלה ריקות, מבחינת האופרטור זה אומר מההתחלה של הרשימה, כשאני השארתי את המיומינה של הנקודתיים ריק, הוא מבין מזה, הדיפולט שלו זה, עד סוף הרשימה.

101
00:38:06,080 --> 00:38:13,960
וסתם דוגמה, מה אני אומר פשוט לייסט ככה.

102
00:38:13,960 --> 00:38:42,620
אה, אוקיי, אז כאילו שאמרתי לו, תביא לי סלייס של ליסט שמתחיל בהתחלה, ושנגמר בסוף. אז פשוט קופי קופי של כל הליסט. אנחנו ממש מבינים איך האופרטור סלייס הזה עובר, איך הוא עובד, ממש פעולה אחרי פעולה. והנה עוד משהו שביכל יכול לחרפן אתכם, תראו קטע מגניב.

103
00:38:42,620 --> 00:39:12,120
אם אני באמת כותב ליסט, עכשיו משמאלה, אני כותב מינוס ארבע, אז נקודתיים משאיר ריק. אוקיי, מה קרה פה? מה זאת אומרת מינוס? אז פה אני רוצה להגיד לכם משהו על הזזה ציקלית, או פשוט לספור אינדקס מהקצה הרחוק. זה לא מסובך כמו שזה יכול להיראות, תקשיבו.

104
00:39:13,120 --> 00:39:41,620
מה שכתבתי כאן, הרי ברור לכם שמשמאלה לנקודתיים זה להגיד לו מאיפה להתחיל. עד כאן אתם איתי? משמאלה לנקודתיים זה להגיד לו מאיפה להתחיל, מימין לנקודתיים זה להגיד לו איפה לסיים. ראיתם מה קרה כשהשארנו ריק? ריק, הוא הבין בהתחלה בטם ובסוף בטם. אז מה כתוב לנו כאן כשכתבתי ליסט החל במיקום מינוס ארבע?

105
00:39:41,620 --> 00:40:11,620
עד לסוף. מה קרה? קודם כל, עד הסוף, מסביר את עצמו אבל איך הוא ידע להתחיל החל מינקס השישי פה כשאמרתי לו מינוס 4? אז התשובה היא, זה תמון במינוס, וזה תמון מ.. מאיפה הוא מתחיל לספור את המינוס הזה. אז תראו, אולי זה יעזור לכם אם אני אכתוב list במקום החל ממינוס 1 עד לסוף, כולל. הוא הביא את ה...

106
00:40:11,620 --> 00:40:17,160
אה learning with my mind, learning with my brain,

107
00:40:17,160 --> 00:40:23,120
learning with my heart, learning with my body.

108
00:40:23,120 --> 00:40:29,060
learning in this world, learning with my mind,

109
00:40:29,060 --> 00:40:35,040
learning keeping all my liver, learning in this heart,

110
00:40:35,040 --> 00:40:39,840
learning keeping my brain, learning in my mind.

111
00:40:39,840 --> 00:41:09,840
האם זה אחד אחרי הסוף פחות אחד זאת אומרת מהאינדקס אחד אחרי הסוף פחות אחד זה אינדקס של הזה האחרון, אם מישהו שואל למה זה לא היה מתחיל ישר מהסוף ואז מינוס אחד היה מביא אותנו בעצם לאחד לפני הסוף, אז הייתי אומר לו או כן אז תגיד לי מה זה, מה זה list במינוס אפס, איזה מינוס, מה זה מינוס 0 זה 0, אבל 0.

112
00:41:09,840 --> 00:41:30,120
אתם מבינים? זה ההתחלה, אז זה למה זה מקובל לעשות את הספירה כאן מינוס כמה שזה לא יהיה. וזה ביחס לאינדקס הדמיוני, האחד אחרי הסוף. אז עכשיו כבר ברור לכם מה קורה. אני אומר ליסט, תתחיל מהאיבר.

113
00:41:30,120 --> 00:41:39,740
מינוס 1, אני בעצם אומר לו תתחיל מהאיבר האחרון. אני אומר לו ליסט, תתחיל במינוס 2, אני אומר לו תתחיל באיבר.

114
00:41:39,740 --> 00:42:09,720
האחד לפני האיבר האחרון. כן? מה שנקרא השני מהסוף, הראשון מהסוף, אני יכול ללכת רחוק, אני יכול להגיד לו לך לאיבר, תתחיל מהאיבר התשיעי מהסוף. אם אני אומר לו תתחיל באיבר העשירי מהסוף, אני בצורה מאוד דפוקה, פשוט אמר לו תביא לי את כל הליסט, כי זה ליסט באורך 10. אז יש בזה, יש בזה משהו שאפשר להבין.

115
00:42:09,720 --> 00:42:15,060
ואם אנחנו נפתח את זה בצורה אינטואיטיבית אחר כך בקוד שלנו אז בכלל זה יהיה נפלא.

116
00:42:17,800 --> 00:42:26,260
אז מה שאני הראתי לכם עכשיו בפייתון בלייב זה גם עונה לשקופית שאנחנו רואים כאן, איך ניגש לאיבר האחרון מהאופסט הדרוש אז אמרנו.

117
00:42:27,080 --> 00:42:30,440
הראשון מאחרון מינוס אחד אבל כמובן.

118
00:42:31,440 --> 00:42:37,700
כל מה שעשיתי כאן הם נקודתיים נקודתיים אומר לו תביא לי סלייס של כל הליסט של יותר מאיבר אחד.

119
00:42:38,600 --> 00:42:59,020
שום דבר לא מונע ממני, פשוט להגיד לו תביא לי את האיבר שהוא האסירי מהסוף. זה פשוט האיבר הראשון או תביא לי את האיבר האחרון. שזה האיבר הראשון מהסוף. ופה כמו שאתם רואים בלי נקודתיים הוא לא מביא ליסט. הוא מביא את האיבר עצמו.

120
00:43:02,080 --> 00:43:30,780
ומה יקרה אם אני אבקש ממנו תביא לי את האיבר האחד עשרה מהסוף ברשימה של עשרה איברים? אז פה הלכתי רחוק מדי אינדקס מחוץ לטווח. אותו דבר אם הייתם כותבים אגב ליסט באינדקס 10 עבור ליסט שיש לו אינדקסים החל מ0 עד 9 כולל, הוא עדיין יגיד לכם ליסט אינדקס אאוט אוף ריינג' פשוט בצד האחר. משהו שכדאי לזכור בוא נגיד את זה ככה.

121
00:43:30,780 --> 00:43:54,480
איזה עוד דברים אנחנו יכולים לעשות בסלייסים, אם אתם זוכרים בריינג', אתם זוכרים איך שבריינג' יכולנו לעשות קפיצות, לדוגמה, אני יכול לעשות פרינט ריינג' שמתחיל מ-0, ה-11 לא כולל, וקפיצות של 2.

122
00:43:54,480 --> 00:44:24,480
לא ילך, תזכרו זה לא ילך, הוא ידפיס לכם רק את הריינג' עצמו, יגיד לכם הנה ריינג' - לא, לא, לא, תדפיס לי את הליסט שבונע את עצמו מהריינג' הזה, או תודה רבה, אז אתם רואים שיש לי פה בעצם את האיברים הזוגיים בין 0 ל-10 כלל, אז האמת שבסלייסים של ליסט אפשר לשים עוד נקודתיים וזה כמו הפסיק השלישי, סליחה, כמו הפסיק השני,

123
00:44:24,480 --> 00:44:54,480
זה, בהגדרה של ריינג', זה הקפיצה שלנו, זה הסטפ שלנו, זה עובד גם בליסט. אז פה אתם רואים לדוגמה, הנה הליסט הזה, אות הליסט שאנחנו עובדים עליו, ואנחנו עושים סלייס, תביא לי סלייס של הליסט שמתחיל באיבר הראשון, נגמר, לא כולל, באיבר, באינדקס 10, ותעשה לי קפיצה של כל שניים. אז ברור לכם שזה באמת מסתכל על הליסט הזה, החל מאינדקס 0, עד אינדקס 10.

124
00:44:54,480 --> 00:45:24,480
קופי של הליסט שמכיל רק את האיברים באינדקס הזוגי אז אני רוצה גם להראות לכם את זה בלייב אני אומר ליסט החל מאינדקס 0 עד לא כולל 10 בקפיצה של 2 עכשיו ברור לכם שאם אני אומר לו תתחיל מהאינדקס ה-0, אנחנו פשוט לא נכתוב את זה, זה אותו דבר והנה זה מביא לי בדיוק את האיברים שראיתם בשקופית.

125
00:45:24,480 --> 00:45:54,480
או יותר פשוט מזה, אני יכול גם לא להכין לו שום דבר אחרי הנקודותיים הראשונות ובעצם כשאני כותב אופרטור סלייס שהוא נראה ככה, סוגריים מרובעות נקודותיים, נקודותיים, שתיים אני בעצם אומר תביא לי קופי של הליסט הזה של כל האיברים באינדקס הזוגי. כלומר: האינדקס האפס, האינדקס השתיים.

126
00:45:54,480 --> 00:46:24,480
ארבע וכן הלאה וכן הלאה. אז ככה אפשר לכתוב כשאתם אפילו לא יודעים איפה הליסט מתחיל, איפה הוא נגמר, אתם רואים לו, פשוט תביא לי קופי של הליסט, כל האיברים באינדקסים זוגיים. אני כמובן יכול לעשות את זה על אינדקסים איזוגיים. עלּא, זה לא יעבוד ככה, שימו לב, זה לא יעבוד ככה. אתם יודעים מה אני אמרתי לו עכשיו? זה סטפ. אני אמרתי לו סטפ, אז פה זה היה קפיצה של

127
00:46:24,480 --> 00:46:54,480
‫שתיים, זאת אומרת, כל עבר, ‫תקפוץ לעבר, לא הבא בתור, לעוד שני עברים. ‫מה שכתבתי פה, ‫אני רוצה עכשיו שתבינו, ‫כתבתי כאן ליסט נקודתיים, נקודתיים אחד. ‫רובוטייז פשוט יביא לי ליסט, ‫זה יביא לי קופי של הליסט המקורי. ‫למה? ‫אני אמרתי לו, תביא לי סלייס של הליסט, ‫שמתחיל בהתחלה, נגמר בסוף, ‫וקופץ כל פעם עבר אחד. ‫אבל זו הברירת מחדל. ‫כך אנחנו עובדים עם רשימות

128
00:46:54,480 --> 00:47:14,620
מלכתחילה? לא, אם אני רציתי את האיברים באינדקסים האיזוקיים, הייתי אומר כזה לא. הייתי אומר תתחיל עם האינדקס אחד. אז תקפוץ שתיים כל פעם, אוקיי? עכשיו קיבלתי את המספרים באינדקסים האיזוקיים.

129
00:47:14,620 --> 00:47:23,660
יש עכשיו את המסקנה המתבגשת, נכון? אם אני אמרתי לכם שקפיצה סטפ של אחד, זה פשוט הליסט.

130
00:47:23,660 --> 00:47:31,000
בקפיצה של עבר אחד אחרי השני אחרי ככה וככה אפשר לעבוד על זה בצורה אחרת אני באמת יכול להגיד.

131
00:47:31,900 --> 00:47:53,400
תתחיל. מהסוף. סיים. בוא נראה אם אני אגיד לו.0 כולל הוא בטח לא יבין את זה מנוס אחד ואז. תעשה לי בקפיצות של מינוס אחד אז כאילו פה אני כותב בסלייס.

132
00:47:53,400 --> 00:48:04,700
שמתחיל בסוף, ממש, עוצר באינדקס המינוס אחד, לא כולל, אבל אחד לפניו יהיה אינדקס אפס, זה תעשה לי בסטפ של מינוס אחד, זה יעבוד לדעתכם?

133
00:48:04,700 --> 00:48:22,700
לא, הוא לא אוהב את זה. כנראה שאני ילכתי איתו רחוק מדי. אין בעיות, אז אל תעשו ככה, אפילו אם זה נראה לכם הגיוני. אבל אם אני אומר לו, משהו אחר, אני אומר לו, קח את הליסט, איך שהיא, ותביא אותה בקפה.

134
00:48:22,700 --> 00:48:52,300
ותביא אותה בקפיצות של מינוס אחד, את זה הוא כן יבין, והוא כן יהפוך את הליסט. הוא בעצם, הוא יודע ישר להתחיל מהסוף ולהביא לנו אותם ככה בסטפ של מינוס אחד. אגב, כמובן, שסטפ של מינוס שתיים יעבוד, כן? אנחנו מקבלים בעצם, תראו, מהסוף, נכון? אמרנו, הוא מתחיל את הספירה שלו מאינדקס שהוא נמצא, אחד אחרי הסוף, מינוס אחד.

135
00:48:52,300 --> 00:49:21,720
מינוס שתיים, מינוס אחד, מינוס שתיים, מינוס שתיים, מינוס שתיים, מינוס שתיים. לאט לאט אנחנו נלמד את זה. ואז באמת, שאלה נוספת, אם אנחנו עכשיו אומרים לו, ליסט, תתחיל באינדקס תשע, תעצור באינדקס אחד, לא כולל, קפיצות של מינוס שתיים, אז ככה זה עובד. זה אינדקס תשע.

136
00:49:21,720 --> 00:49:50,520
כאילו עדיין אמרנו לו, תתחיל מהסוף, עד לאינדקס אחד, לא כולל, זאת אומרת, הוא כנראה יעצור באינדקס שתיים, והוא עושה לנו קפיצות של מינוס שתיים, אז, מכאן, נמשיך לשבע, חמש ושלוש, ואחד כבר לא ילך. ראינו פה הרבה מאוד דוגמאות לסלייסינג, זה באמת הרבה דרכים לעבוד על רשימות, לקבל היתקים של רשימות, זה דברים שאפשר לעשות דברים איתם, מה שנקרא.

137
00:49:50,520 --> 00:50:20,520
ויש לנו פה סוג של תרגיל מסכם על הדברים השניים שאנחנו יכולים לעשות עם סלייסים. אז בואו נראה אם אנחנו יכולים להבין איך לעבוד עם הסלייסים האלה. אז הנה, אני אעשה את זה, אסיים את ההרצאה. ויאללה, בואו נסתכל על מה שאנחנו יכולים לקבל בסלייסים. קודם כל, כמו שראינו עד עכשיו. כשאני לוקח את זה

138
00:50:20,520 --> 00:50:50,520
list ואני עושה לה slice מכלום לכלום, זה בעצם הדרך שלי להגיד תביא לי קופי של כל הרשימה איך שהיא. אוקיי, יחסית מובן. עכשיו אני אומר תביא לי קופי של ה-list החל מ-index: 2, שימו לב, אינדקס 2 עד לאינדקס 7 לא כולל אז בוא נראה זה 2 3 4 5 6 כולל 6

139
00:50:50,520 --> 00:51:20,520
כלומר, האותיות C ואז D ואז E ואז F ואז G.אז אנחנו נקבל ליסט שמכיל את העברים האלה. עכשיו אנחנו קוראים משהוא אחר תביא לי קופי של הליסט בסלייס שמתחיל ישר מההתחלה, כן? מכל נקודתי ריק עד לא כולל לאינדקס 7. הבדל היחיד הוא שזה יהיה כמו LST,

140
00:51:20,520 --> 00:51:50,520
2 עד 7, אבל כל לשני עיוורים A ו-B. מגניב. עכשיו אנחנו אומרים כזה דבר. תביא לי סלייז של הליסט, מתחיל באינדקס 1, עוצר באינדקס 7, לא כולל, בקפיצות של 5, אז יש לי תחושה שיהיה פה רק ליסט עם עיוור 1, כי, באינדקס 1 יש את האות ב, ואז, ועוד 1, ועוד 2, ועוד 3, ועוד 4, ועוד 5. אוקיי. רק עיוור 1?

141
00:51:50,520 --> 00:52:20,520
לא, שני איברים, היה לנו את B ואת G לדעתי, היה לנו את B ואת G, מגניב. עכשיו אנחנו אומרים כזה דבר, List מתחיל ישר בהתחלה, עד האינדקס 10, לא כולל, כמה איברים יש בו? 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, כלומר אינדקסים 0 עד 9 כולל, אז בעצם יש כתבת פה LST,

142
00:52:20,520 --> 00:52:49,920
כלום לפני הנקודתיים, 10 אחרי נקודתיים, קפיצה של 5, זה כאילו אותו דבר אם היינו כותבים LST, נקודתיים, נקודתיים, 5. בעצם אנחנו אומרים, תביא לנו את האיבר הזה, 1, 2, 3, 4, 5, תביא לנו את F גם, 1, 2, 3, 4, זהו, A ו-F, בקיצור. כל כך הרבה מחשבה רק כדי להגיע למסקנה ברורה מלאה, A ו-F.

143
00:52:49,920 --> 00:53:19,720
LST שמתחיל, האיבר האחרון? יש תחושה שיהיה לנו מה? רק את J? מה אתם אומרים? רק את J. LST, הכל אותו דבר, הכל אותו דבר? סטפ מינוס 1. אז פשוט רשימה הפוכה. אין לי פה יותר מה לחדש לכם, זה פשוט בסדר הפוך. עכשיו אנחנו אומרים, LST.

144
00:53:19,720 --> 00:53:49,720
תתחיל בעבר האחרון, תעצור בעבר ה-50 מהסוף שתיים, שלוש, ארבע, חמש, קפיצות של שתיים.� באיזה סדר לפי דעתכם זה ילך? ודרך אגב, הליסט האחרון זה אותו דבר בדיוק, בקפיצות של מינוס שתיים, איך זה יסתדר לדעתכם? אני אומר, בוא נגלה, אז אחד מהם, אחד משני הדברים האלה

145
00:53:49,720 --> 00:54:12,780
זה השיטה הנכונה לכתוב את זה, והשני הוא לא. אז פה הדוגמא כשאנחנו אומרים לו מי הראשון מהסוף על החמישי מהסוף, זה נחמד והכל, אבל ההתחלה שלנו היה יותר מאוחר בליסט מהסוף, ועם סטפ חיובי הוא לא יודע מה אנחנו רוצים לעשות עם זה, מה לעשות עם זה, אז זה לא ילך.

146
00:54:12,780 --> 00:54:35,620
מנגד, כשהבאנו לו התחלה שהיא יותר רחוקה מהסוף, אבל היה סטפ שלילי, אז את זה הוא כן ידע, את זה הוא כן ידע לאקל. אמרנו לו, ספציפית אמרנו סטפ ככה מינוס שתיים, מינוס אחד, מינוס שתיים מזה, ואז עוד, אבל זה כבר לא כולל F.

147
00:54:35,620 --> 00:55:05,440
עכשיו, אם במקרה אתם סקרנים, יש לנו גם כמובן קובץ פייתון שאמור להיות במודל לנוחותכם, יש לנו כאן את הליסט המקורי, יש לנו כאן עוד ליסט שהוא מורכב מהמחוזות שהם הביטויים שראיתם כאן בשאלה, ויש לנו את זה, הדפסה מאוד נוחה של זה. למעשה מה שאתם רואים פה זה דברים שאתם כבר יודעים, אתם יודעים לקרוא את זה, אני מדפיס קודם כל את הליסט המקורי.

148
00:55:05,440 --> 00:55:34,860
F סטרינג, אחר כך אני עושה 4 שעובר על, שימו לב, מחוזות שהן הביטויים האלה, כן? אתם רואים פה ביטויים, פשוט כתבתי אותם בתוך מחוזות, ואז אני עשיתי פרינט. הביטוי הזה, שזה כמחוזת, אז זה הדפיס את המחוזת, הוא, ואז השתמשתי בפונקציה שקוראים לה איבל. מה הפונקציה הזאת עושה?

149
00:55:34,860 --> 00:56:04,860
היא לוקחת את המחרוזת הזאת והיא פשוט מתייחסת למה שבפנים והיא מחשבת אותה כביטוי, זאת אומרת לקחת, זה כאילו שקלטתם ליסט בסלייס מינוס 1 עד מינוס 5 קפצות של 2 והוא ייחשב את זה, אז אני קטטתי בשבילכם האמת כדי שיהיה לכם בצורה נוכחהיים, אז הנה אתם רואים? הנה דוגמה ליסט, כלום נקודתיים.

150
00:56:04,860 --> 00:56:34,860
כלום איז ווינהליסט וככה אתם רואים התפסנו את הכל בצורה מסודרת אז אם היה לכם ספקות לגבי אם זה נכון או לא נכון יש לכם את זה בפייתון בנוחה בצורה נוחה מופיע לכם מה שנקרא סתם שיהיה לכם כי למה לא? עכשיו אם כבר אמרתי מחוזת בואו נזכר קצת על מחוזות נדבר עליהן קצת יותר אתם זוכרים שמחוזת זה בעצם

151
00:56:34,860 --> 00:57:04,860
ככה רצף של תווים, תו אחרי תו אחרי תו, זה אתם יודעים. ואתם ראיתם שאנחנו ידענו לשרשר מחוזות, זאת אומרת ידענו לקחת מחוזת, להגיד מחוזת ועוד מחוזת, זה פשוט היה מחוזת אחת שהיא שירשור ישיר, מחוזת שיש פה A,B ועוד אה, אני אראה לכם את זה ישר בפייתון שלו, נגיד ככה A,B ועוד C,D שתי מחוזות A,B,C,D

152
00:57:04,860 --> 00:57:34,860
היה מחוזת פאי כפול שתיים פאי פאי בדיוק כמו שכתוב כאן בשקופי (מישור חצי האגס שלו) אף אחד לא עובד עליהם אז אפשר לחשוב על זה שמחוזת היא סוג של רשימה אבל רק של תווים זאת אומרת, אני לא יכול לכתוב, לפחות אני לא חושב, אני יכול לכתוב פאי פלוס שלוש הוא לא יודע לחבר לי בין סטרינג לאינט, זה לא ילך.

153
00:57:34,860 --> 00:58:04,860
זה במובן שאם אני אכתוב פאי ועוד מחוזת שיש לה את 3 אז פאי 3 כי זה מחוזת. זה כן עובד. אז האם אנחנו יכולים בגלל שאנחנו חושבים על מחוזה בתור סוג של רשימה של קרקטר של תווים, אנחנו יכולים גם לגשת לקרקטר ספציפי בתוך מחוזת? לדוגמה, אני אומר נגיד סאם סטרינג...

154
00:58:04,860 --> 00:58:34,860
שווה לאיי שלוש ועכשיו אני רוצה את sum string באינדקס שתיים וואלה זה עובד קיבלתי את הקרקטר באינדקס שתיים של המחוזת הזאת זה כן עובד אפשר לעבור על מחוזות ככה זה עובד לחלוטין. עכשיו באופן כללי למחוזות יש הרבה מהתכונות של רשימות. לאן אתה צריך להסבר מה היא מסוגלת להפוך בחשודות ומשפט מעריצים

155
00:58:34,860 --> 00:59:04,860
במעשה, כמו שאתם רואים כאן, הבלתי יאמן הוא האפשרי. יש הדבר הזה סלייסינג. אז אם נניח אני לוקח את המחוזת הזאת שכתבתי, את הפאי 3, ועכשיו אני אומר, בוא נעשה לה סלייסינג, בוא נעשה למחוזת הזאת שכתבנו סלייסינג, תביא לי את המחוזת, פשוט הפוך. אופה, הפכנו אותה, 3 yp, זאת אומרת, אם אני עושה את זה, ואפילו יותר מזה,

156
00:59:04,860 --> 00:59:31,580
תביא לי הפוך בקפצת של מינוס 2, אז הביא את p מינוס 2 3. וואלה מי היה מאמין, רגע רק שנייה, או נכון כי p ואז 3, אפילו שמר על הסדר, איזה קטע.

157
00:59:31,580 --> 01:00:01,420
אפשר לשנות, הרי אם אמרנו שמחוזת כמו רשימה, אפשר לשנות אותה? מה אם אני אומר sum string בindex 2 עכשיו שווה לקרקטר 0, אני רוצה לכתוב πי 0. הוא כותב לי, String Object does not support Item Assignment, אז בסטרינג, מחוזת כזאת.

158
01:00:01,420 --> 01:00:31,100
אני לא יכול לשנות אותה בצורה זאת. אופרטור, מה שנקרא אופרטור הסמה, כשאני עושה את הסיפור הזה, גישה לכתב בתוך מחוזת ככה, זה לא ילך, זה לא עובד. אז כמובן שיש לנו דרכים לשנות מחוזת, אבל לא ככה. בואו נכיר דבר מאוד מאוד בסיסי במחוזות.

159
01:00:31,100 --> 01:00:35,780
זה מסוג התרגילים שתמיד רואים בקורסת מבוא למדעי המחשב, לא משנה מה.

160
01:00:36,640 --> 01:00:49,040
פלינדרום? מה זה פלינדרום? מכרוזת היא נקראת פלינדרום אם היא סימטרית לחלוטין מבחינת הטבים שלה.

161
01:00:49,400 --> 01:01:06,240
זאת אומרת, אם אני מתחיל לקרוא את המחוזת משמאל לימין, אז אני אקפוא, יש לי ABBA, ואז אני מתחיל לקרוא אותה מהסוף להתחלה, מימין לשמאל, אני עדיין מקבל פה ABBA. זה פלינדרום.

162
01:01:06,720 --> 01:01:19,140
אגב, אותו דבר גם אם המחוזת היא באורך איזוגי. יש לי פה SOS, זאת אותו דבר כמו SOS. מנגד, מחוזת כמו AAV.

163
01:01:19,140 --> 01:01:49,140
זה לא אותו דבר כמו VAA. אז עכשיו התרגיל אומר לנו כזה דבר פשוט. תכתבו תוכנית שהיא מקבלת מחוזת, והיא אומרת לכם אם זה פתינדרום, כן או לא. עכשיו אני מניח שאתם יכולים מיד לחשוב על איך לעשות את זה עם סלייסינג, אבל לפני זה בואו נחשוב על איך אנחנו עושים את זה בלי סלייסינג. איזו לוגיקה היינו..., מה אנחנו צריכים לחשוב בראש? איך

164
01:01:49,140 --> 01:01:59,700
איך לעשות את המעבר הזה, משמאל וגם מימין, איך אנחנו בודקים שזה שווה לחלוטין משמאל לימין? איך זה עובד?

165
01:01:59,700 --> 01:02:11,060
אז בואו נסתכל קודם כל על הפתרון שעושה את זה בלי סלייסינג. זאת אומרת בואו נסתכל על פתרון שגם יעבוד בספו תכנות אחרות שאין להם סלייסינג כמו שראינו עכשיו ברשימה.

166
01:02:11,060 --> 01:02:17,800
אז תראו כאן, אנחנו נקבל באינפוט את הסטרינג שלנו, כן?

167
01:02:17,800 --> 01:02:47,740
נשמור אותו לתוך משתנה שנקרא לו to check, אנחנו הולכים לבדוק אותך. ועכשיו תראו כיפה, אנחנו נתחיל שני משתנים ככה, משתנה בשם low נתחיל אותו ב-0, משתנה בשם high אנחנו נתחיל אותו באורך המחוזת פחות אחד, למה פחות אחד? זה כמו שאנחנו עובדים עם רשימה.

168
01:02:48,700 --> 01:03:17,620
כזאת, יש לנו רשימה עם המספרים 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, זאת רשימה באורך 10, אבל האינדקס האחרון שלה זה 9, אז כשאני אומר אורך של רשימה, אורך של משהו פחות אחד, אני בעצם מתכוון לאינדקס האחרון. למה אני מגדיר את זה פה? בעצם אני אומר low.

169
01:03:17,620 --> 01:03:21,980
הוא, אני מתחיל אותו להיות האינדקס הראשון של המחוזת.

170
01:03:22,180 --> 01:03:27,680
ה' מתחיל אותו להיות האינדקס האחרון של המחוזת.

171
01:03:27,780 --> 01:03:37,560
אז יש לי כאן אינדקס התחלה, אינדקס סוף. הגיוני לא? אני רוצה להתחיל לעבור על המחוזת משמאל וגם מימין.

172
01:03:39,760 --> 01:03:47,500
אז עכשיו אני אומר כזה דבר, while התו. כן, כן. התו שבמחוזת,

173
01:03:47,500 --> 01:04:17,480
באינדקס הנמוך, שווה לתו שבמחוזת באינדקס הגבוה, וגם שהאינדקס הנמוך הוא באמת קטן יותר מהאינדקס הגבוה. אז כל עוד שבעצם התו מהקצה השמאלי שווה לקצה הימני, והמעבר שלי משמאל עוד לא עקף את המעבר מימין, זאת אומרת כל עוד שהם עדיין בקצוות נפרדים, מה שנקרא, ושעדיין...

174
01:04:17,480 --> 01:04:47,480
שוויון, אז אני אומר, קדם את האינדקס הנמוך בפלוס 1, זאת אומרת, אותב אחד ימינה, ותקטין את האינדקס הגבוה במינוס 1, אותב אחד שמאלה. מה קורה? בעיקרון, אני ממשיך כאן את הבדיקה, זאת אומרת, אני אראה לכם על סטרים כלשהו, נניח, איי, בי, בי, בי, איי. תסתכלו, אני אומר, low שווה 0, high שווה שווה 0,  עד סטרים כזה אני אומר שמלך הידיעה בלהצפה בשמנה 3000 של חצאים, בטוחה שבדר, שמסבת מלך ככל שאתה שוקף על מזמן אחד שתומד

175
01:04:47,480 --> 01:05:16,840
למה? 0, 1, 2, 3. עכשיו, האם a שווה ל-a? כן, אז עכשיו הם 1 פסיק 2. למה? כי היה שוויון בין ה-a פה וה-a שם, כלומר, המחוזת במקום 0 שווה למקום 3, זה השוויון הזה.

176
01:05:16,840 --> 01:05:29,380
וכמובן 0 קטן מ-3 אז הרצתי את הפקודות האלו, הגדלתי את low ב-1, ואת high הקטנתי ב-1. עכשיו הם 1 ו-2. ואני עושה שוב את הבדיקה.

177
01:05:29,380 --> 01:05:44,880
הכרקטר באינדקס 1, b, שווה לכרקטר באינדקס 2, b, אוקיי. עכשיו הם 2, פסיק 1. ואז כשאני נכנס לאיתרציה בלולה הזאת, אז הווייל הזה עדיין מתקיים, עדיין יש את השוויון הזה, כן?

178
01:05:44,880 --> 01:06:14,880
אבל לואו לא קטן מ-high יותר, עכשיו לואו גדול מ-high ואני יוצא מה while ועכשיו תראו מה אנחנו מדפיסים בפרינט, תדפיסו בפרינט אם לואו גדול שווה ל-high, כלומר אם הגענו למצב שבו לואו השתבע ל-high או יותר גרוע מזה, אם לואו כבר עקף את היי זה אומר שסיימנו לעשות מעבר שלם על הסטרינג, highways מימין, Low מידה יד רעה ופודקן, מינימ טרם גם מבוקס של דרך לSTD Lay On The Hand.__

179
01:06:14,880 --> 01:06:44,880
ומשמאל, והם כל פעם מצאו זוג תווים שווה. אגב, זה אותו דבר גם אם זה אי-זוגי, כן? כי תחשבו על זה: SOS0 שווה ל-2, ואז הגדלנו אותם. עכשיו, יש לנו את 1 ו-1, אז low שווה ל-high, וזה מסתם אותותיו. רואים? low גדול שווה לה-high, ואם זה היה נכון, אז הגענו לפה. בעצם, כל פעם של low גדול שווה לה-high, ...

180
01:06:44,880 --> 01:07:14,040
זה אומר רק דבר אחד, עשינו מעבר שלם לפחות על כל הסטרינג משמאל ומימין, ואם עשינו את זה, זה רק בגלל שהתווים בזוגות, בקצוות, היו שווים. זאת אומרת, פה A היה שווה ל-A, אחר כך B היה שווה ל-B, ואז עשינו מהפך, וזה פשוט הפוך, B שווה ל-B, אבל כבר עשינו את המעבר הזה, חצי מכאן, חצי מכאן, וזהו.

181
01:07:14,040 --> 01:07:41,400
מנגד, אם היה לנו A, B, C, A, אז עכשיו זה היה מתחיל ב-0, 3, 0 שווה ל-3, כן, עוברים ל-1 פסיק 2, ועוצרים, כי B שונה מ-C, ואז היינו עושים פרינט, האם לואו גדול שווה להיי? לא, אז היינו עושים פרינט של פולס.

182
01:07:41,400 --> 01:08:11,360
אז עכשיו שהסברנו עד הסוף את הלוגיקה של זה, בואו נריץ את הפתרון הזה, q2.pi, enter string, כמו שראינו עכשיו, A, B, B, A, true, S, O, S, true, A, B, C, A, false, בדיוק לפי ההיגיון שכרגע הסברנו פה. אז ככה, לא בהכרח בפייתון, אבל...

183
01:08:11,360 --> 01:08:19,180
אבל כן בשפות תכנות אחרות, כמו ב-C, היינו חושבים על הלוגיקה של איך לפתור את הבעיה הזאת.

184
01:08:19,180 --> 01:08:41,340
מה שראינו עכשיו זה דוגמה, נקרא לזה לאלגוריתמיקה מאוד בסיסית. אני לא יודע אם זה משהו שאומרים לכם מספיק, אבל בקורס מבוא למדעי המחשב, אתם לא רק לומדים את שפת התכנות, אתם גם לומדים קונספטים בסיסיים בתכנות ועל הדרך.

185
01:08:41,340 --> 01:08:56,440
מצופה מכם שלאורך הקורס, אתם תלמדו לאט לאט שלבים נכונים של אלגוריתמיקה בסיסית ופתרון בעיות, שבסופו של דבר מסתכם בלכתוב קוד שפותר את הבעיה.

186
01:08:56,440 --> 01:09:08,400
יהיה קצת דיבור על זה יותר בהמשך הקורס, יותר ספציפית, אבל אני רוצה להגיד לכם כבר מעכשיו, במעבור למדעי המחשב הציון שלכם לא יקבע רק אם אתם יודעים לכתוב קוד בפייתון.

187
01:09:08,420 --> 01:09:32,120
הרבה מהציון שלכם גם נקבע לגבי האם אתם יודעים לכתוב, כאילו בוא נגיד זה ככה, האם אתם יודעים לקבל בעיה, לחשוב בראש ואו לכתוב אלגוריתם שפותר את הבעיה ואז לכתוב את הקוד שפותר את הבעיה וההפרדה הזאת לשלבים שנתתי כרגע היא קריטית.

188
01:09:32,120 --> 01:10:02,080
כמובן שדרך אגב אם סלייסים והאופרטורים של פייתון זה קל בצורה אסטרונומית, אנחנו פשוט אומרים הנה הסטרינג שאנחנו מקבלים כאינפוט, אז נתפיס את התשובה של האם הסטרינג שווה לעצמו אבל הפוך, אז ברור שזה עובד כן? תסתכלו q2a זה הפתרון הראשון, q2b.

189
01:10:02,220 --> 01:10:31,860
זה פשוט סטרינג, האם אתה שווה לעצמך אבל הפוך, אז ספוילר, ברור שזה יעבוד, כן? sos עובד, appa עובד, abca פולס, מגניב, בואו נעשה תרגיל אחר, נניח שיש לנו איזושהי רשימה באורך סוגי, אפילו לשם הפתרון ניתן אותה מראש.

190
01:10:31,860 --> 01:10:34,480
רשימה נתונה מראש, לא משנה.

191
01:10:35,700 --> 01:10:51,140
אומרים לנו, תשנו אותה ככה שכל זוג שכנים יתחלף. מה הכוונה? אם יש לכם רשימה ככה שמתחילה ב-0 funding ל 0 בשבע, אז כל זוג, כמו 0, 1, 2, 3, 4, 5, 6, 7, פשוט יתחלפו ביניהם.

192
01:10:51,580 --> 01:11:00,980
ואז הרשימה החדשה תהיה 1, 0, 3, 2, 5, 4, 7, 6. ואז מבקשים איתנו לפתור את זה בכמה דרכים שונות.

193
01:11:01,700 --> 01:11:31,040
בעזרת לולה, בלי לולה, איך נעשה את זה? עכשיו, מתחבא כאן גם איזושהי, מתחבאת כאן טיפה סיבוכיות גדולה יותר ממה שהיינו מצפים, אבל בסופות תכנות אחרות. כי הייתם חושבים שכדי להחליף במערך בין שני זוגות, כאילו בין זוג של איברים, אתם הייתם אומרים, אוקיי,

194
01:11:32,040 --> 01:12:02,040
איבר במקום הזה אתה הולך להיות שווה, סליחה בוא נגיד את זה ככה איבר באינדקס 0 אתה הולך להיות שווה לאיבר באינדקס 1 ואיבר באינדקס 1 אתה הולך להיות שווה לאיבר באינדקס 0 רגע אבל אם אמרתי איבר באינדקס 0 אתה שווה להיות איבר באינדקס 1 אז כאילו במקום 0 1 הייתי מקבל 1 1 ואז כאילו הייתי מאבד את 0, אז הקטע הוא ש...

195
01:12:02,040 --> 01:12:32,040
אם אנחנו היינו עובדים עכשיו בשפת תכנות שלא שומרת לנו בצורה זמנית את הערכים האלה בנפרד, במקום אחר, היינו מאבדים. ובגלל שהיינו מאבדים, אנחנו היינו צריכים לשמור, בוא נגיד את זה ככה, היינו צריכים לשמור בצורה של איזשהו משתנא עזר, איזשהו טמפוררי כזה.OK

196
01:12:32,040 --> 01:12:41,180
בפייתון למזלנו אנחנו לא צריכים לזכור לעשות את זה הרבה מהזמן אבל עדיין זה קונספט שהייתי רוצה שתכיר בכל מקרה.

197
01:12:42,040 --> 01:13:00,140
בפייתון החלינו פותרים את הבעיה הזאת אז יש הרבה דרכים לעשות את זה לדוגמה בפייתון הדרך הכי פשוטה לעשות את זה זה הדרך הכי טריוויאלית שבה אנחנו לא חושבים הרבה אפילו הסתכלו נניח שיש לנו פה רשימה כמו שאמרנו הרשימה הכי פשוטה שיש.

198
01:13:00,660 --> 01:13:16,740
0, 1, 2, 3, 4, 5, 6, 7, כן רשימה באורך סוגי ואנחנו אומרים כזה סיפור לכל אינדקס בטווח שמתחיל ב-0 נגמר באורך הרשימה לא כולל כלומר 0 עד 7 כולל.

199
01:13:18,580 --> 01:13:35,340
בקפיצות של 2, זאת אומרת. 0 ואז 2 ואז 4 ואז 6 כלומר אנחנו הולכים לעבוד על זוגות כן נגיד רשימה באינדקס ורשימה באינדקס פלוס 1 שווה הפוך.

200
01:13:36,060 --> 01:13:46,820
נגיד ליסט באינדקס תהיה שווה לליסט באינדקס פלוס 1 וליסט באינדקס פלוס 1 תהיה שווה לליסט באינדקס עכשיו זה שכתבנו אותם בפקודה 1 פה עוד עם פסיק.

201
01:13:47,780 --> 01:14:17,780
זה כאילו אנחנו אמרנו לו היי, אל תאבד את הערכים האלה תוך כדי, ולמעשה, אני רוצה להראות לכם את זה, אז תראו קצת כמה נוח זה היה, הנה הקוד, אתם רואים אותו, בואו נריץ את זה, עכשיו, אני אומר פייתון, תריץ את q3a.pi, וה עובדה, הפכנו את הרשימה עכשיו, 1 0, 3 2, 5 4, 7 6, זה סתם דוגמא, זה סתם דוגמא.

202
01:14:18,660 --> 01:15:09,526
מה היה קורה, אני אעשה עכשיו comment out לזה, ובין כל זה הייתי מריץ playlist באינדקס, תהיה שווה עכשיו ל-list באינדקס פוס אחד, ובפקודה הנפרדת הייתי אומר ל-list באינדקס פוס אחד, אתה שווה ל-list באינדקס, האם זה היה עובד? לא. אתם רואים מה ההבדל? בכך שעשינו את הפקודה הזאת, שתי ההעסמות האלה, האור כאן בדרך כלל לא היו בריאות שהייתה מסוכן, המהות שהיה היה מוחזם היה שקשר הרוב לא היה בהחלה ובדרך זמן וחסוד כלל, וחסדי שצפתן למה שהיה בערך באמת. לא היה דומה שה

203
01:14:18,660 --> 01:14:48,660
waffle4 עצם (x, y, z)

204
01:14:48,660 --> 01:15:18,660
בפקודה אחת עם פסיק, אנחנו בעצם בצורה נסתרת, אם אתם זוכרים משהו נניח מהרצאה, שקיבלתם דיבור על פונקציות, אל תדאגו אנחנו נדבר על פונקציות בתרגול, אבל, בעצם בצורה נסתרת, אנחנו שלחנו את 2 הערכים האלה, שכבר קיימים, סוג של כפרמטרים, זאת אומרת הערכים האלה נשמרו, באיזושהי פונקציה חבויה, ולכן, יכולנו

205
01:15:18,660 --> 01:15:48,660
לסרוד את ההחלפה הזאת ככה בעצם משהו נסתר מהעיניים שלנו כן עשה את הסו-אפ הזה את ההחלפה הזאת אם במערכות משתנה עזר ושמר על הערכים האלה כי מה שעשינו פה זה בדיוק מה שאמרתי לכם היי תיזהרו ממנו, פה אמרנו ליסט באינדקס עכשיו שווה לליסט באינדקס פלוס אחד אז זה ה0 פה התחלף באחד וגמרנו.

206
01:15:48,660 --> 01:16:12,540
נקודה הבאה בתור מרץ הערך של האינדקס הבא תשווה לערך של האינדקס הקודם אבל כבר דרסנו אותו אז בפייתון יש לכם דרך לעשות את ההחלפות האלה אפילו בלי להיעלץ לחשוב על משתני עזר עכשיו מן הסתם איך עובדים עם משתני עזר?

207
01:16:16,560 --> 01:16:46,560
נבנה כזה. ואגב מה שאתם רואים כאן אנחנו יכולים לעשות את העבודה שלנו בסלייסים בלי לולא אפילו דרך אגב אז פה אתם רואים קונספט דומה למה שעשינו כאן את ההשוואה הזאת עם הפסיק, אז פה אנחנו עושים את זה בלי לולא אלא פשוט בסלייס. אנחנו אומרים ליסט האיברים הזוגיים, האיברים באינדקס הזוגים

208
01:16:46,560 --> 01:17:16,560
איזהוגי, 0, 2, 4, 6 וגם ליסט באיברים, האיזוגיים, כלומר החל מה אינקס אחד ואז קפיצו של 2 כל פעם, אתם שווים בסדר ההפוך, זה גם ירוץ, אבל עכשיו אני רוצה בעיקר להתמקד איתכם, סלייסים זה דבר נחמד, אני רוצה להראות לכם אבל, את העבודה עם המשתנה עזר, אז פה, אתם רואים את זה עם רשימת עזר, תראו מה עשינו,

209
01:17:16,560 --> 01:17:44,400
אמרנו, רשימה של האיברים האי-זוגיים, היא תהיה קופי של הרשימה בסלייס כזה, שמתחיל באינקס אחד, וקפיצות של שתיים. אז יש לנו את האיברים האי-זוגיים, 1, 3, 5, 6 ו-7. עכשיו תראו מה אנחנו אומרים. ליסט, באיברים, באינקסים האי-זוגיים, עכשיו שווה להיות ליסט באיברים הזוגיים.

210
01:17:44,400 --> 01:18:14,320
ואז אנחנו אומרים, ליסט באיברים הזוגיים תהיה שווה למה שהעתקנו פה, למשתנה אות ואלס. זה כאילו היה משתנה עזר שלנו. עכשיו, זה אולי טיפה מבלבל אתכם, כי אתם רואים את זה פה, לא בלולה, אלא בסלייסים של ליסט, אבל זה אמור לעבוד. הנה, אני רוצה גם להראות לכם. יש לכם בקוד, Q3B, שזה הסלייס סוואפ בשורה אחת, וב-Q3C, עם המשתנה...

211
01:18:14,320 --> 01:18:44,100
עם הרשימת עזר הזאת, זה עדיין יעבוד בסופו של דבר. Q3A, Q3B ו-Q3C, כולם עשו את ההחלפה הזאת בצורה מוצלחת. זה משהו שאולי שווה לשבת עליו עוד קצת עם עצמכם, להתנסות, אם אתם לא סגורים על זה. אני ממליץ. בינתיים, נעבור לתרגיל הבא. נתונה לנו...

212
01:18:44,100 --> 01:19:14,100
רשימה ומספר x. אנחנו צריכים לכתוב קוד שמדפיס האם קיימים שני עיוורים, ב- הופה, אתה רואה שכתוב פה מערך, זה שינוי שלא ישרוד את התרגול בלייב, אבל אל תדאגו, אנחנו גם נענה על האינטרצ'יינג'ביליות, מה שנקרא בין רשימה ומערך. אז מה שאני בא להגיד, יש לנו רשימה ומספר x ואנחנו רוצים לבדוק האם קיימים

213
01:19:14,100 --> 01:19:43,180
שני איברים ברשימה הזאת שהסכום שלהם הוא בדיוק x, לדוגמה יש לנו רשימה עם האיברים 0, 10, 3, ו-1 ו-x שווה 11, אז רמז 10 פלוס 1 שווה 11, אז כזה דבר אנחנו נרצה להדפיס true מצד שני עבור x שווה 12, לא, נדפיס false, איך היינו עושים את זה? תראו.

214
01:19:43,180 --> 01:20:13,160
יש לנו כאן קצת מחשבה. אז אני אומר לכם בואו לא נסתבך יותר מדי ונחשוב על זה בצורת הברוט פורס מה שנקרא, נחשוב על זה בצורה הכי במרכאות מטופשת אבל שבטוח תעבוד. מה הצורה הזאת שהיא מטופשת אבל בטוח תעבוד? אנחנו נעשה שתי לולאות, לולאה חיצונית.

215
01:20:13,160 --> 01:20:42,360
פשוט תעבור על כל עבר ברשימה. הלולאה הפנימית היא תעבור על כל עבר ברשימה מהעבר הנוכחי של הלולאה החיצונית עד הסוף. מה זה אומר? לולאה חיצונית מתחילה, אני מסתכל על 0. לולאה פנימית מתחילה, אני מסתכל על 10. אחר כך על 3. אחר כך על 1.

216
01:20:42,840 --> 01:21:33,040
גמרנו. לולא חיצונית עוברת הלאה, לעשר. לולא פנימית מתחילה. אני מסתכל שלוש. אני מסתכל אחד. גמרנו. בקיצור, זאת לולא חיצונית שעוברת על האיברים של הרשימה, ולולא פנימית שעוברת על האיבר הבא, אחרי החיצוני הנוכחי, והלאה. למה? ככה, בצורה עיוורת, א... אז רקע מדי דברים, גמר מאוד דברים, מאגר נלויות גמור בנוכחיות. כל הדברים האלה, שאני אומר רק לדעתי עגב, הם מקומטות של מדרגות החיים או בעצם חיים כל מיני חשופיות בשלפעמים שחייב להיות מתי צר

217
01:20:42,840 --> 01:20:54,300
גמרנו, לולה חיצונית עוברת הלאה ל-10, לולה פנימית מתחילה, אני מסתכל 3, אני מסתכל 1, גמרנו.

218
01:20:54,300 --> 01:21:12,260
בקיצור זאת לולה חיצונית שעוברת על האיברים של הרשימה ולולה פנימית שעוברת על האיבר הבא אחרי החיצוני הנוכחי והלאה. למה? ככה בצורה איברת אנחנו עוברים על כל זוגות האיברים האפשריים ברשימה?

219
01:21:12,260 --> 01:21:41,960
ברשימה, ואז מה אנחנו נעשה? סכום! אנחנו פשוט נבדוק סכום, אם האיבר, שהאיבר הנוכחי בלולה חיצונית ועוד האיבר הנוכחי בלולה הפנימית, אם הסכום שלהם שווה ל-x מצאנו ואפשר לצאת. אם לא, פשוט נעבור עליו, פשוט נעבור עליו. וזהו. יש פה קוד די טיפשי.

220
01:21:41,960 --> 01:22:11,960
כמו שאתם רואים זאת דוגמה, זו קראת לדוגמה כזה. הנה ליסט לדוגמה, הנה ה-X לדוגמה, X 13 אז לעשות הדוגמאי 10 ועוד 13 אנחנו נמצא אותו אז זה בדיוק מה שיקרה. יש לנו פה 4I בריינג' שהוא אורך הרשימה. אז אגב, מה I הולך להיות? I הולך ללכת על פני 0, 1, 2, 3. זאת רשימה באורך 4 אבל היא מזכיר לכם אינדקס 0, 1, 2, 3

221
01:22:11,960 --> 01:22:41,960
אז אתם רואים למה נוח לכתוב ככה ריינג'? לא כתבנו 0% אמרנו ריינג' של אורך הרשימה זה קל זה פשוט זה אינטואיטיבי אז לולאה חיצונית שעוברת על הרשימה אינדקסים של הרשימה ספציפית אחר כך לולאה פנימית שמתחילה בריינג' שמתחיל ב-i פלוס 1 כן זאת אומרת אם אנחנו מסתכלים כרגע על i'

222
01:22:41,960 --> 01:23:06,520
ו0, j יתחיל ב-1 כי אנחנו רוצים להסתכל על האיברים הבא בתורו. וגם זה נגמר, כמו שאתם רואים, עד לאורך הרשימה, לא כולל האורך, לא 4, אלא 3. ופה אנחנו עושים את הסכום, חישוב, האם שווה ל-x, אם כן, נגיד true, נעשה break, פשוט יצא מזה.

223
01:23:06,520 --> 01:23:36,360
ואגב, למה יש פה עוד if found break? זה אולי משהו שכדאי לדעת. אמרנו לכם ש-break יוצא מלולאה, אבל, האם הוא יוצא מכל הלולאות שהוא נמצא בפנים? לא. break יוצא מהלולאה הנוכחית שאנחנו נמצאים בפנים. אז אם נריץ פה, נגיד found שווה true, break, אנחנו נצא מהלולאה של ה-4, j. יצאנו מלולאה.

224
01:23:36,360 --> 01:24:06,360
של 4j, אנחנו עדיין בתוך הלולאה של 4i וזה למה אנחנו שואלים איפהge נמצא רואים? נמצא לי� פה והפסוק אותו לנו. ואיפהגם נמצא? אז עוד פעם בריק, הפעם זה בריק שיוצא החוצה מהמלולה החיצונית, ועכשיו אנחנו עושים פרינט את הערך הבוליאני של נמצא, אם באיזשהי נקודה עשינו בריק זה כי נמצא הפך להיות טרו ונתפיס טרו, אם אף פעם השוויון הזה...

225
01:24:06,360 --> 01:24:36,360
זה לא יתקיים, סיימנו את כל שתי הלולאות האלה עד הסוף וfound נשאר false. כמובן שלנוחותכם, יש את הפתרון הזה של של הארבע ,אתם מוזמנים לקחת אותו לשנות את הערכים או אפילו להוסיף פה input ואז לנסות לפתור את זה. ויש כאן, אני אשאיר לכם את זה בתור שאלה למחשבה, האם יש דרך לייעל את זה, אני רק אגיד לכם רוב הסיכויים

226
01:24:36,920 --> 01:24:38,620
ושאתם מוזמנים לבדוק את זה?

227
01:24:41,280 --> 01:24:43,200
בואו נדבר עוד טיפה על מחוזות.

228
01:24:43,840 --> 01:24:49,120
בקטע של האם אנחנו יכולים לפצל ולחבר מחוזות.

229
01:24:50,600 --> 01:24:58,920
בואו נסתכל על זה. יש לנו כאן מחוזת. 3x ועוד 2 שווה 5. זה טקסט, כן? מחוזת.

230
01:24:59,960 --> 01:25:06,200
אז למעשה, בפייתון לפחות, יש פונקציות כמו ספליט וג'וין.

231
01:25:06,200 --> 01:25:35,920
מה ספליט עושה? תראו. אמרנו, מחוזת שווה טקסט. ועכשיו נגיד, המשתנה סיידס שווה המחוזת פיצול סביב התו שווה. מה זה מחזיר? אני אגיד לכם מה זה מחזיר. זה מחזיר רשימה, שיש לה עכשיו איברים.

232
01:25:36,160 --> 01:26:05,520
שמוגדרים לפי הפיצול סביב התו שווה. אז אני רוצה שתראו את הקוד שכתבתי בדיוק בשביל זה. יש לנו פה קוד פייתון פשוט. כתבתי לתוכנית הזאת ספליט. הנה הסטרינג שלנו. כתבתי פרינט. מי סטרינג הית? התוכן שלו. זה מה שהולך להיות שמה. הגדרתי את הסיידס לפי מה שכתוב שמה. אמרתי סיידס זה הולך להיות רשימה.

233
01:26:05,520 --> 01:26:08,460
מפוצלת סביב התו שווה

234
01:26:08,960 --> 01:26:36,920
אפילו נתתי למשתנה left את העבר השמאלי של sides, שזה באמת הולך להיות ה-string הזה, אתם כבר תראו. ואני כתבתי בפרינט, my str, split between, שווה, looks like this, הרשימה sides, ואז גם אמרתי, the left side is left, וכן, הפיצול כולל את הרווחים שמשמאל ומימין. מה זאת אומרת? אתם כבר תראו.

235
01:26:38,160 --> 01:27:07,740
אז בואו נריץ את זה, python, split, נקודה פאי, עכשיו תסתכלו. זה ה-string, נקודה הזאת אני הוספתי, זה המחוזת שלנו, 3x רווח, ועוד רווח 2, רווח שווה, רווח 5, אני מתעקש על הרווח. עכשיו אני רוצה שתראו, עשינו כאן את פונקציית ספליט של סטרינג סביב השווה.

236
01:27:08,540 --> 01:27:35,300
ועכשיו אנחנו מקבלים רשימה, האיבר הראשון זה המחוזת, 3x רווח ועוד רווח 2, רווח. כל זה כמחוזת. האיבר הבא בתור הוא רווח 5. אז מה זה צד שמאל? מה זה sides באינדקס 0? 3x רווח ועוד רווח 2 רווח. אתם מבינים?

237
01:27:36,840 --> 01:27:48,560
אז בעצם מה שקרה כאן, יש לנו דרך חכמה לקחת מחוזת ולפצל אותה לחלקים הנפרדים שלה סביב תו או ביטוי.

238
01:27:49,520 --> 01:28:18,720
זה לא היה חייב להיות תו, זה יכול להיות גם מחוזת, כן? אתם יודעים מה? שאני רוצה להראות לכם את זה בלייב. אני הולך לעשות פה רווח, רווח, לפחות את זה למרכאות. כשאני רוצה לעשות ספליט סביב השווה, אבל גם סביב הרווח שווה רווח. כלומר, אתם רואים את זה, זה יהיה הספליט פוינט. עכשיו אני רוצה להריץ את זה. אופה.

239
01:28:18,720 --> 01:28:47,600
ראיתם? אז זה עדיין הסטרינג המקורי. טוב, עכשיו הספליט הוא לא היה סביב הסתם השווה, אז אני רוצה גם איפה כאן? הנה. אוקיי, אתם יודעים משהו? לא, השאירה לי יותר טוב. אני רוצה ממש להראות לכם את זה. תסתכלו. קח את זה, ספליט str שווה ככה.

240
01:28:47,600 --> 01:29:16,900
אז פה אני מביא לו את ספליט str כפרמטר. זהו. עכשיו עשיתי את הקוד עוד יותר גנרי. הופה. אז הנה הסטרינג שלנו, ועכשיו הסטרינג הזה, ספליט בין זה, יראה ככה. הנה הספליט.

241
01:29:16,900 --> 01:29:29,500
והפעם עשינו את הספליט שלנו סביב הרווח שווה רווח. ואם אני עכשיו מחזיר אותנו רק לשווה, זה ייראה כמו שקופית, כמו מצגת.

242
01:29:29,500 --> 01:29:46,800
אז אני מקווה שראיתם וקיבלתם תחושה טובה עכשיו לספליט ואיך שהוא עובד. והשאלה המתבקשת, מה היה קורה אם היה לנו יותר מ... יותר משווה אחד? כלומר, מה אם היה יותר?

243
01:29:46,800 --> 01:30:16,800
מהופעה אחת של מי שאנחנו עושים לו ספליט. אין בעיות? בואו נעשה את זה. אז אני עכשיו אעשה את זה comment, ואני אתן לנו mystr אחר. mystr הולך להיות 1 שווה 2 שווה 3 2024 בואו תראו. full103 במנקה את זה. תראו my str זה 1 שווה 2 שווה 3. עשינו ספליט סביב שווה וקיבלנו.

244
01:30:16,800 --> 01:30:46,800
יש לנו רשימה של שלושה איברים של האחד ואז שווה זה נקודת חלוקה, שתיים, נקודת חלוקה, שלוש ואז כמובן איבר הראשון, השמאלי זה אחד, אתם רואים? יש לנו ככה דרך לעשות את החלוקה הזאת לכמה שלא איברים שזה יצא, זה משהו ששווה להסתכל עליו

245
01:30:46,800 --> 01:31:16,800
אנחנו יכולים גם לעשות את ההפך עם ספליט, אנחנו יכולים לעשות ג'וין, כלומר אנחנו יכולים לקחת מחוזות ולהרכיב בעצם מחוזת חדשה שהיא מורכבת מהחלוקות השונות. אז סתם דוגמה, אני עכשיו אריץ בדיוק לשם זה את הקוד ג'וין.שע תסתכלו, יש לנו כאן וורדס שזה רשימה. שיש אינטרסים במה שהיא מד playlist. הופכו לנו להסתחיר  ביתר לתרגיל את זה. בהחלט לא צריכים לצפות פה. ובטחרתן לאור לגרום אותנו לדרך מפירצים .

246
01:31:16,800 --> 01:31:46,800
שלושה מחוזות: I love Python. ואני מגדיר סנטנס, הוא הולך להיות רווח, שימו לב, רווח נקודת ג'וין וכפרמטר אני מביא לו את הרשימה Word.מה המשמעות של זה? אני בעצם יוצר מחוזת חדשה.. אני מביא לו נקודת החיבור

247
01:31:46,800 --> 01:31:57,540
אני מבין את הדבק. דבק זה טוב. אני הולך להביא לו כדבק את המחוזת שהיא פשוט רווח.

248
01:31:57,540 --> 01:32:08,880
ואני אומר לו, סביב רווח, תחבר למחוזת שלמה את האיברים של הרשימה וורט.

249
01:32:08,880 --> 01:32:38,880
אז מה שהולך להיות לי, הוא הולך לכתוב: i רווח love רווח python. זה הרעיון של join, אז הנה אני רוצה להראות לכם את זה, אני אריץ לכם עכשיו את join.py, והנה הדפסה בקוד שכתבנו words is a list that looks like this, הנה התוכן של הרשימה, כמו שאתם רואים, הקוד

250
01:32:38,880 --> 01:32:42,900
מאחוריכם, זה בסך הכל פרינט F. כן?

251
01:32:42,940 --> 01:32:50,540
Sentence is the joining of words with במקום ספייס, אני רוצה לכתוב משהו אחר.

252
01:32:50,560 --> 01:32:59,760
במקום with a space, with a, נקרא לזה, with the string, ואז אני כותב.

253
01:33:03,860 --> 01:33:08,740
לא. נקרא לזה, gluestring שווה.

254
01:33:08,740 --> 01:33:38,660
או, זהו. אתם הולכים לקבל את זה בצורה הכי גנרית שיש. שזה טוב, כי זה אומר שאתם תוכלו לשנות את זה ולשחק עם זה בעצמכם. את כל זה אני הולך לשים לכם במודל, אל דאגה. אוקיי. בוא נעשה עכשיו אם זה עובד. אופה. בלי שגיא אוקטיב. תודה רבה.

255
01:33:38,660 --> 01:33:53,860
וה כמובן אשיג פה גרש כי בלי גרש אתם לא תדעו שזה סטינג סליחה יאללה או אני אוהב את זה.

256
01:33:53,860 --> 01:34:07,360
ספייסט ביטווין איצט וורד אוקיי זהו שינוי אחרון אוקיי הנה אנחנו וורדז זה רשימה שנראית ככה אתם חופשיים לשנות את וורדז.

257
01:34:07,360 --> 01:34:33,680
הנה גלו סטרינג שלנו חופשיים לשנות אותו לדוגמה דולר דולר בבקשה וורדז זה סטור שנראה ככה איי לייב פייתון ככה סנטנס זה הסתובבות של וורדז עם הסטרינג דולר דולר גרמת בין כל וורד זה נראה ככה איי דולר דולר אייב דולר דולר פייתון.

258
01:34:33,680 --> 01:35:03,660
אני חושב שאחרי שאתם ראיתם את זה זה אמור להיות לכם בדיוק ברור איך שזה עובד. זה ממש הדבק שיחבר את האיברים השונים ברשימה הזאת לסטרינג. כשכל המאה האיברים בעצמם היו סטרינג. כן? אז סתם דוגמה יש כאן מלכודת פה הם כתבו לכם מרכאות עם כלום בפנים זאת אומרת.

259
01:35:03,660 --> 01:35:31,940
אין דבק ריק נקודת ג'וין סוגריים עורבאות זה לא עובד זה גם לא יעבוד ג'וין של מה אתם לא הבאתם לו כלום עכשיו מילא הייתם אומרים מה היה קורה אם היינו עושים כזה דבר ג'וין של וורדז רק עם אקס אחד עד שתיים זה היה עובד לנו מה אתם אומרים לא בדיוק.

260
01:35:31,940 --> 01:36:01,860
כי הוא מצפה לסלייסים או לאינטג'ר כי הוא מצפה שאנחנו נביא לו. רשימה לא עכשיו זוג כי הבאנו לו פה עכשיו זוג. כשכתוב פה את המילה טופל טאפל זה משהו שאולי כדאי שתכירו יותר מאוחר בפייתון וזה תחשבו על טאפל בתור ענייה סדורה מחדווה אחד אבל בוא נדבר.

261
01:36:01,860 --> 01:36:31,460
על זה אחר כך בסדר מה שהתכוונו לכתוב מה שהתכוונו לכתוב זה וורדז עד אינדקס שתיים נניח. לא? מה רצינו? אינדקס אחד ושתיים אז סליחה להפך בוא נעשה את זה זה יעבוד זה יעבוד love פייתון שימו לב לסלייסים.

262
01:36:31,460 --> 01:37:01,460
כן, ושוב אם אתם רוצים להבין רגע מה קרה פה, למה פסיק לא עבד אז כשאני מדבר על טפל אני מקווה אולי אתם תבינו יותר טוב, אם לא אני מזמין אתכם לקרוא טיפה על מה זה טפל בפייתון אבל לא דחוף כרגע. עכשיו סוף סוף אנחנו יכולים טיפה ממש טיפה ככה לתת תקציר על פונקציות ראיתם הרבה על פונקציות בהרצאה אבל אני אתן תקציר על זה

263
01:37:01,460 --> 01:37:31,460
מה זה פונקציה? אז בצורה הכי פשוטה שיש פונקציה וכשאתם כותבים קוד שעושה פעולה, נניח הקוד הזה מקבל כלת, הוא עושה פעולה, הוא מחזיר פלט, וזה קוד שאתם יכולים לקרוא לו יותר מפעם אחת, אפילו ביותר מהקשר אחד עם יותר ממשמעות אחת. זאת אומרת זה קוד

264
01:37:31,460 --> 01:37:37,160
שיכול לעשות עבודה בשביל כמה דרישות, כמה דברים.

265
01:37:38,580 --> 01:37:43,320
זה משהו שכמובן עוזר לכם לחסוך בקוד, במקום לכתוב את אותו קוד שוב ושוב ושוב.

266
01:37:43,420 --> 01:37:49,620
אתם יכולים לכתוב אותו פעם אחת, להגיד אותו כפונקציה, פשוט לקרוא לפונקציה הזאת במקרים שונים.

267
01:37:50,980 --> 01:38:00,180
זה גם בעזרת קוד, אתם יכולים לחלק את הקוד שלכם, ממש למבנה, לתתי חלקים,

268
01:38:01,300 --> 01:38:10,400
שזה משהו אולי יסבירו לכם בקטע של להסתכל על משימה או על קוד או על פרויקט, מלמעלה למטה.

269
01:38:10,700 --> 01:38:18,360
לחשוב תמונה גדולה, ואז להיכנס פנימה לחלקים הנפרדים ולהפוך אותם למשהו שעובד.

270
01:38:19,460 --> 01:38:31,260
אבל בסדר, זה דיבור גדול. בכללי, תחשבו על פונקציה בתור אבסטרקציה, ממש כאילו הגרסה הכללית, של מה שאנחנו בעצם עושים.

271
01:38:31,260 --> 01:39:01,260
בחיים, כמתכנתים, יש לנו כלת, פרמטרים, מידע כלשהו, שאנחנו רוצים לעשות איתו משהו, אנחנו עושים איתו עבודה, ויש לנו תוצאה, יש לנו ערך שחישבנו, משהו שעשינו, וזה הפלט שלנו, זוכרים? כשאמרנו בתרגול הראשון, כלט, מחשב, פלט? זה קצת אותו מבנה, אם אתם חושבים על זה. באמת שבפונקציות, כאילו זה

272
01:39:01,260 --> 01:39:29,320
זה הלבנת בטון, זה כאילו הבסיס שלנו בתכנון. אז פה אתם רואים דוגמה מאוד מאוד בסיסית לפונקציה. תראו, אנחנו רוצים להדפיס את הסכום של האיברים ברשימה 1, 2, 3. אז פה איזה דוגמה למימוש, אז כשכותב פה sum סוגריים הרשימה הזאת, מה עשינו?

273
01:39:29,320 --> 01:39:58,920
אנחנו קראנו לפונקציה שקוראים לה sum והעברנו לה כפרמטר, כארגומנט, את הרשימה 1, 2, 3. איפה הפונקציה sum מוגדרת? איפה המימוש שלה? איפה הקוד שרץ כשאנחנו קוראים לה sum? במקרה של הדוגמה הזאת, זה נמצא פה. אנחנו כותבים בפייתון ככה.

274
01:39:59,640 --> 01:40:27,520
def, שזה קיצור ל-define, הגדרה או להגדיר. אז אנחנו אומרים def, רווח, שם הפונקציה, סוגריים, פרמטרים אפשריים שהפונקציה יכולה לקבל, והשם שאנחנו נתייחס אליהם, איתו, בפונקציה. אז פה אנחנו מגדירים פונקציה בשם sum, שתקבל כפרמטר משתנה שקוראים לו LST.

275
01:40:27,520 --> 01:40:57,520
אז def, sum, עם פרמטר lst, נקודתיים. ואז פה יש כמובן הזכה, אינדטציה, כמו שאתם זוכרים, מתנאים, לולאות. וקוד, קוד שפשוט עושה עבודה. אז אנחנו מחשבים סכום, אז מה קורה? נגדיר איזה שהוא משתנה, סתם לדוגמה. נקרא לך, לא יודע, mid. אז אתה יודע, אנחנו לא עושים איתו כלום, אז זה סתם, לדוגמה. אקדמנו משתנה...

276
01:40:57,520 --> 01:41:27,520
לו mid, נתנו לו ערך 0 ולא עושים איתו כלום יתר אבל הנה מה שאנחנו כן עושים, נגדיר סכום רץ בתור 0 ועכשיו נעשה להולעת four לכל מספר ברשימה סכום רץ פלוס שווה המספר הנוכחי, סיימנו את הפור זה אומר שסיימנו לעבור לרשימה ובסכום רץ יש לנו את הסכום הסופי ומה אנחנו עושים איתו? ריטרן, זאת מילת

277
01:41:27,520 --> 01:41:40,060
גם בפייתון וגם בהרבה סופות תכנות אחרות שאומרת זה הערך שהפונקציה תחזיר כשהיא תסיים לראות אז בעצם.

278
01:41:40,060 --> 01:41:57,160
קראנו לסם הבאנו לה את הרשימה הזאת 1,2,3 בתור ליסט עכשיו זה שכתוב פה LST לא אומר שזה סם בהכרח תקבל את זה כרשימה אלא זה פשוט שם משתנה, שם משתנה שקוראים לו ליסט.

279
01:41:57,160 --> 01:42:26,840
אנחנו פשוט במקרה שולחים לשם רשימה אז זה מה שאנחנו עושים, מהתחילים סם 1 שווה 0 עוברים על המספרים ברשימה סוכמים ואנחנו עושים ריטרן מה זה אומר כשהפייתון תריץ סם של רשימה 1,2,3 כל זה ביטוי שיחושב להיות 1 ועוד 2 ועוד 3.

280
01:42:26,840 --> 01:42:56,740
שזה 6 כלומר נתפיס 6. עכשיו שימו לב. יש קטע כזה של סקופ שאני אתן לכם את הגרסה הקצרה. אבל משתנה הזה כאן mid הוא ייעלם אחרי שהפונקציה תסיים לרוץ. בעצם כל מה שקורה פה בתוך הפונקציה נעלם אחרי שהפונקציה מסיימת לרוץ. חוץ מהערך הזה ריטרן שאותו אנחנו מחזירים.

281
01:42:56,980 --> 01:43:26,340
כלומר כשנכתוב את הסאם סוגריים פרמטר סגור סוגריים כל זה פייתון יחשב ויקבל את ערך הריטרן. כל מה שקרה פה בפנים הכל טוב ויפה אף מהזיכרון נעלם נגמר. בהרצאה אני חושב שדיברו איתכם על זה אבל גם אם לא קיבלתם עכשיו תקציר לפונקציה לדוגמה שלה ובערך מה שקורה כשהיא רצה.

282
01:43:26,340 --> 01:43:56,240
ואחרי שהיא סיימה לרוץ. אגב ראינו הרבה פונקציות זוכרים שראינו מקס מין סאם ראינו. כמעט כל פעם בעצם שאתם ראיתם בפייתון ראיתם בפייתון נניח סאמתינג כל דבר סוגריים. זה היה פונקציה סאמתינג היה פונקציה ובתוך הסוגריים פרמטר של הפונקציה.

283
01:43:56,240 --> 01:44:26,240
פונקציה או יותר מאחד ריינג׳ תאמינו לו ריינג׳ היא פונקציה והבאנו לה פרמטרים כדאי לדעת אגב איך זה יכול להיות אבל לא הבאנו לריינג׳ תמיד הכל אז התשובה היא נכון הרבה פונקציות יודעות לתת ברירת מחדל למה שלא כתבתם זאת אומרת כתבתי פה ריינג׳

284
01:44:26,240 --> 01:44:56,240
אבל זה אותו דבר בדיוק כמו להגיד ריינג' 0 פסיק 10 פסיק 1, הוא פשוט הבין שאם לא כתבתם את זה וגם את זה זה הולך להיות ברירת מחדל, אז משהו לזכור. הנה דוגמא לקוד שאולי אנחנו יכולים לייעל אותו בעזרת פונקציה. אנחנו קולטים גיל וקולטים מספר ילדים.

285
01:44:56,620 --> 01:45:26,320
נתחיל לקלוט גיל, אנחנו רוצים שהגיל הזה יהיה חיובי, כן? וגם מספר ילדים שיהיה חיובי, אז רגע, אנחנו עושים פה קלט, מתחילים משתנה במינוס 1, כל עוד שהמשתנה שלילי, מקבלים אינפוט, הופכים אותו לאינט, ואז אם זה קטן מ-0, חוזרים חזרה לווואיל, רגע.

286
01:45:26,320 --> 01:45:55,780
אנחנו עושים את זה פעמיים, גם פה בקליטת גיל, גם פה בצ'ילדרן, אפשר לייעל את זה, אפשר לכתוב פונקציה עם כל הקוד הזה, פשוט לכל הפעמיים, אז זה מה שנעשה, נגדיר פונקציה, דפיין, גט אינפוט, אפילו נשלח לה כפרמטר את הפרומפט, את הסטרינג הזה, שאתם מראים למסך כשאתם מבקשים מהמשתמש קלט, וככה נגדיר את הפונקציה.

287
01:45:55,780 --> 01:46:25,260
בצורה כללית, נגיד, ריזולט שווה מינוס 1, ואז ווייל הריזולט קטן מ-0, נקלוט אינפוט, מה יהיה כתוב למסך? הפרומפט הזה שנקבל כמחוזת, נהפוך את זה לאינטג'ר, ואז אם התוצאה שקיבלנו הייתה קטנה מ-0, נגיד, היי, הערך צריך להיות חיובי, ופשוט נחזור חזרה להתחלה של הווייל, וזה ימשיך עד שריזולט הוא אי שלילי, ונחזיר רק את הריזולט.

288
01:46:25,260 --> 01:46:55,220
ועכשיו תראו איך קראנו לפונקציה, פעמיים, אייג' שווה למה שהפונקציה תחזיר, איזו פונקציה? גט אינפוט, ונשלח לה את הפרומפט, כמחוזת, Enter the Age, נקודתיים רווח, וצ'ילדרן, גם, גט אינפוט בסוגריים, Enter Num of Children, נקודתיים מרכאות, אתם מבינים? קוד אחד, שני שימושים, זה...

289
01:46:55,220 --> 01:47:25,220
אולי הדוגמה הכי בסיסית שיש לפונקציה. עכשיו אתה גיל 5 בוא נכתוב פונקציה שמקבלת מחוזת שהוא בעצם תאריך, זאת אומרת אנחנו צריכים לקבל מחוזת שזה יהיה הפורמט שלה, ספרה ספרה סלאש ספרה ספרה סלאש ארבע ספרות, יהיה לנו תאריך של יום חודש שנה והפונקציה תקשורת יום חודש שנה יהיה יותר טוב לפי רכבת ישראל

290
01:47:25,220 --> 01:47:55,220
צריכה לקחת את המחוזת הזאת שהיא תקבל ולהחזיר אותה בפורמט הפוך, שנה חודש יום. איך? רמז, אתם רואים את הסלשים האלה? סלשים? לא למדנו משהו על הספליט וג'וין? וסלייסים שלותנים לנו להפוך את הסדר של רשימה? זה זה. אז הנה הפתרון, נגדיר פונקציה, דפיין, א.. אז להפוך מהפונקציה הזאת מהחוזת הזאת שהיא תקבל לכולנו

291
01:47:55,220 --> 01:48:25,220
reverse date בסוגריים תקבל תאריך ומה נגיד חלקים יהיה שווה תוצאת התאריך שזה יהיה בעצם החוזה, נקודה ספליט, ספליט סביב מה? סלאש, אוקיי פיצלנו לרשימה וברשימה יהיה לנו מספר, סליחה מספר, מה זה מספר? יהיה לנו מחוזה של היום, מחוזה של החודש ומחוזה של השנה.

292
01:48:26,200 --> 01:48:56,200
עכשיו נגיד, פארץ תהפחית הסדר, עכשיו אני רשימה עם מחוזת של שנה, מחוזת של יום, סליחה מחוזת של חודש ואז מחוזת של יום, ואז נעשה ישר ריטרן מחוזת, שהיא התוצאה של ג'וין של רשימת הפארץ שבדיוק הפכנו סביב איזה דבק? 
סלאש, אז אני אראה לכם שהצלחתי,

293
01:48:56,200 --> 01:49:26,200
באמת את q5 ממומשת. הנה הקוד בדיוק עכשיו שאתם ראיתם במצגת, זה בדיוק פה. איך אנחנו קוראים לפונקציה? נגיד date שווה להיות ה- input של בבקשה תכניסו תאריך בפורמט הזה, נריץ את זה. וnew date יהיה הרברז של הדייט שבדיוק עכשיו קלטנו. דרך אגב כשכתוב פה דייט,

294
01:49:26,800 --> 01:49:56,800
ובדפיין בפרמטר דייט זה לא אותו דבר. פה אנחנו מביאים כפרמטר את המשתנה דייט הזה, אבל כשבדפיין כתוב reverse date ואז פרמטר דייט, כל משתנה שreverse date יקבל כפרמטר, מקומית הוא יתייחס אליו בתור דייט. אם זה מבלבל אתכם צריך קצת לדבר יותר על הנושא של סקופ של משתנים, דובר על זה בהרצאה. אולי

295
01:49:56,800 --> 01:50:26,800
בתרגולים נזכיר את זה יותר בהמשך אבל רק תזכרו שזה לא אותו דבר בסדר? עכשיו, פרינט reverse the format date is a new date. ברור, נראה לכם שזה באמת רץ, python cue 5.py. Please enter a date in the format of יום, חודש ושנה עם סלאש באמצע. טוב אני לא יצירתי מאוד, אני אכתוב 11 סלאש

296
01:50:26,800 --> 01:50:46,480
‫12 / 2013, סתם. ‫אנטר. ‫והוא הופך. ‫2013 / 12 / 11. ‫איך זה עבד? ‫לפי הספליט וג'וין שלמדנו מוקדם יותר בתרגול. בדיוק.

297
01:50:48,780 --> 01:51:18,780
עכשיו, בעיקרון, פייתון בכלל, אחלה שפת תכנות, אפשר לעשות איתה דברים עם פונקציות שלא בכל שפת תכנות זה יעבוד, חלק כן, חלק לא, בפייתון, באמת אפשר לקבל יותר מערך חזרה אחד, אז הנה דוגמה, סתם דוגמה, פונקציה שמקבלת רשימה, והיא תחזיר גם את הסכום, וגם את המקס, פתאום לא לעזאזל

298
01:51:18,780 --> 01:51:48,780
מפה עם פסיק בהאמצע. בפייתון יש לנו הרבה פעמים יכולת לעבוד עם יותר מערך אחד בצורה קונטקסטואלית. אולי במקרים אחרים אתם תראו דוגמאות לזה, אבל פה זה כאילו סתם משהו להראות לכם של היי, זה אפשרי. אגב, כמובן שפונקציה יכולה פשוט לא לתת שום ערך חזרה ואז כל הפואנטיה של לקרוא לפונקציה זה פשוט

299
01:51:48,780 --> 01:52:18,780
לקרוא לפונקציה, כן? שהיא תעשה עבודה ותסיים, אז פה אתם רואים דוגמאות, נניח מגדירים פונקציה שמקבלת רשימה, נקודתיים, והיא פשוט תדפיס את הרשימה, גמרנו, אז יש הרבה דרכים להגיד לפונקציה שהיא לא יהיה לערך חזרה, אנחנו יכולים פשוט לא לכתוב ריטרן, לכתוב ריטרן כלום, שזו מילה שמורה,

300
01:52:18,780 --> 01:52:48,780
נן אם אין גדולה ראשונה, אף שתכתוב ריטרן שום דבר. עכשיו לכתוב ריטרן ואז כלום זה אפילו משהו שבשפות תכנות אחרות אתם תראו, האמת, אין גם וריאציה של ריטרן כלום, זה גם משהו שאתם תראו. עכשיו אולי מוקדם יותר בתרגול אתם תפסתם אזכור של המילה מערך, תראו.

301
01:52:48,780 --> 01:53:18,780
בעיקרון, לפחות בעולם של פייטו, אתם צריכים להכיר את ההבדל המהותי הגדול ביותר בין מה זה מערך ורשימה, שעבדנו עכשיו בתרגול הזה עם רשימות כל הזמן. מבחינתכם, מערך זה כמו רשימה, רק שכל האיברים במערך הם מאותו טיפוס, מאותו טייפ. אז כשאתם ראיתם...

302
01:53:18,780 --> 01:53:37,200
בהתחלה, התחלה התחלה של התרגול, בוא נראה, איפה אתם ראיתם? הנה, אם אתם הייתם ראיתם בהתחלה של התרגול, רשימה שהאיברים של הזה, אחד, 3.2, מוחזת high ובוליאן פולס, זה ספציפית לא דבר שאפשרי במערך.

303
01:53:37,260 --> 01:54:06,720
כל שאר הדברים שהראינו ברשימה בתרגול עד עכשיו, זה בעצם דברים שעובדים במערך. למה? כי הראינו רשימות, שכל האיברים שהיו בתוך הרשימה היו בדיוק מאותו טיפוס. כל מה שעשינו עד עכשיו, היה בעצם רלוונטי לחלוטין למערך. רק מה? במערך אי אפשר לשמור ככה דברים מטיפוסים שונים, זה לא ילך.

304
01:54:07,620 --> 01:54:36,500
אוקיי, אז, עכשיו, אתם מבינים, אנחנו, למעשה בפייתון בכלל, אם אנחנו רוצים לעבוד עם הראי, יש לנו פקאג' שקוראים לו הראי, הוא בלתי לתוך פייתון, הכל טוב, אנחנו אבל צריכים לייבא אותו. זה לא משהו שאתם יכולים סתם ככה לעשות הראי, אז פה דוגמא אנחנו נגדיר a הולך להיות שווה לתראו מה עשינו, עשינו אימפורט לספרייה.

305
01:54:36,500 --> 01:55:06,500
שקוראים לה array, נתנו לה שם קצר arrr� ומה אנחנו אומרים המשתנה a אתה הולך להיות שווה ל... כתוב פה arrr נקודה. מה זה אומר? אנחנו מביאים לכאן פונקציה שמגיע מתוך הספרייה arrr. arr זה פשוט ראיתם? אימפורט משהו בתור שם אחר, בעצם זה כמו לכתוב a שווה ל arrr נקודה לאתר, שוב לא structures שלך לגרסר לעומות

306
01:55:06,500 --> 01:55:36,500
פשוט הופכים את a להיות array של ואנחנו מביאים את זה כפרמטרים ואם לא Тогда i ואז רשימה של 1,2,3 הוא לא יאהב את זה הוא לא יאהב את זה בכלל. כאילו, מה שהוא לא יאהב סליחה סליחה אני קצת בלבטתכם, מה שהוא לא יאהב זה אם פה רשימה, אם ...

307
01:55:36,500 --> 01:56:06,500
int int ואז float אבל אני כן רוצה להראות לכם, האמת, האם הוא יודע להתמודד עם ה RA מהסוג הראשון אז בואו נריץ באמת פייתון ונבדוק את זהcessuaI sendptI imports ray as R, עשינו את זה, A שווה ל R.RA של התוואי פסיק ואז הרשימה 1,2,3... סגור סוג R, הוא קיבל את זה! משב.שתיק! ואאאלה!

308
01:56:07,500 --> 01:56:09,880
מעניין מאוד

309
01:56:10,700 --> 01:56:24,260
אז מה שאנחנו רואים כאן, זה עדיין אריי, שכן יודע לקבל כרקטר, ואז רשימה.

310
01:56:25,160 --> 01:56:40,640
אה, אבל אני אגיד לכם מה הוא לא אוהב. אם אני אנסה להגיד אריי, עכשיו להפוך אותו אריי, עם קרקטר, ואז כאן רשימה שבעצמה יש איברים, שהם לא כולם אותו סוג, אז...

311
01:56:40,640 --> 01:56:48,040
אז בגלל שהרשימה הזאת תהיה שמורה בזיכרון בצורה הרבה יותר לא קונבנציונלית,

312
01:56:48,420 --> 01:56:54,120
מאשר רשימה שבה כל הערכים שלהם מאותו סוג, זה מה שהערי לא יוכל להתמודד איתו.

313
01:56:54,960 --> 01:57:01,960
זאת אומרת, הוא לא יכול להתמודד עם הרשימה הזאת בגלל הfloat כאן.

314
01:57:02,780 --> 01:57:07,720
אז אפילו שאנחנו אומרים לכם שמערך זה אוסף של איברים מאותו טיפוס, פה ספציפית,

315
01:57:10,000 --> 01:57:40,000
array הזה שמגיע מתוך הספרייה  הרה של פייתון זה עדיין array שיש לו גמישות מסויימת אבל תעשו טובה מבקשה גם למערצים שלכם ולתרגילים שלכם, בפחות בקורס הזה, תתייחסו למערך בתור אוסף שאיברים מאותו טיפוס בדיוק מה שראינו כאן זה מקרה קיצון שכן עובד, זה רק שתדעו ולהגיד את האמת

316
01:57:40,000 --> 01:58:10,000
באופן כללי יש הרבה שפות תכנות שבהן כשאתם מסתכלים על מערך בכלל, אגב זה שכתוב פה לדוגמה בהרבה שפות תכנות שאינן פייתון אז האמת שגם בפייתון לפעמים איברים במערך כן יושבים בצורה רציפה בזיכרון אז נגיד בהרבה שפות תכנות, זהו נשאיר את זה ככה, בהרבה שפות תכנות..

317
01:58:10,000 --> 01:58:26,500
שתדעו, במערך אמיתי, האיברים יושבים בזיכרון בצורה רציפה, זאת אומרת, ממש אתם מביאים מערך מוגדר מראש, תסתכלו פה, יש לכם כאן דוגמא לשפת תכנונות C או C++, תסתכלו מה כתוב פה.

318
01:58:26,900 --> 01:58:51,620
אנחנו מגדירים כאן מערך של אינטג'רים, אנחנו אומרים אינט, כלומר, מכריזים על משהו שמטיפוס אינטג'רים, שם משתנה, סוגריים מרובעות ככה, שזה בעצם אומר, אנחנו מכריזים על מערך בשם A מסוג אינטג'רים, והנה התוכן שלו, 1 ואז 2 ואז 3.

319
01:58:51,620 --> 01:59:20,920
הרעיון הוא שבגלל שב-C בכלל, אובייקט אינטג'ר, אנחנו יודעים בדיוק מה הגודל שלו, הגודל שלו זה 4 בייטים, אינטג'ר ב-C לפחות, ב-C, כזה בשפת תכנונות C, אינטג'ר is 32 bits, שזה שווה ל-4 בייטס, בזיכרון.

320
01:59:20,920 --> 01:59:50,920
וזה למה, אם אתם מגדירים מראש מערך, אז הצורה הכי מהירה, הכי מסודרת לכתוב אותו בזיכרון, זה בצורה רציפה. אז פה אתם רואים קפיצות של ארבע בכתובת זיכרון שבו האיברים שמורים בזיכרון של המערך הזה. זה כבר העשרה, כן? כאילו, אם תרצו להעמיק על זה, אתם כבר תגלו עוד על זיכרון ועל הצורה שבדברים שמורים, אבל זה סתם שתדעו, שתדעו איך מערך ...

321
01:59:50,920 --> 02:00:20,920
ואני עכשיו לוקח את הידיים שלי בחיים האמיתיים ועושה מרחאות. מערך, איך מערך הוא במרחאות עובד באמת. סגור מרחאות. וזהו, כל הכבוד לכם ששרדתם את התרגול המוקלט מראש האקסטנדד הזה. נתראה שבוע הבא.

